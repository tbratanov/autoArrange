{"version":3,"file":"core.umd.min.js","sources":["../src/metrics/const/metric-types.ts","../src/metrics/protocols/gw3/serializer.ts","../src/metrics/helpers.ts","../src/metrics/metrics/base.ts","../src/metrics/metrics/number.ts","../src/metrics/metrics/object.ts","../src/metrics/metrics/string.ts","../src/metrics/metrics/timestamp.ts","../src/metrics/repository.ts","../src/metrics/system.ts","../src/metrics/protocols/null/null.ts","../src/metrics/pertTracker.ts","../src/metrics/main.ts","../src/metrics/protocols/gw3/gw3.ts","../node_modules/callback-registry/lib/index.js","../src/connection/transports/inProc.ts","../src/connection/transports/worker.ts","../src/utils/utils.ts","../src/utils/pw.ts","../src/utils/timer.ts","../src/connection/transports/ws.ts","../node_modules/shortid/lib/random/random-from-seed.js","../node_modules/shortid/lib/alphabet.js","../node_modules/shortid/lib/random/random-byte-browser.js","../node_modules/shortid/lib/encode.js","../node_modules/shortid/lib/decode.js","../node_modules/shortid/lib/is-valid.js","../node_modules/shortid/lib/index.js","../node_modules/shortid/index.js","../src/connection/protocols/gw3Domain.ts","../src/connection/protocols/gw3.ts","../src/connection/replayer.ts","../src/utils/promise-plus.ts","../src/connection/transports/webPlatform.ts","../src/connection/connection.ts","../src/logger/logger.ts","../src/contexts/bridges/gw3/messages.ts","../src/contexts/contextMessageReplaySpec.ts","../src/contexts/bridges/gw3/contextData.ts","../src/contexts/helpers.ts","../src/contexts/bridges/gw3/bridge.ts","../src/interop/client/client.ts","../src/contexts/contextsModule.ts","../src/interop/helpers/promisify.ts","../src/interop/helpers/promiseHelpers.ts","../src/interop/server/subscription.ts","../src/interop/server/request.ts","../src/interop/server/streaming.ts","../src/interop/server/branch.ts","../src/interop/server/stream.ts","../src/interop/server/server.ts","../src/interop/instance.ts","../src/interop/client/repository.ts","../src/interop/server/repository.ts","../src/interop/protocols/gw3/server-streaming.ts","../src/interop/protocols/gw3/server.ts","../src/interop/protocols/gw3/subscription.ts","../src/interop/protocols/gw3/client-streaming.ts","../src/interop/protocols/gw3/client.ts","../src/interop/protocols/gw3/factory.ts","../src/interop/interop.ts","../src/bus/main.ts","../src/index.ts","../src/config.ts"],"sourcesContent":["export default {\r\n    STRING: 1,\r\n    NUMBER: 2,\r\n    TIMESTAMP: 3,\r\n    OBJECT: 4\r\n};\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport MetricTypes from \"../../const/metric-types\";\r\n\r\nfunction getMetricTypeByValue(metric: Glue42Core.Metrics.Metric): string {\r\n\r\n    if (metric.type === MetricTypes.TIMESTAMP) {\r\n        return \"timestamp\";\r\n    } else if (metric.type === MetricTypes.NUMBER) {\r\n        return \"number\";\r\n    } else if (metric.type === MetricTypes.STRING) {\r\n        return \"string\";\r\n    } else if (metric.type === MetricTypes.OBJECT) {\r\n        return \"object\";\r\n    }\r\n\r\n    return \"unknown\";\r\n}\r\n\r\nfunction getTypeByValue(value: any): string {\r\n\r\n    if (value.constructor === Date) {\r\n        return \"timestamp\";\r\n    } else if (typeof value === \"number\") {\r\n        return \"number\";\r\n    } else if (typeof value === \"string\") {\r\n        return \"string\";\r\n    } else if (typeof value === \"object\") {\r\n        return \"object\";\r\n    } else {\r\n        return \"string\";\r\n    }\r\n}\r\n\r\nfunction serializeMetric(metric: Glue42Core.Metrics.Metric): any {\r\n\r\n    const serializedMetrics: any = {};\r\n    const type = getMetricTypeByValue(metric);\r\n    if (type === \"object\") {\r\n        const values = Object.keys(metric.value).reduce((memo: any, key: any) => {\r\n            const innerType = getTypeByValue(metric.value[key]);\r\n            if (innerType === \"object\") {\r\n                const composite = defineNestedComposite(metric.value[key]);\r\n                memo[key] = {\r\n                    type: \"object\",\r\n                    description: \"\",\r\n                    context: {},\r\n                    composite,\r\n                };\r\n            } else {\r\n                memo[key] = {\r\n                    type: innerType,\r\n                    description: \"\",\r\n                    context: {},\r\n                };\r\n            }\r\n\r\n            return memo;\r\n        }, {});\r\n\r\n        serializedMetrics.composite = values;\r\n    }\r\n\r\n    serializedMetrics.name = normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name);\r\n    serializedMetrics.type = type;\r\n    serializedMetrics.description = metric.description;\r\n    serializedMetrics.context = {};\r\n\r\n    return serializedMetrics;\r\n}\r\n\r\nfunction defineNestedComposite(values: any): any {\r\n    return Object.keys(values).reduce((memo: any, key: any) => {\r\n        const type = getTypeByValue(values[key]);\r\n        if (type === \"object\") {\r\n            memo[key] = {\r\n                type: \"object\",\r\n                description: \"\",\r\n                context: {},\r\n                composite: defineNestedComposite(values[key]),\r\n            };\r\n        } else {\r\n            memo[key] = {\r\n                type,\r\n                description: \"\",\r\n                context: {},\r\n            };\r\n        }\r\n\r\n        return memo;\r\n    }, {});\r\n}\r\n\r\nfunction normalizeMetricName(name: string): string {\r\n    if (typeof name !== \"undefined\" && name.length > 0 && name[0] !== \"/\") {\r\n        return \"/\" + name;\r\n    } else {\r\n        return name;\r\n    }\r\n}\r\n\r\nfunction getMetricValueByType(metric: Glue42Core.Metrics.Metric) {\r\n    const type: string = getMetricTypeByValue(metric);\r\n    if (type === \"timestamp\") {\r\n        return Date.now();\r\n    } else {\r\n        return publishNestedComposite(metric.value);\r\n    }\r\n}\r\n\r\nfunction publishNestedComposite(values: any) {\r\n    if (typeof values !== \"object\") {\r\n        return values;\r\n    }\r\n    return Object.keys(values).reduce((memo: any, key: any) => {\r\n        const value = values[key];\r\n        if (typeof value === \"object\" && value.constructor !== Date) {\r\n            memo[key] = publishNestedComposite(value);\r\n        } else if (value.constructor === Date) {\r\n            memo[key] = new Date(value).getTime();\r\n        } else if (value.constructor === Boolean) {\r\n            memo[key] = value.toString();\r\n        } else {\r\n            memo[key] = value;\r\n        }\r\n\r\n        return memo;\r\n    }, {});\r\n}\r\n\r\nfunction flatten(arr: any[]): Glue42Core.Metrics.SystemStateInfo[] {\r\n    return arr.reduce((flat: Glue42Core.Metrics.SystemStateInfo[], toFlatten: Glue42Core.Metrics.SystemStateInfo | Glue42Core.Metrics.SystemStateInfo[]): Glue42Core.Metrics.SystemStateInfo[] => {\r\n        return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);\r\n    }, []);\r\n}\r\n\r\nfunction getHighestState(arr: Glue42Core.Metrics.SystemStateInfo[]): Glue42Core.Metrics.SystemStateInfo {\r\n    return arr.sort((a, b) => {\r\n        if (!a.state) { return 1; }\r\n        if (!b.state) { return -1; }\r\n\r\n        return b.state - a.state;\r\n    })[0];\r\n}\r\n\r\nfunction aggregateDescription(arr: Glue42Core.Metrics.SystemStateInfo[]): string {\r\n    let msg = \"\";\r\n    arr.forEach((m: any, idx: number, a: any[]) => {\r\n        const path = m.path.join(\".\");\r\n        if (idx === a.length - 1) {\r\n            msg += path + \".\" + m.name + \": \" + m.description;\r\n        } else {\r\n            msg += path + \".\" + m.name + \": \" + m.description + \",\";\r\n        }\r\n    });\r\n    if (msg.length > 100) {\r\n        return msg.slice(0, 100) + \"...\";\r\n    } else {\r\n        return msg;\r\n    }\r\n}\r\n\r\nfunction composeMsgForRootStateMetric(system: Glue42Core.Metrics.System): any {\r\n    const aggregatedState: Glue42Core.Metrics.SystemStateInfo[] = system.root.getAggregateState();\r\n    const merged = flatten(aggregatedState);\r\n    const highestState = getHighestState(merged);\r\n    const aggregateDesc = aggregateDescription(merged);\r\n    return {\r\n        description: aggregateDesc,\r\n        value: highestState.state,\r\n    };\r\n}\r\n\r\nexport { normalizeMetricName, serializeMetric, getMetricValueByType, composeMsgForRootStateMetric };\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { Protocol } from \"./types\";\r\n\r\nexport default {\r\n    validate: (definition: Glue42Core.Metrics.MetricDefinition, parent: Glue42Core.Metrics.System, transport: Protocol) => {\r\n        if (definition === null || typeof definition !== \"object\") {\r\n            throw new Error(\"Missing definition\");\r\n        }\r\n        if (parent === null || typeof parent !== \"object\") {\r\n            throw new Error(\"Missing parent\");\r\n        }\r\n        if (transport === null || typeof transport !== \"object\") {\r\n            throw new Error(\"Missing transport\");\r\n        }\r\n    },\r\n};\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport Helpers from \"../helpers\";\r\nimport { Protocol } from \"../types\";\r\n\r\nexport class BaseMetric<T> implements Glue42Core.Metrics.Metric {\r\n    public readonly path: string[] = [];\r\n    public readonly name: string;\r\n    public readonly description: string | undefined;\r\n\r\n    public get repo() {\r\n        return this.system?.repo;\r\n    }\r\n\r\n    public get id() { return `${this.system.path}/${name}`; }\r\n\r\n    constructor(public definition: Glue42Core.Metrics.MetricDefinition, public system: Glue42Core.Metrics.System, protected transport: Protocol, public value: T, public type: number) {\r\n        Helpers.validate(definition, system, transport);\r\n\r\n        this.path = system.path.slice(0);\r\n        this.path.push(system.name);\r\n\r\n        this.name = definition.name;\r\n        this.description = definition.description;\r\n\r\n        transport.createMetric(this);\r\n    }\r\n\r\n    public update(newValue: T): Promise<void> {\r\n        this.value = newValue;\r\n        return this.transport.updateMetric(this);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class NumberMetric extends BaseMetric<number> implements Glue42Core.Metrics.NumberMetric {\r\n\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: number) {\r\n        super(definition, system, transport, value, metricTypes.NUMBER);\r\n    }\r\n\r\n    public incrementBy(num: number): void {\r\n        this.update(this.value + num);\r\n    }\r\n\r\n    public increment(): void {\r\n        this.incrementBy(1);\r\n    }\r\n\r\n    public decrement(): void {\r\n        this.incrementBy(-1);\r\n    }\r\n\r\n    public decrementBy(num: number): void {\r\n        this.incrementBy(num * -1);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class ObjectMetric extends BaseMetric<object> implements Glue42Core.Metrics.ObjectMetric {\r\n\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: object) {\r\n        super(definition, system, transport, value, metricTypes.OBJECT);\r\n    }\r\n\r\n    public update(newValue: object): Promise<void> {\r\n        this.mergeValues(newValue);\r\n        return this.transport.updateMetric(this);\r\n    }\r\n\r\n    private mergeValues(values: any) {\r\n        return Object.keys(this.value).forEach((k) => {\r\n            if (typeof values[k] !== \"undefined\") {\r\n                (this.value as any)[k] = values[k];\r\n            }\r\n        });\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class StringMetric extends BaseMetric<string> implements Glue42Core.Metrics.StringMetric {\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: string) {\r\n        super(definition, system, transport, value, metricTypes.STRING);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { BaseMetric } from \"./base\";\r\nimport metricTypes from \"../const/metric-types\";\r\n\r\nexport class TimestampMetric extends BaseMetric<Date> implements Glue42Core.Metrics.TimestampMetric {\r\n    constructor(definition: Glue42Core.Metrics.MetricDefinition, system: Glue42Core.Metrics.System, transport: Protocol, value: Date) {\r\n        super(definition, system, transport, value, metricTypes.TIMESTAMP);\r\n    }\r\n\r\n    public now(): void {\r\n        this.update(new Date());\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport system from \"./system\";\r\nimport { MetricsSettings, Protocol } from \"./types\";\r\n\r\nexport class Repository implements Glue42Core.Metrics.Repository {\r\n    public root: Glue42Core.Metrics.System;\r\n\r\n    constructor(options: MetricsSettings, protocol: Protocol) {\r\n        protocol.init(this);\r\n        this.root = system(\"\", this, protocol);\r\n\r\n        this.addSystemMetrics(this.root, options.clickStream || options.clickStream === undefined);\r\n    }\r\n\r\n    private addSystemMetrics(rootSystem: Glue42Core.Metrics.System, useClickStream: any) {\r\n        // Create some system metrics\r\n        if (typeof navigator !== \"undefined\") {\r\n            rootSystem.stringMetric(\"UserAgent\", navigator.userAgent);\r\n        }\r\n\r\n        if (useClickStream && typeof document !== \"undefined\") {\r\n            const clickStream: Glue42Core.Metrics.System = rootSystem.subSystem(\"ClickStream\");\r\n\r\n            const documentClickHandler = (e: Event) => {\r\n                if (!e.target) {\r\n                    return;\r\n                }\r\n                const target = e.target as HTMLAnchorElement;\r\n                const className = target ? target.getAttribute(\"class\") ?? \"\" : \"\";\r\n                clickStream.objectMetric(\"LastBrowserEvent\", {\r\n                    type: \"click\",\r\n                    timestamp: new Date(),\r\n                    target: {\r\n                        className,\r\n                        id: target.id,\r\n                        type: \"<\" + target.tagName.toLowerCase() + \">\",\r\n                        href: target.href || \"\",\r\n                    },\r\n                });\r\n            };\r\n\r\n            // Create click stream record\r\n            clickStream.objectMetric(\"Page\", {\r\n                title: document.title,\r\n                page: window.location.href,\r\n            });\r\n\r\n            if (document.addEventListener) {\r\n                document.addEventListener(\"click\", documentClickHandler);\r\n            } else {\r\n                // For IE versions prior to IE9, attachEvent method should be used to register the specified listener\r\n                // to the EventTarget it is called on, for others addEventListener should be used.\r\n                // (<any>document)\r\n                (document as any).attachEvent(\"onclick\", documentClickHandler);\r\n            }\r\n        }\r\n\r\n        const startTime = rootSystem.stringMetric(\"StartTime\", (new Date()).toString());\r\n        const urlMetric = rootSystem.stringMetric(\"StartURL\", \"\");\r\n        const appNameMetric = rootSystem.stringMetric(\"AppName\", \"\");\r\n        if (typeof window !== \"undefined\") {\r\n            if (typeof window.location !== \"undefined\") {\r\n                const startUrl = window.location.href;\r\n                urlMetric.update(startUrl);\r\n            }\r\n\r\n            if (typeof window.glue42gd !== \"undefined\") {\r\n                appNameMetric.update(window.glue42gd.appName);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { NumberMetric } from \"./metrics/number\";\r\nimport { ObjectMetric } from \"./metrics/object\";\r\nimport { StringMetric } from \"./metrics/string\";\r\nimport { TimestampMetric } from \"./metrics/timestamp\";\r\n\r\nimport { Glue42Core } from \"./../../glue\";\r\nimport MetricTypes from \"./const/metric-types\";\r\nimport { Protocol } from \"./types\";\r\n\r\nexport default function system(name: string, repo: Glue42Core.Metrics.Repository, protocol: Protocol, parent?: Glue42Core.Metrics.System, description?: any): Glue42Core.Metrics.System {\r\n    // Validation\r\n    // if (!name) throw new Error(\"Name is required. \");\r\n\r\n    if (!repo) {\r\n        throw new Error(\"Repository is required\");\r\n    }\r\n\r\n    if (!protocol) {\r\n        throw new Error(\"Transport is required\");\r\n    }\r\n\r\n    const _transport: Protocol = protocol;\r\n\r\n    const _name: string = name;\r\n    const _description: string = description || \"\";\r\n    const _repo: Glue42Core.Metrics.Repository = repo;\r\n    const _parent: Glue42Core.Metrics.System | undefined = parent;\r\n    const _path: string[] = _buildPath(parent);\r\n    let _state: Glue42Core.Metrics.State = {};\r\n\r\n    const id: string = _arrayToString(_path, \"/\") + name;\r\n    const root: Glue42Core.Metrics.System = repo.root;\r\n    const _subSystems: Glue42Core.Metrics.System[] = [];\r\n    const _metrics: Glue42Core.Metrics.Metric[] = [];\r\n\r\n    function subSystem(nameSystem: string, descriptionSystem?: string): Glue42Core.Metrics.System {\r\n        if (!nameSystem || nameSystem.length === 0) {\r\n            throw new Error(\"name is required\");\r\n        }\r\n\r\n        const match: Glue42Core.Metrics.System[] = _subSystems.filter((s) => s.name === nameSystem);\r\n        if (match.length > 0) {\r\n            return match[0];\r\n        }\r\n\r\n        const _system: Glue42Core.Metrics.System = system(nameSystem, _repo, _transport, me, descriptionSystem);\r\n        _subSystems.push(_system);\r\n        return _system;\r\n    }\r\n\r\n    function setState(state: number, stateDescription?: string): void {\r\n        _state = { state, description: stateDescription };\r\n        _transport.updateSystem(me, _state);\r\n    }\r\n\r\n    function stringMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: string): Glue42Core.Metrics.StringMetric {\r\n        return _getOrCreateMetric<StringMetric>(definition, MetricTypes.STRING, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new StringMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function numberMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: number): Glue42Core.Metrics.NumberMetric {\r\n        return _getOrCreateMetric<NumberMetric>(definition, MetricTypes.NUMBER, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new NumberMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function objectMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: any): Glue42Core.Metrics.ObjectMetric {\r\n        return _getOrCreateMetric<ObjectMetric>(definition, MetricTypes.OBJECT, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new ObjectMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function timestampMetric(definition: Glue42Core.Metrics.MetricDefinition | string, value: any): Glue42Core.Metrics.TimestampMetric {\r\n        return _getOrCreateMetric<TimestampMetric>(definition, MetricTypes.TIMESTAMP, value, (metricDef: Glue42Core.Metrics.MetricDefinition) => new TimestampMetric(metricDef, me, _transport, value));\r\n    }\r\n\r\n    function _getOrCreateMetric<T extends Glue42Core.Metrics.Metric>(metricObject: Glue42Core.Metrics.MetricDefinition | string, expectedType: number, value: any, createMetric: (metricDef: Glue42Core.Metrics.MetricDefinition, me?: Glue42Core.Metrics.System, _transport?: Protocol, value?: any) => T): T {\r\n        let metricDef = { name: \"\" };\r\n        if (typeof metricObject === \"string\") {\r\n            metricDef = { name: metricObject };\r\n        } else {\r\n            metricDef = metricObject;\r\n        }\r\n        const matching: Glue42Core.Metrics.Metric[] = _metrics.filter((shadowedMetric) => shadowedMetric.name === metricDef.name);\r\n\r\n        if (matching.length > 0) {\r\n            const existing: Glue42Core.Metrics.Metric = matching[0];\r\n            if (existing.type !== expectedType) {\r\n                // NOTE: Extend the error with the already defined metric?\r\n                throw new Error(`A metric named ${metricDef.name} is already defined with different type.`);\r\n            }\r\n\r\n            if (typeof value !== \"undefined\") {\r\n                existing\r\n                    .update(value)\r\n                    .catch(() => { /** swallow */});\r\n            }\r\n\r\n            return existing as T;\r\n        }\r\n\r\n        const metric: T = createMetric(metricDef);\r\n        _metrics.push(metric);\r\n        return metric;\r\n    }\r\n\r\n    function _buildPath(shadowedSystem?: Glue42Core.Metrics.System): string[] {\r\n        if (!shadowedSystem || !shadowedSystem.parent) {\r\n            return [];\r\n        }\r\n\r\n        const path = _buildPath(shadowedSystem.parent);\r\n        path.push(shadowedSystem.name);\r\n        return path;\r\n    }\r\n\r\n    function _arrayToString(path: string[], separator: string) {\r\n        return ((path && path.length > 0) ? path.join(separator) : \"\");\r\n    }\r\n\r\n    function getAggregateState(): Glue42Core.Metrics.SystemStateInfo[] {\r\n        const aggState: Glue42Core.Metrics.SystemStateInfo[] = [];\r\n        if (Object.keys(_state).length > 0) {\r\n            aggState.push({\r\n                name: _name,\r\n                path: _path,\r\n                state: _state.state,\r\n                description: _state.description,\r\n            });\r\n        }\r\n\r\n        _subSystems.forEach((shadowedSubSystem) => {\r\n            const result = shadowedSubSystem.getAggregateState();\r\n            if (result.length > 0) {\r\n                aggState.push(...result);\r\n            }\r\n        });\r\n\r\n        return aggState;\r\n    }\r\n\r\n    const me: Glue42Core.Metrics.System = {\r\n        get name() {\r\n            return _name;\r\n        },\r\n\r\n        get description() {\r\n            return _description;\r\n        },\r\n\r\n        get repo() {\r\n            return _repo;\r\n        },\r\n\r\n        get parent() {\r\n            return _parent;\r\n        },\r\n        path: _path,\r\n        id,\r\n        root,\r\n\r\n        get subSystems() {\r\n            return _subSystems;\r\n        },\r\n\r\n        get metrics() {\r\n            return _metrics;\r\n        },\r\n        subSystem,\r\n        getState: () => {\r\n            return _state;\r\n        },\r\n        setState,\r\n        stringMetric,\r\n        timestampMetric,\r\n        objectMetric,\r\n        numberMetric,\r\n        getAggregateState,\r\n    };\r\n\r\n    _transport.createSystem(me);\r\n\r\n    return me;\r\n}\r\n","import { Protocol } from \"../../types\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\n\r\nexport class NullProtocol implements Protocol {\r\n    public init(repo: Glue42Core.Metrics.Repository): void {\r\n        // do nothing\r\n    }\r\n\r\n    public createSystem(system: Glue42Core.Metrics.System): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public updateSystem(metric: Glue42Core.Metrics.System, state: Glue42Core.Metrics.State): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public createMetric(metric: Glue42Core.Metrics.Metric): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public updateMetric(metric: Glue42Core.Metrics.Metric): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { count } from \"console\";\r\n\r\nexport class PerfTracker {\r\n\r\n    private lastCount = 0;\r\n\r\n    private initialPublishTimeout = 10 * 1000; // 10 sec\r\n    private publishInterval = 60 * 1000; // 60 sec\r\n    private system: Glue42Core.Metrics.System;\r\n\r\n    constructor(private api: Glue42Core.Metrics.API, initialPublishTimeout?: number, publishInterval?: number) {\r\n        this.initialPublishTimeout = initialPublishTimeout ?? this.initialPublishTimeout;\r\n        this.publishInterval = publishInterval ?? this.publishInterval;\r\n        this.scheduleCollection();\r\n        this.system = this.api.subSystem(\"performance\", \"Performance data published by the web application\");\r\n    }\r\n\r\n    private scheduleCollection() {\r\n        setTimeout(() => {\r\n            this.collect();\r\n            setInterval(() => {\r\n                this.collect();\r\n            }, this.publishInterval);\r\n        }, this.initialPublishTimeout);\r\n    }\r\n\r\n    private collect() {\r\n        try {\r\n            // tslint:disable-next-line:no-console\r\n            this.collectMemory();\r\n            this.collectEntries();\r\n        } catch {\r\n            // DO NOTHING\r\n        }\r\n    }\r\n\r\n    private collectMemory() {\r\n        // memory - use performance.memory\r\n        const memory = (window.performance as any).memory;\r\n        this.system.stringMetric(\"memory\", JSON.stringify({\r\n            totalJSHeapSize: memory.totalJSHeapSize,\r\n            usedJSHeapSize: memory.usedJSHeapSize\r\n        }));\r\n    }\r\n\r\n    private collectEntries() {\r\n        const allEntries = window.performance.getEntries();\r\n        if (allEntries.length <= this.lastCount) {\r\n            return;\r\n        }\r\n        this.lastCount = allEntries.length;\r\n        const jsonfiedEntries = allEntries.map((i) => i.toJSON());\r\n\r\n        this.system.stringMetric(\"entries\", JSON.stringify(jsonfiedEntries));\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport gw3 from \"./protocols/gw3/gw3\";\r\nimport { Repository } from \"./repository\";\r\nimport { Protocol, MetricsSettings } from \"./types\";\r\nimport { NullProtocol } from \"./protocols/null/null\";\r\nimport { PerfTracker } from \"./pertTracker\";\r\n\r\nexport default (options: MetricsSettings): Glue42Core.Metrics.API => {\r\n\r\n    let protocol: Protocol;\r\n    if (!options.connection || typeof options.connection !== \"object\") {\r\n        protocol = new NullProtocol();\r\n    } else {\r\n        protocol = gw3(options.connection, options);\r\n    }\r\n\r\n    const repo = new Repository(options, protocol);\r\n    let rootSystem = repo.root;\r\n    if (!options.disableAutoAppSystem) {\r\n        rootSystem = rootSystem.subSystem(\"App\");\r\n    }\r\n\r\n    // add FAV support\r\n    const api = addFAVSupport(rootSystem);\r\n    // initialize page performance\r\n    initPerf(api, options.pagePerformanceMetrics);\r\n\r\n    return api;\r\n};\r\n\r\nlet perf: PerfTracker;\r\nfunction initPerf(api: Glue42Core.Metrics.API, config?: Glue42Core.PagePerformanceMetricsConfig) {\r\n    if (typeof window === \"undefined\") {\r\n        return;\r\n    }\r\n\r\n    // allow Glue42 Enterprise to override\r\n    const perfConfig = window?.glue42gd?.metrics?.pagePerformanceMetrics;\r\n    if (perfConfig) {\r\n        // allow Glue42 Enterprise to override\r\n        config = perfConfig;\r\n    }\r\n\r\n    if (config?.enabled) {\r\n        perf = new PerfTracker(api, config.initialPublishTimeout, config.publishInterval);\r\n    }\r\n}\r\n\r\nfunction addFAVSupport(system: Glue42Core.Metrics.System): Glue42Core.Metrics.API {\r\n    // Creating subsystem for reporting and feature metric\r\n    const reportingSystem: Glue42Core.Metrics.System = system.subSystem(\"reporting\");\r\n    const def = {\r\n        name: \"features\"\r\n    };\r\n\r\n    let featureMetric: Glue42Core.Metrics.ObjectMetric;\r\n\r\n    const featureMetricFunc = (name: string, action: string, payload: string) => {\r\n        if (typeof name === \"undefined\" || name === \"\") {\r\n            throw new Error(\"name is mandatory\");\r\n        } else if (typeof action === \"undefined\" || action === \"\") {\r\n            throw new Error(\"action is mandatory\");\r\n        } else if (typeof payload === \"undefined\" || payload === \"\") {\r\n            throw new Error(\"payload is mandatory\");\r\n        }\r\n\r\n        if (!featureMetric) {\r\n            featureMetric = reportingSystem.objectMetric(def, { name, action, payload });\r\n        } else {\r\n            featureMetric.update({\r\n                name,\r\n                action,\r\n                payload\r\n            });\r\n        }\r\n    };\r\n    (system as any).featureMetric = featureMetricFunc;\r\n    return system as Glue42Core.Metrics.API;\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { Protocol, MetricsSettings } from \"../../types\";\r\nimport { composeMsgForRootStateMetric, getMetricValueByType, normalizeMetricName, serializeMetric } from \"./serializer\";\r\nimport Connection from \"../../../connection/connection\";\r\n\r\nexport default function (connection: Connection, config: MetricsSettings): Protocol {\r\n    if (!connection || typeof connection !== \"object\") {\r\n        throw new Error(\"Connection is required parameter\");\r\n    }\r\n\r\n    let joinPromise: Promise<any>;\r\n    let session: Glue42Core.Connection.GW3DomainSession;\r\n\r\n    const init = (repo: Glue42Core.Metrics.Repository): void => {\r\n        let resolveReadyPromise: (() => void) | undefined;\r\n        joinPromise = new Promise((resolve) => {\r\n            resolveReadyPromise = resolve;\r\n        });\r\n\r\n        session = connection.domain(\"metrics\");\r\n\r\n        session.onJoined((reconnect) => {\r\n            if (!reconnect && resolveReadyPromise) {\r\n                resolveReadyPromise();\r\n                resolveReadyPromise = undefined;\r\n            }\r\n\r\n            // Creating root state metric\r\n            const rootStateMetric: any = {\r\n                name: \"/State\",\r\n                type: \"object\",\r\n                composite: {\r\n                    Description: {\r\n                        type: \"string\",\r\n                        description: \"\",\r\n                    },\r\n                    Value: {\r\n                        type: \"number\",\r\n                        description: \"\",\r\n                    },\r\n                },\r\n                description: \"System state\",\r\n                context: {},\r\n            };\r\n\r\n            const defineRootMetricsMsg = {\r\n                type: \"define\",\r\n                metrics: [rootStateMetric],\r\n            };\r\n\r\n            session.send(defineRootMetricsMsg);\r\n\r\n            if (reconnect) {\r\n                replayRepo(repo);\r\n            }\r\n\r\n        });\r\n\r\n        session.join({\r\n            system: config.system,\r\n            service: config.service,\r\n            instance: config.instance\r\n        });\r\n    };\r\n\r\n    const replayRepo = (repo: Glue42Core.Metrics.Repository) => {\r\n        replaySystem(repo.root);\r\n    };\r\n\r\n    const replaySystem = (system: Glue42Core.Metrics.System) => {\r\n        // replay system\r\n        createSystem(system);\r\n\r\n        // replay all metrics in the system\r\n        system.metrics.forEach((m) => {\r\n            createMetric(m);\r\n        });\r\n\r\n        // replay all sub-systems\r\n        system.subSystems.forEach((ss) => {\r\n            replaySystem(ss);\r\n        });\r\n    };\r\n\r\n    const createSystem = async (system: Glue42Core.Metrics.System): Promise<void> => {\r\n        if (system.parent === undefined) {\r\n            return;\r\n        }\r\n\r\n        await joinPromise;\r\n        const metric = {\r\n            name: normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n            type: \"object\",\r\n            composite: {\r\n                Description: {\r\n                    type: \"string\",\r\n                    description: \"\",\r\n                },\r\n                Value: {\r\n                    type: \"number\",\r\n                    description: \"\",\r\n                },\r\n            },\r\n            description: \"System state\",\r\n            context: {},\r\n        };\r\n\r\n        const createMetricsMsg = {\r\n            type: \"define\",\r\n            metrics: [metric],\r\n        };\r\n\r\n        session.send(createMetricsMsg);\r\n    };\r\n\r\n    const updateSystem = async (system: Glue42Core.Metrics.System, state: Glue42Core.Metrics.State): Promise<void> => {\r\n        await joinPromise;\r\n\r\n        const shadowedUpdateMetric = {\r\n            type: \"publish\",\r\n            values: [{\r\n                name: normalizeMetricName(system.path.join(\"/\") + \"/\" + system.name + \"/State\"),\r\n                value: {\r\n                    Description: state.description,\r\n                    Value: state.state,\r\n                },\r\n                timestamp: Date.now(),\r\n            }],\r\n        };\r\n\r\n        session.send(shadowedUpdateMetric);\r\n\r\n        const stateObj = composeMsgForRootStateMetric(system);\r\n        const rootMetric = {\r\n            type: \"publish\",\r\n            peer_id: connection.peerId,\r\n            values: [{\r\n                name: \"/State\",\r\n                value: {\r\n                    Description: stateObj.description,\r\n                    Value: stateObj.value,\r\n                },\r\n                timestamp: Date.now(),\r\n            }],\r\n        };\r\n\r\n        session.send(rootMetric);\r\n    };\r\n\r\n    const createMetric = async (metric: Glue42Core.Metrics.Metric): Promise<void> => {\r\n        const metricClone = cloneMetric(metric);\r\n        await joinPromise;\r\n        const m = serializeMetric(metricClone);\r\n\r\n        const createMetricsMsg = {\r\n            type: \"define\",\r\n            metrics: [m],\r\n        };\r\n\r\n        session.send(createMetricsMsg);\r\n        if (typeof metricClone.value !== \"undefined\") {\r\n            // do not use updateMetric because it will dispatch the call (joinPromise.then)\r\n            // which leads to method calls reorder. It is safe to call updateMetricCore directly\r\n            // because we are being executed in joinPromise.then\r\n            updateMetricCore(metricClone);\r\n        }\r\n    };\r\n\r\n    const updateMetric = async (metric: Glue42Core.Metrics.Metric): Promise<void> => {\r\n        const metricClone = cloneMetric(metric);\r\n        await joinPromise;\r\n        updateMetricCore(metricClone);\r\n    };\r\n\r\n    const updateMetricCore = (metric: Glue42Core.Metrics.Metric): Promise<void> => {\r\n        if (canUpdate()) {\r\n            const value = getMetricValueByType(metric);\r\n            const publishMetricsMsg = {\r\n                type: \"publish\",\r\n                values: [{\r\n                    name: normalizeMetricName(metric.path.join(\"/\") + \"/\" + metric.name),\r\n                    value,\r\n                    timestamp: Date.now(),\r\n                }],\r\n            };\r\n            return session.sendFireAndForget(publishMetricsMsg);\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n\r\n    const cloneMetric = (metric: Glue42Core.Metrics.Metric): Glue42Core.Metrics.Metric => {\r\n        const metricClone: Glue42Core.Metrics.Metric = { ...metric };\r\n        if (typeof metric.value === \"object\" && metric.value !== null) {\r\n            metricClone.value = { ...metric.value };\r\n        }\r\n        return metricClone;\r\n    };\r\n\r\n    const canUpdate = (): boolean => {\r\n        try {\r\n            const func = config.canUpdateMetric ?? (() => true);\r\n            return func();\r\n        } catch {\r\n            return true;\r\n        }\r\n    };\r\n\r\n    return {\r\n        init,\r\n        createSystem,\r\n        updateSystem,\r\n        createMetric,\r\n        updateMetric,\r\n    };\r\n}\r\n","\"use strict\";\r\nfunction createRegistry(options) {\r\n    if (options && options.errorHandling\r\n        && typeof options.errorHandling !== \"function\"\r\n        && options.errorHandling !== \"log\"\r\n        && options.errorHandling !== \"silent\"\r\n        && options.errorHandling !== \"throw\") {\r\n        throw new Error(\"Invalid options passed to createRegistry. Prop errorHandling should be [\\\"log\\\" | \\\"silent\\\" | \\\"throw\\\" | (err) => void], but \" + typeof options.errorHandling + \" was passed\");\r\n    }\r\n    var _userErrorHandler = options && typeof options.errorHandling === \"function\" && options.errorHandling;\r\n    var callbacks = {};\r\n    function add(key, callback, replayArgumentsArr) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            callbacksForKey = [];\r\n            callbacks[key] = callbacksForKey;\r\n        }\r\n        callbacksForKey.push(callback);\r\n        if (replayArgumentsArr) {\r\n            setTimeout(function () {\r\n                replayArgumentsArr.forEach(function (replayArgument) {\r\n                    var _a;\r\n                    if ((_a = callbacks[key]) === null || _a === void 0 ? void 0 : _a.includes(callback)) {\r\n                        try {\r\n                            if (Array.isArray(replayArgument)) {\r\n                                callback.apply(undefined, replayArgument);\r\n                            }\r\n                            else {\r\n                                callback.apply(undefined, [replayArgument]);\r\n                            }\r\n                        }\r\n                        catch (err) {\r\n                            _handleError(err, key);\r\n                        }\r\n                    }\r\n                });\r\n            }, 0);\r\n        }\r\n        return function () {\r\n            var allForKey = callbacks[key];\r\n            if (!allForKey) {\r\n                return;\r\n            }\r\n            allForKey = allForKey.reduce(function (acc, element, index) {\r\n                if (!(element === callback && acc.length === index)) {\r\n                    acc.push(element);\r\n                }\r\n                return acc;\r\n            }, []);\r\n            if (allForKey.length === 0) {\r\n                delete callbacks[key];\r\n            }\r\n            else {\r\n                callbacks[key] = allForKey;\r\n            }\r\n        };\r\n    }\r\n    function execute(key) {\r\n        var argumentsArr = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            argumentsArr[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey || callbacksForKey.length === 0) {\r\n            return [];\r\n        }\r\n        var results = [];\r\n        callbacksForKey.forEach(function (callback) {\r\n            try {\r\n                var result = callback.apply(undefined, argumentsArr);\r\n                results.push(result);\r\n            }\r\n            catch (err) {\r\n                results.push(undefined);\r\n                _handleError(err, key);\r\n            }\r\n        });\r\n        return results;\r\n    }\r\n    function _handleError(exceptionArtifact, key) {\r\n        var errParam = exceptionArtifact instanceof Error ? exceptionArtifact : new Error(exceptionArtifact);\r\n        if (_userErrorHandler) {\r\n            _userErrorHandler(errParam);\r\n            return;\r\n        }\r\n        var msg = \"[ERROR] callback-registry: User callback for key \\\"\" + key + \"\\\" failed: \" + errParam.stack;\r\n        if (options) {\r\n            switch (options.errorHandling) {\r\n                case \"log\":\r\n                    return console.error(msg);\r\n                case \"silent\":\r\n                    return;\r\n                case \"throw\":\r\n                    throw new Error(msg);\r\n            }\r\n        }\r\n        console.error(msg);\r\n    }\r\n    function clear() {\r\n        callbacks = {};\r\n    }\r\n    function clearKey(key) {\r\n        var callbacksForKey = callbacks[key];\r\n        if (!callbacksForKey) {\r\n            return;\r\n        }\r\n        delete callbacks[key];\r\n    }\r\n    return {\r\n        add: add,\r\n        execute: execute,\r\n        clear: clear,\r\n        clearKey: clearKey\r\n    };\r\n}\r\n;\r\ncreateRegistry.default = createRegistry;\r\nmodule.exports = createRegistry;\r\n//# sourceMappingURL=index.js.map","import { Transport } from \"../types\";\r\nimport { default as CallbackRegistryFactory, CallbackRegistry, UnsubscribeFunction } from \"callback-registry\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { Logger } from \"../../logger/logger\";\r\n\r\nexport default class InProcTransport implements Transport {\r\n\r\n    private gw: Glue42Core.Connection.GW3Facade;\r\n    private registry: CallbackRegistry = CallbackRegistryFactory();\r\n    private client?: Glue42Core.Connection.GW3Client;\r\n\r\n    constructor(settings: Glue42Core.InprocGWSettings, logger: Logger) {\r\n        this.gw = settings.facade;\r\n        this.gw.connect((_client, message) => {\r\n            this.messageHandler(message);\r\n        }).then((client) => {\r\n            this.client = client;\r\n        });\r\n    }\r\n\r\n    public get isObjectBasedTransport() {\r\n        return true;\r\n    }\r\n\r\n    public sendObject(msg: object): Promise<void> {\r\n        if (this.client) {\r\n            this.client.send(msg);\r\n            return Promise.resolve(undefined);\r\n        } else {\r\n            return Promise.reject(`not connected`);\r\n        }\r\n    }\r\n\r\n    public send(_msg: string) {\r\n        return Promise.reject(\"not supported\");\r\n    }\r\n\r\n    public onMessage(callback: (msg: string | object) => void): UnsubscribeFunction {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean) => void) {\r\n        callback(true);\r\n    }\r\n\r\n    public close() {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public open() {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public name(): string {\r\n        return \"in-memory\";\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private messageHandler(msg: object) {\r\n        this.registry.execute(\"onMessage\", msg);\r\n    }\r\n}\r\n","import { Transport } from \"../types\";\r\nimport {\r\n    default as CallbackRegistryFactory,\r\n    CallbackRegistry,\r\n    UnsubscribeFunction,\r\n} from \"callback-registry\";\r\nimport { Logger } from \"../../logger/logger\";\r\n\r\n// tslint:disable-next-line:no-namespace\r\ndeclare namespace SharedWorker {\r\n    interface AbstractWorker extends EventTarget {\r\n        onerror: (ev: ErrorEvent) => any;\r\n    }\r\n\r\n    export interface SharedWorker extends AbstractWorker {\r\n        /**\r\n         * the value it was assigned by the object's constructor.\r\n         * It represents the MessagePort for communicating with the shared worker.\r\n         * @type {MessagePort}\r\n         */\r\n        port: MessagePort;\r\n    }\r\n\r\n    export interface SharedWorkerGlobalScope extends Worker {\r\n        onconnect: (event: MessageEvent) => void;\r\n    }\r\n}\r\n\r\n/**\r\n * Shared worker transport\r\n */\r\nexport default class SharedWorkerTransport implements Transport {\r\n    private worker: any;\r\n    private registry: CallbackRegistry = CallbackRegistryFactory();\r\n\r\n    constructor(workerFile: string, private logger: Logger) {\r\n        this.worker = new SharedWorker(workerFile);\r\n        this.worker.port.onmessage = (e: { data: any; timestamp: number }) => {\r\n            this.messageHandler(e.data);\r\n        };\r\n    }\r\n\r\n    public get isObjectBasedTransport() {\r\n        return true;\r\n    }\r\n\r\n    public sendObject(msg: object): Promise<void> {\r\n        this.worker.port.postMessage(msg);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public send(_msg: string) {\r\n        return Promise.reject(\"not supported\");\r\n    }\r\n\r\n    public onMessage(\r\n        callback: (msg: string | object) => void\r\n    ): UnsubscribeFunction {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean) => void) {\r\n        callback(true);\r\n    }\r\n\r\n    public close() {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public open() {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public name(): string {\r\n        return \"shared-worker\";\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private messageHandler(msg: object) {\r\n        this.registry.execute(\"onMessage\", msg);\r\n    }\r\n}\r\n\r\ninterface SharedWorkerOptions {\r\n    credentials?: RequestCredentials;\r\n    name?: string;\r\n    type?: WorkerType;\r\n}\r\n\r\n// eslint-disable-next-line\r\ndeclare var SharedWorker: {\r\n    prototype: SharedWorker.SharedWorker;\r\n\r\n    /**\r\n     *\r\n     * @param {string} stringUrl                          Pathname to JavaScript file\r\n     * @param {string|SharedWorkerOptions} [options]      Name of the worker to execute\r\n     *                                                    or an object containing option properties\r\n     */\r\n    new(\r\n        stringUrl: string,\r\n        options?: string | SharedWorkerOptions\r\n    ): SharedWorker.SharedWorker;\r\n};\r\n","export default class Utils {\r\n\r\n    public static getGDMajorVersion(): number | undefined {\r\n        if (typeof window === \"undefined\") {\r\n            return undefined;\r\n        }\r\n        if (!window.glueDesktop) {\r\n            return undefined;\r\n        }\r\n        if (!window.glueDesktop.version) {\r\n            return undefined;\r\n        }\r\n        const ver = Number(window.glueDesktop.version.substr(0, 1));\r\n        return isNaN(ver) ? undefined : ver;\r\n    }\r\n\r\n    public static isNode() {\r\n        if (typeof Utils._isNode !== \"undefined\") {\r\n            return Utils._isNode;\r\n        }\r\n\r\n        if (typeof window !== \"undefined\") {\r\n            Utils._isNode = false;\r\n            return false;\r\n        }\r\n\r\n        // Only Node.JS has a process variable that is of [[Class]] process\r\n        try {\r\n            Utils._isNode = Object.prototype.toString.call(global.process) === \"[object process]\";\r\n        } catch (e) {\r\n            Utils._isNode = false;\r\n        }\r\n        return Utils._isNode;\r\n    }\r\n    private static _isNode?: boolean;\r\n}\r\n","export class PromiseWrapper<T> {\r\n\r\n    public static delay(time: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, time));\r\n    }\r\n\r\n    public resolve!: (arg?: T | PromiseLike<T>) => void;\r\n    public reject!: (err: any) => void;\r\n    public promise: Promise<T>;\r\n    public rejected: boolean = false;\r\n    public resolved: boolean = false;\r\n    public get ended(): boolean {\r\n        return this.rejected || this.resolved;\r\n    }\r\n\r\n    constructor() {\r\n        this.promise = new Promise<T>((resolve, reject) => {\r\n            this.resolve = (t: any) => {\r\n                this.resolved = true;\r\n                resolve(t);\r\n            };\r\n\r\n            this.reject = (err: any) => {\r\n                this.rejected = true;\r\n                reject(err);\r\n            };\r\n        });\r\n    }\r\n}\r\n","import { Timer, Mark } from \"../types\";\r\n\r\nconst timers: { [index: string]: Timer } = {};\r\n\r\nexport function getAllTimers() {\r\n    return timers;\r\n}\r\n\r\nexport default function (timerName: string): Timer {\r\n    const existing = timers[timerName];\r\n    if (existing) {\r\n        return existing;\r\n    }\r\n\r\n    const marks: Mark[] = [];\r\n    function now(): number {\r\n        return new Date().getTime();\r\n    }\r\n\r\n    const startTime = now();\r\n    mark(\"start\", startTime);\r\n    let endTime: number;\r\n    let period: number;\r\n\r\n    function stop(): number {\r\n        endTime = now();\r\n        mark(\"end\", endTime);\r\n        period = endTime - startTime;\r\n        return period;\r\n    }\r\n\r\n    function mark(name: string, time?: number): void {\r\n        const currentTime = time ?? now();\r\n        let diff = 0;\r\n        if (marks.length > 0) {\r\n            diff = currentTime - marks[marks.length - 1].time;\r\n        }\r\n        marks.push({ name, time: currentTime, diff });\r\n    }\r\n\r\n    const timerObj = {\r\n        get startTime(): number {\r\n            return startTime;\r\n        },\r\n        get endTime(): number {\r\n            return endTime;\r\n        },\r\n        get period(): number {\r\n            return period;\r\n        },\r\n        stop,\r\n        mark,\r\n        marks\r\n    };\r\n\r\n    timers[timerName] = timerObj;\r\n    return timerObj;\r\n}\r\n","import {\r\n    default as CallbackRegistryFactory,\r\n    CallbackRegistry,\r\n} from \"callback-registry\";\r\nimport { Transport, ConnectionSettings } from \"../types\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport Utils from \"../../utils/utils\";\r\nimport { PromiseWrapper } from \"../../utils/pw\";\r\nimport timer from \"../../utils/timer\";\r\n\r\nconst WebSocketConstructor = Utils.isNode() ? require(\"ws\") : window.WebSocket;\r\n\r\nexport default class WS implements Transport {\r\n    private ws: WebSocket | undefined;\r\n    private logger: Logger;\r\n    private settings: ConnectionSettings;\r\n    private startupTimer = timer(\"connection\");\r\n\r\n    /**\r\n     * If the flag is true the connection should keep trying to connect.\r\n     * If false the user explicitly closed it and it should not reconnect\r\n     */\r\n    private _running = true;\r\n\r\n    private _registry: CallbackRegistry = CallbackRegistryFactory();\r\n    private wsRequests: Array<{ callback: () => void, failed?: (err?: string) => void }> = [];\r\n\r\n    constructor(settings: ConnectionSettings, logger: Logger) {\r\n        this.settings = settings;\r\n        this.logger = logger;\r\n        if (!this.settings.ws) {\r\n            throw new Error(\"ws is missing\");\r\n        }\r\n    }\r\n\r\n    public onMessage(callback: (msg: string) => void): () => void {\r\n        return this._registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    // Create a function for sending a message\r\n    public send(msg: string, options?: Glue42Core.Connection.SendMessageOptions): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n            options = options || {};\r\n            this.waitForSocketConnection(\r\n                () => {\r\n                    try {\r\n                        this.ws?.send(msg);\r\n                        resolve();\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                },\r\n                reject\r\n            );\r\n        });\r\n    }\r\n\r\n    public open() {\r\n        this.logger.info(`opening ws...`);\r\n        this._running = true;\r\n        return new Promise<void>((resolve, reject) => {\r\n            this.waitForSocketConnection(\r\n                resolve,\r\n                reject\r\n            );\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        this._running = false;\r\n        if (this.ws) {\r\n            this.ws.close();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean, reason?: string) => void): () => void {\r\n        return this._registry.add(\"onConnectedChanged\", callback);\r\n    }\r\n\r\n    public name(): string {\r\n        return `ws ${this.settings.ws}`;\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        this.ws?.close();\r\n        const pw = new PromiseWrapper<void>();\r\n        this.waitForSocketConnection(() => {\r\n            pw.resolve();\r\n        });\r\n        return pw.promise;\r\n    }\r\n\r\n    // Holds callback execution until socket connection is established.\r\n    private waitForSocketConnection(\r\n        callback: () => void,\r\n        failed?: (err?: string) => void\r\n    ) {\r\n        failed = failed ?? (() => { /** DO nothing */ });\r\n\r\n        // check if we're still running\r\n        if (!this._running) {\r\n            failed(\r\n                `wait for socket on ${this.settings.ws} failed - socket closed by user`\r\n            );\r\n            return;\r\n        }\r\n\r\n        // if socket is opened - returned immediately\r\n        if (this.ws?.readyState === 1) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        // store the callback\r\n        this.wsRequests.push({ callback, failed });\r\n        // if someone has already initiated the socket return\r\n        if (this.wsRequests.length > 1) {\r\n            return;\r\n        }\r\n\r\n        this.openSocket();\r\n    }\r\n\r\n    private async openSocket(retryInterval?: number, retriesLeft?: number) {\r\n        this.startupTimer.mark(\"opening-socket\");\r\n        if (retryInterval === undefined) {\r\n            retryInterval = this.settings.reconnectInterval;\r\n        }\r\n\r\n        if (retriesLeft !== undefined) {\r\n            if (retriesLeft === 0) {\r\n                this.notifyForSocketState(\r\n                    `wait for socket on ${this.settings.ws} failed - no more retries left`\r\n                );\r\n                return;\r\n            }\r\n            this.logger.debug(\r\n                `will retry ${retriesLeft} more times (every ${retryInterval} ms)`\r\n            );\r\n        }\r\n\r\n        try {\r\n            await this.initiateSocket();\r\n            this.startupTimer.mark(\"socket-initiated\");\r\n            this.notifyForSocketState();\r\n        } catch {\r\n            setTimeout(() => {\r\n                const retries =\r\n                    retriesLeft === undefined ? undefined : retriesLeft - 1;\r\n                this.openSocket(\r\n                    retryInterval,\r\n                    retries,\r\n                );\r\n            }, retryInterval); // wait X milliseconds for the connection...\r\n        }\r\n    }\r\n\r\n    private initiateSocket(): Promise<void> {\r\n        const pw = new PromiseWrapper<void>();\r\n        this.logger.debug(`initiating ws to ${this.settings.ws}...`);\r\n        this.ws = new WebSocketConstructor(this.settings.ws || \"\") as WebSocket;\r\n        this.ws.onerror = (err: any) => {\r\n            let reason: string = \"\";\r\n            try {\r\n                reason = JSON.stringify(err);\r\n            } catch (error) {\r\n                const seen = new WeakSet();\r\n                const replacer = (key: string, value: any) => {\r\n                    if (typeof value === \"object\" && value !== null) {\r\n                        if (seen.has(value)) {\r\n                            return;\r\n                        }\r\n                        seen.add(value);\r\n                    }\r\n                    return value;\r\n                };\r\n\r\n                reason = JSON.stringify(err, replacer);\r\n            }\r\n\r\n            pw.reject(\"error\");\r\n            this.notifyStatusChanged(false, reason);\r\n        };\r\n        this.ws.onclose = (err) => {\r\n            this.logger.info(`ws closed ${err}`);\r\n            pw.reject(\"closed\");\r\n            this.notifyStatusChanged(false);\r\n        };\r\n        // Log on connection\r\n        this.ws.onopen = () => {\r\n            // tslint:disable-next-line:no-console\r\n            this.startupTimer.mark(\"ws-opened\");\r\n            this.logger.info(`ws opened ${this.settings.identity?.application}`);\r\n            pw.resolve();\r\n            this.notifyStatusChanged(true);\r\n        };\r\n        // Attach handler\r\n        this.ws.onmessage = (message: { data: object }) => {\r\n            this._registry.execute(\"onMessage\", message.data);\r\n        };\r\n\r\n        return pw.promise;\r\n    }\r\n\r\n    private notifyForSocketState(error?: string) {\r\n        this.wsRequests.forEach((wsRequest) => {\r\n            if (error) {\r\n                if (wsRequest.failed) {\r\n                    wsRequest.failed(error);\r\n                }\r\n            } else {\r\n                wsRequest.callback();\r\n            }\r\n        });\r\n        this.wsRequests = [];\r\n    }\r\n\r\n    private notifyStatusChanged(status: boolean, reason?: string) {\r\n        this._registry.execute(\"onConnectedChanged\", status, reason);\r\n    }\r\n}\r\n","'use strict';\n\n// Found this seed-based random generator somewhere\n// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)\n\nvar seed = 1;\n\n/**\n * return a random number based on a seed\n * @param seed\n * @returns {number}\n */\nfunction getNextValue() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed/(233280.0);\n}\n\nfunction setSeed(_seed_) {\n    seed = _seed_;\n}\n\nmodule.exports = {\n    nextValue: getNextValue,\n    seed: setSeed\n};\n","'use strict';\n\nvar randomFromSeed = require('./random/random-from-seed');\n\nvar ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';\nvar alphabet;\nvar previousSeed;\n\nvar shuffled;\n\nfunction reset() {\n    shuffled = false;\n}\n\nfunction setCharacters(_alphabet_) {\n    if (!_alphabet_) {\n        if (alphabet !== ORIGINAL) {\n            alphabet = ORIGINAL;\n            reset();\n        }\n        return;\n    }\n\n    if (_alphabet_ === alphabet) {\n        return;\n    }\n\n    if (_alphabet_.length !== ORIGINAL.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);\n    }\n\n    var unique = _alphabet_.split('').filter(function(item, ind, arr){\n       return ind !== arr.lastIndexOf(item);\n    });\n\n    if (unique.length) {\n        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));\n    }\n\n    alphabet = _alphabet_;\n    reset();\n}\n\nfunction characters(_alphabet_) {\n    setCharacters(_alphabet_);\n    return alphabet;\n}\n\nfunction setSeed(seed) {\n    randomFromSeed.seed(seed);\n    if (previousSeed !== seed) {\n        reset();\n        previousSeed = seed;\n    }\n}\n\nfunction shuffle() {\n    if (!alphabet) {\n        setCharacters(ORIGINAL);\n    }\n\n    var sourceArray = alphabet.split('');\n    var targetArray = [];\n    var r = randomFromSeed.nextValue();\n    var characterIndex;\n\n    while (sourceArray.length > 0) {\n        r = randomFromSeed.nextValue();\n        characterIndex = Math.floor(r * sourceArray.length);\n        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);\n    }\n    return targetArray.join('');\n}\n\nfunction getShuffled() {\n    if (shuffled) {\n        return shuffled;\n    }\n    shuffled = shuffle();\n    return shuffled;\n}\n\n/**\n * lookup shuffled letter\n * @param index\n * @returns {string}\n */\nfunction lookup(index) {\n    var alphabetShuffled = getShuffled();\n    return alphabetShuffled[index];\n}\n\nmodule.exports = {\n    characters: characters,\n    seed: setSeed,\n    lookup: lookup,\n    shuffled: getShuffled\n};\n","'use strict';\n\nvar crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto\n\nfunction randomByte() {\n    if (!crypto || !crypto.getRandomValues) {\n        return Math.floor(Math.random() * 256) & 0x30;\n    }\n    var dest = new Uint8Array(1);\n    crypto.getRandomValues(dest);\n    return dest[0] & 0x30;\n}\n\nmodule.exports = randomByte;\n","'use strict';\n\nvar randomByte = require('./random/random-byte');\n\nfunction encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomByte() );\n        done = number < (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\nmodule.exports = encode;\n","'use strict';\nvar alphabet = require('./alphabet');\n\n/**\n * Decode the id to get the version and worker\n * Mainly for debugging and testing.\n * @param id - the shortid-generated id.\n */\nfunction decode(id) {\n    var characters = alphabet.shuffled();\n    return {\n        version: characters.indexOf(id.substr(0, 1)) & 0x0f,\n        worker: characters.indexOf(id.substr(1, 1)) & 0x0f\n    };\n}\n\nmodule.exports = decode;\n","'use strict';\nvar alphabet = require('./alphabet');\n\nfunction isShortId(id) {\n    if (!id || typeof id !== 'string' || id.length < 6 ) {\n        return false;\n    }\n\n    var characters = alphabet.characters();\n    var len = id.length;\n    for(var i = 0; i < len;i++) {\n        if (characters.indexOf(id[i]) === -1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nmodule.exports = isShortId;\n","'use strict';\n\nvar alphabet = require('./alphabet');\nvar encode = require('./encode');\nvar decode = require('./decode');\nvar isValid = require('./is-valid');\n\n// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.\n// This number should be updated every year or so to keep the generated id short.\n// To regenerate `new Date() - 0` and bump the version. Always bump the version!\nvar REDUCE_TIME = 1459707606518;\n\n// don't change unless we change the algos or REDUCE_TIME\n// must be an integer and less than 16\nvar version = 6;\n\n// if you are using cluster or multiple servers use this to make each instance\n// has a unique value for worker\n// Note: I don't know if this is automatically set when using third\n// party cluster solutions such as pm2.\nvar clusterWorkerId = require('./util/cluster-worker-id') || 0;\n\n// Counter is used when shortid is called multiple times in one second.\nvar counter;\n\n// Remember the last time shortid was called in case counter is needed.\nvar previousSeconds;\n\n/**\n * Generate unique id\n * Returns string id\n */\nfunction generate() {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode(alphabet.lookup, version);\n    str = str + encode(alphabet.lookup, clusterWorkerId);\n    if (counter > 0) {\n        str = str + encode(alphabet.lookup, counter);\n    }\n    str = str + encode(alphabet.lookup, seconds);\n\n    return str;\n}\n\n\n/**\n * Set the seed.\n * Highly recommended if you don't want people to try to figure out your id schema.\n * exposed as shortid.seed(int)\n * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.\n */\nfunction seed(seedValue) {\n    alphabet.seed(seedValue);\n    return module.exports;\n}\n\n/**\n * Set the cluster worker or machine id\n * exposed as shortid.worker(int)\n * @param workerId worker must be positive integer.  Number less than 16 is recommended.\n * returns shortid module so it can be chained.\n */\nfunction worker(workerId) {\n    clusterWorkerId = workerId;\n    return module.exports;\n}\n\n/**\n *\n * sets new characters to use in the alphabet\n * returns the shuffled alphabet\n */\nfunction characters(newCharacters) {\n    if (newCharacters !== undefined) {\n        alphabet.characters(newCharacters);\n    }\n\n    return alphabet.shuffled();\n}\n\n\n// Export all other functions as properties of the generate function\nmodule.exports = generate;\nmodule.exports.generate = generate;\nmodule.exports.seed = seed;\nmodule.exports.worker = worker;\nmodule.exports.characters = characters;\nmodule.exports.decode = decode;\nmodule.exports.isValid = isValid;\n","'use strict';\nmodule.exports = require('./lib/index');\n","import { Glue42Core } from \"../../../glue\";\r\nimport { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport generate from \"shortid\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport Connection from \"../connection\";\r\n\r\ninterface GW3Message {\r\n    request_id?: string;\r\n    domain?: string;\r\n    peer_id?: string;\r\n    _tag?: object;\r\n}\r\n\r\n/**\r\n * Handles domain session lifetime and events for a given connection/domain pair\r\n */\r\nexport default function (domain: string, connection: Connection, logger: Logger, successMessages?: string[], errorMessages?: string[]): Glue42Core.Connection.GW3DomainSession {\r\n\r\n    if (domain == null) {\r\n        domain = \"global\";\r\n    }\r\n\r\n    successMessages = successMessages || [\"success\"];\r\n    errorMessages = errorMessages || [\"error\"];\r\n\r\n    let isJoined = false;\r\n    let tryReconnecting = false;\r\n    /** holds latest options passed to join - used when doing reconnects */\r\n    let _latestOptions: object | undefined;\r\n    // #deleteme TODO: verify this gets properly set to true\r\n    let _connectionOn: boolean = false;\r\n\r\n    const callbacks: CallbackRegistry = CallbackRegistryFactory();\r\n\r\n    // attach event handlers to connection\r\n    connection.disconnected(handleConnectionDisconnected);\r\n    connection.loggedIn(handleConnectionLoggedIn);\r\n    connection.on(\"success\", (msg: GW3Message) => handleSuccessMessage(msg));\r\n    connection.on(\"error\", (msg: GW3Message) => handleErrorMessage(msg));\r\n    connection.on(\"result\", (msg: GW3Message) => handleSuccessMessage(msg));\r\n\r\n    if (successMessages) {\r\n        successMessages.forEach((sm) => {\r\n            connection.on(sm, (msg: GW3Message) => handleSuccessMessage(msg));\r\n        });\r\n    }\r\n    if (errorMessages) {\r\n        errorMessages.forEach((sm) => {\r\n            connection.on(sm, (msg: GW3Message) => handleErrorMessage(msg));\r\n        });\r\n    }\r\n\r\n    interface RequestHandler {\r\n        success: (success: { _tag?: object }) => void;\r\n        error: (error: { _tag?: object, err?: string }) => void;\r\n    }\r\n\r\n    const requestsMap: { [key: string]: RequestHandler } = {};\r\n\r\n    function join(options?: object): Promise<{}> {\r\n        _latestOptions = options;\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            if (isJoined) {\r\n                resolve();\r\n                return;\r\n            }\r\n            let joinPromise: Promise<{}>;\r\n\r\n            if (domain === \"global\") {\r\n                joinPromise = _connectionOn ? Promise.resolve<{}>({}) : Promise.reject<{}>(\"not connected to gateway\");\r\n            } else {\r\n                logger.debug(`joining domain ${domain}`);\r\n\r\n                const joinMsg = {\r\n                    type: \"join\",\r\n                    destination: domain,\r\n                    domain: \"global\",\r\n                    options,\r\n                };\r\n\r\n                // #deleteme TODO: what happens if multiple clients try to open the same domain?\r\n                // e.g. contexts\r\n                joinPromise = send(joinMsg);\r\n            }\r\n            joinPromise\r\n                .then(() => {\r\n                    handleJoined();\r\n                    resolve();\r\n                })\r\n                .catch((err) => {\r\n                    logger.debug(\"error joining \" + domain + \" domain: \" + JSON.stringify(err));\r\n                    reject(err);\r\n                });\r\n        });\r\n    }\r\n\r\n    // terminology: join vs leave (domain), connect vs login vs disconnect (to/from GW)\r\n    function leave(): Promise<void> {\r\n        if (domain === \"global\") {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        logger.debug(\"stopping session \" + domain + \"...\");\r\n        const leaveMsg = {\r\n            type: \"leave\",\r\n            destination: domain,\r\n            domain: \"global\",\r\n        };\r\n        tryReconnecting = false;\r\n        // #deleteme - handling\r\n        return send(leaveMsg)\r\n            .then(() => {\r\n                isJoined = false;\r\n                callbacks.execute(\"onLeft\");\r\n            })\r\n            .catch(() => {\r\n                // may fail if socked is already closed\r\n                isJoined = false;\r\n                callbacks.execute(\"onLeft\");\r\n            });\r\n    }\r\n\r\n    function handleJoined() {\r\n        logger.debug(\"did join \" + domain);\r\n\r\n        isJoined = true;\r\n        const wasReconnect = tryReconnecting;\r\n        tryReconnecting = false;\r\n        callbacks.execute(\"onJoined\", wasReconnect);\r\n    }\r\n\r\n    function handleConnectionDisconnected() {\r\n        _connectionOn = false;\r\n        logger.debug(\"connection is down\");\r\n        isJoined = false;\r\n        tryReconnecting = true;\r\n        callbacks.execute(\"onLeft\", { disconnected: true });\r\n    }\r\n\r\n    function handleConnectionLoggedIn() {\r\n        _connectionOn = true;\r\n        if (tryReconnecting) {\r\n            logger.debug(\"connection is now up - trying to reconnect...\");\r\n            join(_latestOptions);\r\n        }\r\n    }\r\n\r\n    function onJoined(callback: (wasReconnect: boolean) => void) {\r\n        if (isJoined) {\r\n            callback(false);\r\n        }\r\n\r\n        return callbacks.add(\"onJoined\", callback);\r\n    }\r\n\r\n    function onLeft(callback: () => void) {\r\n        if (!isJoined) {\r\n            callback();\r\n        }\r\n\r\n        return callbacks.add(\"onLeft\", callback);\r\n    }\r\n\r\n    function handleErrorMessage(msg: GW3Message) {\r\n        if (domain !== msg.domain) {\r\n            return;\r\n        }\r\n\r\n        const requestId = msg.request_id;\r\n        if (!requestId) {\r\n            return;\r\n        }\r\n        const entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n\r\n        entry.error(msg);\r\n    }\r\n\r\n    function handleSuccessMessage(msg: GW3Message) {\r\n        if (msg.domain !== domain) {\r\n            return;\r\n        }\r\n        const requestId = msg.request_id;\r\n        if (!requestId) {\r\n            return;\r\n        }\r\n        const entry = requestsMap[requestId];\r\n        if (!entry) {\r\n            return;\r\n        }\r\n        entry.success(msg);\r\n    }\r\n\r\n    function getNextRequestId() {\r\n        return generate();\r\n    }\r\n\r\n    /**\r\n     * Send a message\r\n     * @param msg message to send\r\n     * @param tag a custom object (tag) - it will be transferred to success/error callback\r\n     * @param success\r\n     * @param error\r\n     */\r\n    function send<T>(msg: GW3Message, tag?: object, options?: Glue42Core.Connection.SendMessageOptions): Promise<T> {\r\n        options = options || {};\r\n        // Allows function caller to override request_id\r\n        msg.request_id = msg.request_id || getNextRequestId();\r\n        // Allows function caller to override domain (join/leave messages are in global domain)\r\n        msg.domain = msg.domain || domain;\r\n        if (!options.skipPeerId) {\r\n            msg.peer_id = connection.peerId;\r\n        }\r\n\r\n        const requestId = msg.request_id;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            requestsMap[requestId] = {\r\n                success: (successMsg: any) => {\r\n                    delete requestsMap[requestId];\r\n                    successMsg._tag = tag;\r\n                    resolve(successMsg);\r\n                },\r\n                error: (errorMsg: { _tag?: any, error?: string }) => {\r\n                    logger.warn(`GW error - ${JSON.stringify(errorMsg)} for request ${JSON.stringify(msg)}`);\r\n                    delete requestsMap[requestId];\r\n                    errorMsg._tag = tag;\r\n                    reject(errorMsg);\r\n                },\r\n            };\r\n            connection\r\n                .send(msg, options)\r\n                .catch((err: string) => {\r\n                    requestsMap[requestId].error({ err });\r\n                });\r\n        });\r\n    }\r\n\r\n    function sendFireAndForget(msg: GW3Message): Promise<void> {\r\n        // Allows function caller to override request_id\r\n        msg.request_id = msg.request_id ? msg.request_id : getNextRequestId();\r\n        // Allows function caller to override domain (join/leave messages are in global domain)\r\n        msg.domain = msg.domain || domain;\r\n        msg.peer_id = connection.peerId;\r\n\r\n        return connection.send(msg);\r\n    }\r\n\r\n    return {\r\n        join,\r\n        leave,\r\n        onJoined,\r\n        onLeft,\r\n        send,\r\n        sendFireAndForget,\r\n        on: <T>(type: string, callback: (msg: T) => void) => {\r\n            connection.on(type, (msg: any) => {\r\n                if (msg.domain !== domain) {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    callback(msg);\r\n                } catch (e) {\r\n                    logger.error(`Callback  failed: ${e} \\n ${e.stack} \\n msg was: ${JSON.stringify(msg)}`, e);\r\n                }\r\n            });\r\n        },\r\n        loggedIn: (callback: () => void) => connection.loggedIn(callback),\r\n        connected: (callback: (server: string) => void) => connection.connected(callback),\r\n        disconnected: (callback: () => void) => connection.disconnected(callback),\r\n        get peerId() {\r\n            return connection.peerId;\r\n        },\r\n        get domain() {\r\n            return domain;\r\n        },\r\n    };\r\n}\r\n","import domainSession from \"./gw3Domain\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport { GW3Protocol, Identity, ConnectionSettings } from \"../types\";\r\nimport Connection from \"../connection\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport { WelcomeMessage, CreateTokenReq, CreateTokenRes } from \"./messages\";\r\nexport default class GW3ProtocolImpl implements GW3Protocol {\r\n    public protocolVersion: number = 3;\r\n\r\n    private datePrefix = \"#T42_DATE#\";\r\n    private datePrefixLen = this.datePrefix.length;\r\n    private dateMinLen = this.datePrefixLen + 1; // prefix + at least one char (1970/01/01 = 0)\r\n    private datePrefixFirstChar = this.datePrefix[0];\r\n    private registry: CallbackRegistry = CallbackRegistryFactory();\r\n\r\n    private globalDomain: Glue42Core.Connection.GW3DomainSession | undefined;\r\n\r\n    /* Flag indicating if the user is currently logged in */\r\n    private _isLoggedIn = false;\r\n\r\n    /*\r\n     * If true(default) the user wants to be connected.\r\n     * If the user explicitly calls logout this will become false.\r\n     * This is used to determine if it should retry trying to login.\r\n     */\r\n    private shouldTryLogin = true;\r\n\r\n    /* True only if this is the initial login attempt. */\r\n    private initialLogin = true;\r\n    private initialLoginAttempts = 3;\r\n    private pingTimer: any;\r\n    private sessions: Glue42Core.Connection.GW3DomainSession[] = [];\r\n    private loginConfig: Glue42Core.Auth | undefined;\r\n\r\n    constructor(private connection: Connection, private settings: ConnectionSettings, private logger: Logger) {\r\n        connection.disconnected(() => {\r\n            this.handleDisconnected();\r\n        });\r\n\r\n        this.ping();\r\n    }\r\n\r\n    public get isLoggedIn() {\r\n        return this._isLoggedIn;\r\n    }\r\n\r\n    public processStringMessage(message: string): { msg: object, msgType: string } {\r\n        const msg: { type: string } = JSON.parse(message, (key, value) => {\r\n\r\n            // check for date - we have custom protocol for dates\r\n            if (typeof value !== \"string\") {\r\n                return value;\r\n            }\r\n            if (value.length < this.dateMinLen) {\r\n                return value;\r\n            }\r\n            if (value[0] !== this.datePrefixFirstChar) {\r\n                return value;\r\n            }\r\n            if (value.substring(0, this.datePrefixLen) !== this.datePrefix) {\r\n                return value;\r\n            }\r\n            try {\r\n                const milliseconds = parseInt(value.substring(this.datePrefixLen, value.length), 10);\r\n                if (isNaN(milliseconds)) {\r\n                    return value;\r\n                }\r\n                return new Date(milliseconds);\r\n            } catch (ex) {\r\n                return value;\r\n            }\r\n        });\r\n\r\n        return {\r\n            msg,\r\n            msgType: msg.type,\r\n        };\r\n    }\r\n\r\n    public createStringMessage(message: object): string {\r\n        const oldToJson = Date.prototype.toJSON;\r\n        try {\r\n            const datePrefix = this.datePrefix;\r\n            Date.prototype.toJSON = function () {\r\n                return datePrefix + this.getTime();\r\n            };\r\n            const result = JSON.stringify(message);\r\n            return result;\r\n        } finally {\r\n            Date.prototype.toJSON = oldToJson;\r\n        }\r\n    }\r\n\r\n    public processObjectMessage(message: { type: string }): { msg: object, msgType: string } {\r\n        if (!message.type) {\r\n            throw new Error(\"Object should have type property\");\r\n        }\r\n        return {\r\n            msg: message,\r\n            msgType: message.type,\r\n        };\r\n    }\r\n\r\n    public createObjectMessage(message: object): object {\r\n        return message;\r\n    }\r\n\r\n    public async login(config: Glue42Core.Auth, reconnect?: boolean): Promise<Identity> {\r\n        this.logger.debug(\"logging in...\");\r\n        this.loginConfig = config;\r\n\r\n        if (!this.loginConfig) {\r\n            // in case of no auth send empty username and password\r\n            this.loginConfig = { username: \"\", password: \"\" };\r\n        }\r\n        this.shouldTryLogin = true;\r\n\r\n        const authentication: {\r\n            method?: string,\r\n            token?: string,\r\n            login?: string,\r\n            secret?: string,\r\n            provider?: string\r\n        } = {};\r\n\r\n        this.connection.gatewayToken = config.gatewayToken;\r\n        if (config.gatewayToken) {\r\n            // in case of re-connect try to refresh the GW token\r\n            if (reconnect) {\r\n                try {\r\n                    const token = await this.getNewGWToken();\r\n                    config.gatewayToken = token;\r\n                } catch (e) {\r\n                    this.logger.warn(`failed to get GW token when reconnecting ${e?.message || e}`);\r\n                }\r\n            }\r\n            authentication.method = \"gateway-token\";\r\n            authentication.token = config.gatewayToken;\r\n            this.connection.gatewayToken = config.gatewayToken;\r\n        } else if (config.flowName === \"sspi\") {\r\n            authentication.provider = \"win\";\r\n            authentication.method = \"access-token\";\r\n\r\n            if (config.flowCallback && config.sessionId) {\r\n                authentication.token =\r\n                    (await config.flowCallback(config.sessionId, null))\r\n                        .data\r\n                        .toString(\"base64\");\r\n            } else {\r\n                throw new Error(\"Invalid SSPI config\");\r\n            }\r\n        } else if (config.token) {\r\n            authentication.method = \"access-token\";\r\n            authentication.token = config.token;\r\n        } else if (config.username) {\r\n            authentication.method = \"secret\";\r\n            authentication.login = config.username;\r\n            authentication.secret = config.password;\r\n        } else {\r\n            throw new Error(\"invalid auth message\" + JSON.stringify(config));\r\n        }\r\n\r\n        const helloMsg: any = {\r\n            type: \"hello\",\r\n            identity: this.settings.identity,\r\n            authentication\r\n        };\r\n\r\n        if (config.sessionId) {\r\n            helloMsg.request_id = config.sessionId;\r\n        }\r\n\r\n        this.globalDomain = domainSession(\r\n            \"global\",\r\n            this.connection,\r\n            this.logger.subLogger(\"global-domain\"),\r\n            [\r\n                \"welcome\",\r\n                \"token\",\r\n                \"authentication-request\"\r\n            ]);\r\n\r\n        const sendOptions: Glue42Core.Connection.SendMessageOptions = { skipPeerId: true };\r\n        if (this.initialLogin) {\r\n            sendOptions.retryInterval = this.settings.reconnectInterval;\r\n            sendOptions.maxRetries = this.settings.reconnectAttempts;\r\n        }\r\n\r\n        try {\r\n            let welcomeMsg: WelcomeMessage;\r\n\r\n            while (true) {\r\n                const msg: any = await this.globalDomain.send(helloMsg, undefined, sendOptions);\r\n                if (msg.type === \"authentication-request\") {\r\n                    // respond to auth challenge\r\n                    const token = Buffer.from(msg.authentication.token, \"base64\");\r\n                    if (config.flowCallback && config.sessionId) {\r\n                        helloMsg.authentication.token =\r\n                            (await config.flowCallback(config.sessionId, token))\r\n                                .data\r\n                                .toString(\"base64\");\r\n                    }\r\n                    helloMsg.request_id = config.sessionId;\r\n                    continue;\r\n                } else if (msg.type === \"welcome\") {\r\n                    // we're in\r\n                    welcomeMsg = msg as WelcomeMessage;\r\n                    break;\r\n                } else if (msg.type === \"error\") {\r\n                    throw new Error(\"Authentication failed: \" + msg.reason);\r\n                } else {\r\n                    throw new Error(\"Unexpected message type during authentication: \" + msg.type);\r\n                }\r\n            }\r\n            // we've logged in once - set this to false for the rest of the lifetime\r\n            this.initialLogin = false;\r\n            this.logger.debug(\"login successful with peerId \" + welcomeMsg.peer_id);\r\n\r\n            this.connection.peerId = welcomeMsg.peer_id;\r\n            this.connection.resolvedIdentity = welcomeMsg.resolved_identity;\r\n            this.connection.availableDomains = welcomeMsg.available_domains as any;\r\n            if (welcomeMsg.options) {\r\n                this.connection.token = welcomeMsg.options.access_token;\r\n                this.connection.info = welcomeMsg.options.info;\r\n            }\r\n            this.setLoggedIn(true);\r\n            return welcomeMsg.resolved_identity;\r\n        } catch (err) {\r\n            this.logger.error(\"error sending hello message - \" + (err.message || err.msg || err.reason || err), err);\r\n            throw err;\r\n        } finally {\r\n            if (config && config.flowCallback && config.sessionId) {\r\n                config.flowCallback(config.sessionId, null);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async logout(): Promise<void> {\r\n        this.logger.debug(\"logging out...\");\r\n        this.shouldTryLogin = false;\r\n\r\n        if (this.pingTimer) {\r\n            clearTimeout(this.pingTimer);\r\n        }\r\n\r\n        // go through all sessions and leave the corresponding domain\r\n        const promises = this.sessions.map((session) => {\r\n            session.leave();\r\n        });\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    public loggedIn(callback: (() => void)): () => void {\r\n        if (this._isLoggedIn) {\r\n            callback();\r\n        }\r\n        return this.registry.add(\"onLoggedIn\", callback);\r\n    }\r\n\r\n    public domain(domainName: string, domainLogger: Logger, successMessages?: string[], errorMessages?: string[]): Glue42Core.Connection.GW3DomainSession {\r\n        let session = this.sessions.filter((s) => s.domain === domainName)[0];\r\n        if (!session) {\r\n            session = domainSession(domainName, this.connection, domainLogger, successMessages, errorMessages);\r\n            this.sessions.push(session);\r\n        }\r\n        return session;\r\n    }\r\n\r\n    public handleDisconnected() {\r\n        this.setLoggedIn(false);\r\n        const tryToLogin = this.shouldTryLogin;\r\n        if (tryToLogin && this.initialLogin) {\r\n            if (this.initialLoginAttempts <= 0) {\r\n                return;\r\n            }\r\n            this.initialLoginAttempts--;\r\n        }\r\n\r\n        this.logger.debug(\"disconnected - will try new login?\" + this.shouldTryLogin);\r\n        if (this.shouldTryLogin) {\r\n            if (!this.loginConfig) {\r\n                throw new Error(\"no login info\");\r\n            }\r\n\r\n            this.connection.login(this.loginConfig, true)\r\n                .catch(() => {\r\n                    setTimeout(this.handleDisconnected.bind(this), this.settings.reconnectInterval || 1000);\r\n                });\r\n        }\r\n    }\r\n\r\n    public setLoggedIn(value: boolean) {\r\n        this._isLoggedIn = value;\r\n        if (this._isLoggedIn) {\r\n            this.registry.execute(\"onLoggedIn\");\r\n        }\r\n    }\r\n\r\n    public ping() {\r\n        // if we don't want to be connected return\r\n        if (!this.shouldTryLogin) {\r\n            return;\r\n        }\r\n\r\n        // if logged in ping\r\n        if (this._isLoggedIn) {\r\n            this.connection.send({ type: \"ping\" });\r\n        }\r\n\r\n        // schedule next after 30 sec\r\n        this.pingTimer = setTimeout(() => {\r\n            this.ping();\r\n        }, 30 * 1000);\r\n    }\r\n\r\n    public authToken(): Promise<string> {\r\n        const createTokenReq: CreateTokenReq = {\r\n            type: \"create-token\"\r\n        };\r\n\r\n        if (!this.globalDomain) {\r\n            return Promise.reject(new Error(\"no global domain session\"));\r\n        }\r\n\r\n        return this.globalDomain.send<CreateTokenRes>(createTokenReq)\r\n            .then((res: CreateTokenRes) => {\r\n                return res.token;\r\n            });\r\n    }\r\n\r\n    private getNewGWToken(): Promise<string | undefined> {\r\n        if (typeof window !== undefined) {\r\n            // pull up a new token from gd\r\n            const glue42gd = window.glue42gd;\r\n            if (glue42gd) {\r\n                return glue42gd.getGWToken();\r\n            }\r\n        }\r\n        return Promise.reject(new Error(\"not running in GD\"));\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\n\r\nexport class MessageReplayerImpl implements Glue42Core.Connection.MessageReplayer {\r\n    private specs: { [name: string]: Glue42Core.Connection.MessageReplaySpec };\r\n    private specsNames: string[] = [];\r\n    private messages: { [type: string]: object[] } = {};\r\n    private isDone: boolean | undefined;\r\n    private subs: { [type: string]: any } = {};\r\n    private subsRefCount: { [type: string]: number } = {};\r\n    private connection: Glue42Core.Connection.API | undefined;\r\n\r\n    constructor(specs: Glue42Core.Connection.MessageReplaySpec[]) {\r\n        this.specs = {};\r\n        for (const spec of specs) {\r\n            this.specs[spec.name] = spec;\r\n            this.specsNames.push(spec.name);\r\n        }\r\n    }\r\n\r\n    public init(connection: Glue42Core.Connection.API) {\r\n        this.connection = connection;\r\n        for (const name of this.specsNames) {\r\n            for (const type of this.specs[name].types) {\r\n                let refCount = this.subsRefCount[type];\r\n                if (!refCount) {\r\n                    refCount = 0;\r\n                }\r\n                refCount += 1;\r\n                this.subsRefCount[type] = refCount;\r\n                if (refCount > 1) {\r\n                    continue;\r\n                }\r\n\r\n                const sub = connection.on<object>(\r\n                    type,\r\n                    (msg) => this.processMessage(type, msg));\r\n\r\n                this.subs[type] = sub;\r\n            }\r\n        }\r\n    }\r\n\r\n    public processMessage(type: string, msg: object) {\r\n        if (this.isDone || !msg) {\r\n            return;\r\n        }\r\n\r\n        for (const name of this.specsNames) {\r\n            if (this.specs[name].types.indexOf(type) !== -1) {\r\n                const messages = this.messages[name] || [];\r\n                this.messages[name] = messages;\r\n                messages.push(msg);\r\n            }\r\n        }\r\n    }\r\n\r\n    public drain(name: string, callback?: (msg: object) => void) {\r\n        if (callback) {\r\n            (this.messages[name] || []).forEach(callback);\r\n        }\r\n\r\n        delete this.messages[name];\r\n\r\n        for (const type of this.specs[name].types) {\r\n            this.subsRefCount[type] -= 1;\r\n            if (this.subsRefCount[type] <= 0) {\r\n                this.connection?.off(this.subs[type]);\r\n                delete this.subs[type];\r\n                delete this.subsRefCount[type];\r\n            }\r\n        }\r\n\r\n        delete this.specs[name];\r\n\r\n        if (!this.specs.length) {\r\n            this.isDone = true;\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nexport const PromisePlus = <T>(executor: (resolve: (value?: T | PromiseLike<T> | undefined) => void, reject: (reason?: any) => void) => void, timeoutMilliseconds: number, timeoutMessage?: string): Promise<T> => {\r\n\r\n    return new Promise<T>((resolve, reject) => {\r\n        const timeout = setTimeout(() => {\r\n\r\n            const message = timeoutMessage || `Promise timeout hit: ${timeoutMilliseconds}`;\r\n\r\n            reject(message);\r\n        }, timeoutMilliseconds);\r\n\r\n        const providedPromise = new Promise<T>(executor);\r\n\r\n        providedPromise\r\n            .then((result) => {\r\n                clearTimeout(timeout);\r\n                resolve(result);\r\n            })\r\n            .catch((error) => {\r\n                clearTimeout(timeout);\r\n                reject(error);\r\n            });\r\n    });\r\n\r\n};\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { Identity, Transport } from \"../types\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport {\r\n    default as CallbackRegistryFactory,\r\n    CallbackRegistry,\r\n    UnsubscribeFunction,\r\n} from \"callback-registry\";\r\nimport generate from \"shortid\";\r\nimport { PromisePlus } from \"../../utils/promise-plus\";\r\n\r\ntype MessageType = \"connectionAccepted\" | \"connectionRejected\" | \"connectionRequest\" | \"parentReady\" |\r\n    \"parentPing\" | \"platformPing\" | \"platformUnload\" | \"platformReady\" | \"clientUnload\" | \"manualUnload\" |\r\n    \"extConnectionResponse\" | \"extSetupRequest\";\r\n\r\nexport default class WebPlatformTransport implements Transport {\r\n\r\n    private publicWindowId: string | undefined;\r\n    private parentReady = false;\r\n    private iAmConnected = false;\r\n    private rejected = false;\r\n    private parentPingResolve: ((value?: void | PromiseLike<void> | undefined) => void) | undefined;\r\n    private connectionResolve: ((value?: void | PromiseLike<void> | undefined) => void) | undefined;\r\n    private extConnectionResolve: ((value: void | PromiseLike<void>) => void) | undefined;\r\n    private extConnectionReject: ((reason?: any) => void) | undefined;\r\n    private connectionReject: ((reason?: unknown) => void) | undefined;\r\n    private port: MessagePort | undefined;\r\n    private myClientId: string | undefined;\r\n    private children: Array<{ grandChildId: string; source: Window; connected: boolean; origin: string }> = [];\r\n\r\n    private extContentAvailable = false;\r\n    private extContentConnecting = false;\r\n    private extContentConnected = false;\r\n    private parentWindowId: string | undefined;\r\n    private parentInExtMode = false;\r\n\r\n    private readonly parent: Window | undefined;\r\n    private readonly parentType: \"opener\" | \"top\" | \"workspace\" | undefined;\r\n    private readonly parentPingTimeout = 3000;\r\n    private readonly connectionRequestTimeout = 5000;\r\n    private readonly defaultTargetString = \"*\";\r\n    private readonly registry: CallbackRegistry = CallbackRegistryFactory();\r\n    private readonly messages: { [key in MessageType]: { name: string; handle: (event: MessageEvent) => void } } = {\r\n        connectionAccepted: { name: \"connectionAccepted\", handle: this.handleConnectionAccepted.bind(this) },\r\n        connectionRejected: { name: \"connectionRejected\", handle: this.handleConnectionRejected.bind(this) },\r\n        connectionRequest: { name: \"connectionRequest\", handle: this.handleConnectionRequest.bind(this) },\r\n        parentReady: { name: \"parentReady\", handle: this.handleParentReady.bind(this) },\r\n        parentPing: { name: \"parentPing\", handle: this.handleParentPing.bind(this) },\r\n        platformPing: { name: \"platformPing\", handle: this.handlePlatformPing.bind(this) },\r\n        platformUnload: { name: \"platformUnload\", handle: this.handlePlatformUnload.bind(this) },\r\n        platformReady: { name: \"platformReady\", handle: this.handlePlatformReady.bind(this) },\r\n        clientUnload: { name: \"clientUnload\", handle: this.handleClientUnload.bind(this) },\r\n        manualUnload: { name: \"manualUnload\", handle: this.handleManualUnload.bind(this) },\r\n        extConnectionResponse: { name: \"extConnectionResponse\", handle: this.handleExtConnectionResponse.bind(this) },\r\n        extSetupRequest: { name: \"extSetupRequest\", handle: this.handleExtSetupRequest.bind(this) }\r\n    };\r\n\r\n    constructor(private readonly settings: Glue42Core.WebPlatformConnection, private readonly logger: Logger, private readonly identity?: Identity) {\r\n        this.extContentAvailable = !!(window as any).glue42ext;\r\n\r\n        this.setUpMessageListener();\r\n        this.setUpUnload();\r\n\r\n        if (!this.settings.port) {\r\n            this.parent = window.opener || window.top;\r\n\r\n            this.parentType = window.opener ? \"opener\" :\r\n                window.name.indexOf(\"#wsp\") !== -1 ? \"workspace\" : \"top\";\r\n        }\r\n    }\r\n\r\n    public get transportWindowId(): string | undefined {\r\n        return this.publicWindowId;\r\n    }\r\n\r\n    public async sendObject(msg: object): Promise<void> {\r\n\r\n        if (this.extContentConnected) {\r\n            return window.postMessage({ glue42ExtOut: msg }, this.defaultTargetString);\r\n        }\r\n\r\n        if (!this.port) {\r\n            throw new Error(\"Cannot send message, because the port was not opened yet\");\r\n        }\r\n        this.port.postMessage(msg);\r\n    }\r\n\r\n    public get isObjectBasedTransport(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public onMessage(callback: (msg: string | object) => void): UnsubscribeFunction {\r\n        return this.registry.add(\"onMessage\", callback);\r\n    }\r\n\r\n    public send(): Promise<void> {\r\n        return Promise.reject(\"not supported\");\r\n    }\r\n\r\n    public onConnectedChanged(callback: (connected: boolean, reason?: string) => void): UnsubscribeFunction {\r\n        return this.registry.add(\"onConnectedChanged\", callback);\r\n    }\r\n\r\n    public async open(): Promise<void> {\r\n\r\n        this.logger.debug(\"opening a connection to the web platform gateway.\");\r\n\r\n        await this.connect();\r\n\r\n        this.notifyStatusChanged(true);\r\n    }\r\n\r\n    public close(): Promise<void> {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public name(): string {\r\n        return \"web-platform\";\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        // DO NOTHING\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private async connect(): Promise<void> {\r\n\r\n        if (this.parentReady) {\r\n            this.logger.debug(\"cancelling connection attempt, because this client's parent has already given a ready signal\");\r\n            return;\r\n        }\r\n\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"opening an internal web platform connection\");\r\n            this.port = this.settings.port;\r\n\r\n            this.publicWindowId = this.settings.windowId;\r\n\r\n            if (this.identity) {\r\n                this.identity.windowId = this.publicWindowId;\r\n            }\r\n\r\n            this.port.onmessage = (event): object[] => this.registry.execute(\"onMessage\", event.data);\r\n            this.logger.debug(\"internal web platform connection completed\");\r\n            return;\r\n        }\r\n\r\n        if (!this.parentType || !this.parent) {\r\n            throw new Error(\"Cannot initiate a connection, because there is no opener, no top and no port.\");\r\n        }\r\n\r\n        this.logger.debug(`opening a ${this.parentType === \"opener\" ? \"child\" : \"grandchild\"} client web platform connection`);\r\n\r\n        await this.waitParent(this.parent, this.parentType);\r\n\r\n        if (this.parentInExtMode) {\r\n            await this.requestConnectionPermissionFromExt();\r\n        }\r\n\r\n        await this.initiateRemoteConnection(this.parent, this.parentType);\r\n\r\n        this.logger.debug(`the ${this.parentType === \"opener\" ? \"child\" : \"grandchild\"} client is connected`);\r\n    }\r\n\r\n    private initiateRemoteConnection(target: Window, parentType: \"opener\" | \"top\" | \"workspace\"): Promise<void> {\r\n\r\n        return PromisePlus<void>((resolve, reject) => {\r\n            this.connectionResolve = resolve;\r\n            this.connectionReject = reject;\r\n\r\n            this.myClientId = generate();\r\n\r\n            const bridgeInstanceId = this.parentType === \"workspace\" ? window.name.substring(0, window.name.indexOf(\"#wsp\")) : window.name;\r\n\r\n            const request = {\r\n                glue42core: {\r\n                    type: this.messages.connectionRequest.name,\r\n                    clientId: this.myClientId,\r\n                    clientType: parentType === \"top\" || parentType === \"workspace\" ? \"grandChild\" : \"child\",\r\n                    bridgeInstanceId\r\n                }\r\n            };\r\n\r\n            this.logger.debug(`sending connection request to ${parentType}`);\r\n\r\n            if (this.extContentConnecting) {\r\n                request.glue42core.clientType = \"child\";\r\n                request.glue42core.bridgeInstanceId = this.myClientId;\r\n                (request as any).glue42core.parentWindowId = this.parentWindowId;\r\n                return window.postMessage(request, this.defaultTargetString);\r\n            }\r\n\r\n            target.postMessage(request, this.defaultTargetString);\r\n        }, this.connectionRequestTimeout, \"The connection to the opener/top window timed out\");\r\n\r\n    }\r\n\r\n    private async waitParent(target: Window, parentType: \"opener\" | \"top\" | \"workspace\"): Promise<void> {\r\n        const connectionNotPossibleMsg = \"Cannot initiate glue, because this window was not opened or created by a glue client\";\r\n\r\n        const parentCheck = PromisePlus<void>((resolve, reject) => {\r\n\r\n            const isIframe = window.self !== window.top;\r\n\r\n            if (parentType === \"top\" && !isIframe) {\r\n                return reject(connectionNotPossibleMsg);\r\n            }\r\n\r\n            this.parentPingResolve = resolve;\r\n\r\n            const message = {\r\n                glue42core: {\r\n                    type: parentType === \"opener\" ? this.messages.platformPing.name : this.messages.parentPing.name\r\n                }\r\n            };\r\n\r\n            this.logger.debug(`checking for ${parentType} window availability`);\r\n\r\n            target.postMessage(message, this.defaultTargetString);\r\n        }, this.parentPingTimeout, connectionNotPossibleMsg);\r\n\r\n        if (!this.extContentAvailable) {\r\n            return parentCheck;\r\n        }\r\n\r\n        try {\r\n            await parentCheck;\r\n\r\n            return;\r\n        } catch (error) {\r\n            this.logger.debug(\"the parent check failed, but there is an associated extension content script, requesting permission...\");\r\n            // all attempts failed, but there is a glue extension content script\r\n            // requesting connection permission there\r\n            await this.requestConnectionPermissionFromExt();\r\n        }\r\n\r\n    }\r\n\r\n    private setUpMessageListener(): void {\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"skipping generic message listener, because this is an internal client\");\r\n            // do not set up listener, because this is running as an internal client for the platform\r\n            return;\r\n        }\r\n\r\n        window.addEventListener(\"message\", (event) => {\r\n            const data = event.data?.glue42core;\r\n\r\n            if (!data || this.rejected) {\r\n                return;\r\n            }\r\n\r\n            if (!this.checkMessageTypeValid(data.type)) {\r\n                this.logger.error(`cannot handle the incoming glue42 core message, because the type is invalid: ${data.type}`);\r\n                return;\r\n            }\r\n\r\n            const messageType = data.type as MessageType;\r\n\r\n            this.logger.debug(`received valid glue42core message of type: ${messageType}`);\r\n\r\n            this.messages[messageType].handle(event);\r\n        });\r\n    }\r\n\r\n    private setUpUnload(): void {\r\n        if (this.settings.port) {\r\n            this.logger.debug(\"skipping unload event listener, because this is an internal client\");\r\n            // do not set up listener, because this is running as an internal client for the platform\r\n            return;\r\n        }\r\n\r\n        window.addEventListener(\"beforeunload\", () => {\r\n\r\n            if (this.extContentConnected) {\r\n                // before unload in this case should be handled in the content script\r\n                return;\r\n            }\r\n\r\n            const message = {\r\n                glue42core: {\r\n                    type: this.messages.clientUnload.name,\r\n                    data: {\r\n                        clientId: this.myClientId,\r\n                        ownWindowId: this.identity?.windowId\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (this.parent) {\r\n                this.parent.postMessage(message, this.defaultTargetString);\r\n            }\r\n\r\n            this.port?.postMessage(message);\r\n        });\r\n    }\r\n\r\n    private handleParentReady(event: MessageEvent): void {\r\n        this.logger.debug(\"handling the ready signal from the parent, by resoling the pending promise.\");\r\n        this.parentReady = true;\r\n\r\n        const data = event.data?.glue42core;\r\n\r\n        if (data && data.extMode) {\r\n            this.logger.debug(\"my parent is connected to its content script, fetching windowId and proceeding with content script connection\");\r\n            this.parentWindowId = data.extMode.windowId;\r\n            this.parentInExtMode = true;\r\n        }\r\n\r\n        if (this.parentPingResolve) {\r\n            this.parentPingResolve();\r\n            delete this.parentPingResolve;\r\n            return;\r\n        }\r\n\r\n        this.logger.debug(\"silently handling the ready signal from the top parent, because there is no defined promise\");\r\n    }\r\n\r\n    private handlePlatformReady(): void {\r\n        this.logger.debug(\"the web platform gave the ready signal\");\r\n        this.parentReady = true;\r\n\r\n        if (this.parentPingResolve) {\r\n            this.parentPingResolve();\r\n            delete this.parentPingResolve;\r\n            return;\r\n        }\r\n\r\n        this.logger.debug(\"silently handling the ready signal from the top parent, because there is no defined promise\");\r\n    }\r\n\r\n    private handleConnectionAccepted(event: MessageEvent): void {\r\n        const data = event.data?.glue42core;\r\n\r\n        if (this.myClientId === data.clientId) {\r\n            return this.handleAcceptanceOfMyRequest(data);\r\n        }\r\n\r\n        return this.handleAcceptanceOfGrandChildRequest(data, event);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private handleAcceptanceOfMyRequest(data: any): void {\r\n        this.logger.debug(\"handling a connection accepted signal targeted at me.\");\r\n\r\n        if (this.extContentConnecting) {\r\n            return this.processExtContentConnection(data);\r\n        }\r\n\r\n        if (!data.port) {\r\n            this.logger.error(\"cannot set up my connection, because I was not provided with a port\");\r\n            return;\r\n        }\r\n\r\n        this.publicWindowId = this.parentType === \"opener\" ? window.name :\r\n            this.parentType === \"top\" ? data.parentWindowId :\r\n                window.name.substring(0, window.name.indexOf(\"#wsp\"));\r\n\r\n        if (this.identity && this.parentType !== \"top\") {\r\n            this.identity.windowId = this.publicWindowId;\r\n        }\r\n\r\n        if (this.identity && data.appName) {\r\n            this.identity.application = data.appName;\r\n            this.identity.applicationName = data.appName;\r\n        }\r\n\r\n        this.port = data.port as MessagePort;\r\n        this.port.onmessage = (e): object[] => this.registry.execute(\"onMessage\", e.data);\r\n\r\n        if (this.connectionResolve) {\r\n            this.logger.debug(\"my connection is set up, calling the connection resolve.\");\r\n            this.connectionResolve();\r\n            delete this.connectionResolve;\r\n            return;\r\n        }\r\n\r\n        this.logger.error(\"unable to call the connection resolve, because no connection promise was found\");\r\n    }\r\n\r\n    private processExtContentConnection(data: any): void {\r\n        this.logger.debug(\"handling a connection accepted signal targeted at me for extension content connection.\");\r\n\r\n        this.extContentConnecting = false;\r\n        this.extContentConnected = true;\r\n\r\n        this.publicWindowId = this.parentWindowId || this.myClientId;\r\n\r\n        if (this.extContentConnecting && this.identity) {\r\n            this.identity.windowId = this.publicWindowId;\r\n        }\r\n\r\n        if (this.identity && data.appName) {\r\n            this.identity.application = data.appName;\r\n            this.identity.applicationName = data.appName;\r\n        }\r\n\r\n        window.addEventListener(\"message\", (event) => {\r\n            const extData = event.data?.glue42ExtInc;\r\n\r\n            if (!extData) {\r\n                return;\r\n            }\r\n\r\n            this.registry.execute(\"onMessage\", extData);\r\n        });\r\n\r\n        if (this.connectionResolve) {\r\n            this.logger.debug(\"my connection is set up, calling the connection resolve.\");\r\n            this.connectionResolve();\r\n            delete this.connectionResolve;\r\n            return;\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    private handleAcceptanceOfGrandChildRequest(data: any, event: MessageEvent): void {\r\n        if (this.extContentConnecting || this.extContentConnected) {\r\n            this.logger.debug(\"cannot process acceptance of a grandchild, because I am connected to a content script\");\r\n            return;\r\n        }\r\n        this.logger.debug(`handling a connection accepted signal targeted at a grandchild: ${data.clientId}`);\r\n\r\n        const child = this.children.find((c) => c.grandChildId === data.clientId);\r\n\r\n        if (!child) {\r\n            this.logger.error(`cannot handle connection accepted for grandchild: ${data.clientId}, because there is no grandchild with this id`);\r\n            return;\r\n        }\r\n\r\n        child.connected = true;\r\n\r\n        this.logger.debug(`the grandchild connection for ${data.clientId} is set up, forwarding the success message and the gateway port`);\r\n\r\n        data.parentWindowId = this.publicWindowId;\r\n\r\n        child.source.postMessage(event.data, child.origin, [data.port]);\r\n        return;\r\n    }\r\n\r\n    private handleConnectionRejected(): void {\r\n        this.logger.debug(\"handling a connection rejection. Most likely the reason is that this window was not created by a glue API call\");\r\n        if (this.connectionReject) {\r\n            this.connectionReject(\"The platform connection was rejected. Most likely because this window was not created by a glue API call\");\r\n            delete this.connectionReject;\r\n        }\r\n    }\r\n\r\n    private handleConnectionRequest(event: MessageEvent): void {\r\n\r\n        if (this.extContentConnecting) {\r\n            // I am being connected now and this is handled in the associated content script\r\n            this.logger.debug(\"This connection request event is targeted at the extension content\");\r\n            return;\r\n        }\r\n\r\n        const source = event.source as Window;\r\n        const data = event.data.glue42core;\r\n\r\n        if (!data.clientType || data.clientType !== \"grandChild\") {\r\n            return this.rejectConnectionRequest(source, event.origin, \"rejecting a connection request, because the source was not opened by a glue API call\");\r\n        }\r\n\r\n        if (!data.clientId) {\r\n            return this.rejectConnectionRequest(source, event.origin, \"rejecting a connection request, because the source did not provide a valid id\");\r\n        }\r\n\r\n        if (this.parentType !== \"opener\" || !this.parent) {\r\n            return this.rejectConnectionRequest(source, event.origin, \"Cannot forward the connection request, because no direct connection to the platform was found\");\r\n        }\r\n\r\n        this.logger.debug(`handling a connection request for a grandchild: ${data.clientId}`);\r\n\r\n        this.children.push({ grandChildId: data.clientId, source, connected: false, origin: event.origin });\r\n\r\n        this.logger.debug(`grandchild: ${data.clientId} is prepared, forwarding connection request to the platform`);\r\n\r\n        this.parent.postMessage(event.data, this.defaultTargetString);\r\n    }\r\n\r\n    private handleParentPing(event: MessageEvent): void {\r\n\r\n        if (!this.parentReady) {\r\n            this.logger.debug(\"my parent is not ready, I am ignoring the parent ping\");\r\n            return;\r\n        }\r\n\r\n        if (!this.iAmConnected) {\r\n            this.logger.debug(\"i am not fully connected yet, I am ignoring the parent ping\");\r\n            return;\r\n        }\r\n\r\n        const message = {\r\n            glue42core: {\r\n                type: this.messages.parentReady.name\r\n            }\r\n        };\r\n\r\n        if (this.extContentConnected) {\r\n            (message as any).glue42core.extMode = { windowId: this.myClientId };\r\n        }\r\n\r\n        const source = event.source as Window;\r\n\r\n        this.logger.debug(\"responding to a parent ping with a ready message\");\r\n\r\n        source.postMessage(message, event.origin);\r\n    }\r\n\r\n    private handlePlatformUnload(event: MessageEvent): void {\r\n        this.logger.debug(\"detected a web platform unload\");\r\n\r\n        this.parentReady = false;\r\n\r\n        if (this.children.length) {\r\n            this.logger.debug(\"forwarding the platform unload to all known children and starting platform discovery polling\");\r\n            this.children.forEach((child) => child.source.postMessage(event.data, child.origin));\r\n        }\r\n\r\n        this.notifyStatusChanged(false, \"Gateway unloaded\");\r\n\r\n    }\r\n\r\n    private handleManualUnload(): void {\r\n        const message = {\r\n            glue42core: {\r\n                type: this.messages.clientUnload.name,\r\n                data: {\r\n                    clientId: this.myClientId,\r\n                    ownWindowId: this.identity?.windowId\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this.parent) {\r\n            this.parent.postMessage(message, this.defaultTargetString);\r\n        }\r\n\r\n        if (this.extContentConnected) {\r\n            return window.postMessage({ glue42ExtOut: message }, this.defaultTargetString);\r\n        }\r\n\r\n        this.port?.postMessage(message);\r\n    }\r\n\r\n    private handleClientUnload(event: MessageEvent): void {\r\n        const data = event.data.glue42core;\r\n        const clientId = data?.data.clientId;\r\n\r\n        if (!clientId) {\r\n            this.logger.warn(\"cannot process grand child unload, because the provided id was not valid\");\r\n            return;\r\n        }\r\n\r\n        const foundChild = this.children.find((child) => child.grandChildId === clientId);\r\n\r\n        if (!foundChild) {\r\n            this.logger.warn(\"cannot process grand child unload, because this client is unaware of this grandchild\");\r\n            return;\r\n        }\r\n\r\n        this.logger.debug(`handling grandchild unload for id: ${clientId}`);\r\n\r\n        this.children = this.children.filter((child) => child.grandChildId !== clientId);\r\n    }\r\n\r\n    private handlePlatformPing(): void {\r\n        this.logger.error(\"cannot handle platform ping, because this is not a platform calls handling component\");\r\n    }\r\n\r\n    private notifyStatusChanged(status: boolean, reason?: string): void {\r\n        this.iAmConnected = status;\r\n        this.registry.execute(\"onConnectedChanged\", status, reason);\r\n    }\r\n\r\n    private checkMessageTypeValid(typeToValidate: string): boolean {\r\n        return typeof typeToValidate === \"string\" && !!this.messages[typeToValidate as MessageType];\r\n    }\r\n\r\n    private rejectConnectionRequest(source: Window, origin: string, reason: string): void {\r\n        this.rejected = true;\r\n        this.logger.error(reason);\r\n\r\n        const rejection = {\r\n            glue42core: {\r\n                type: this.messages.connectionRejected.name\r\n            }\r\n        };\r\n\r\n        source.postMessage(rejection, origin);\r\n    }\r\n\r\n    // --- ext methods ---\r\n\r\n    private requestConnectionPermissionFromExt(): Promise<void> {\r\n\r\n        // here I know that a content script is started, but not sure if it is ready\r\n\r\n        return this.waitForContentScript()\r\n            .then(() => PromisePlus<void>((resolve, reject) => {\r\n                this.extConnectionResolve = resolve;\r\n                this.extConnectionReject = reject;\r\n\r\n                const message = {\r\n                    glue42core: {\r\n                        type: \"extSetupRequest\"\r\n                    }\r\n                };\r\n\r\n                this.logger.debug(\"permission request to the extension content script was sent\");\r\n\r\n                window.postMessage(message, this.defaultTargetString);\r\n            }, this.parentPingTimeout, \"Cannot initialize glue, because this app was not opened or created by a Glue Client and the request for extension connection timed out\"));\r\n    }\r\n\r\n    private handleExtConnectionResponse(event: MessageEvent): void {\r\n        const data = event.data?.glue42core;\r\n\r\n        if (!data.approved && this.extConnectionReject) {\r\n            return this.extConnectionReject(\"Cannot initialize glue, because this app was not opened or created by a Glue Client and the request for extension connection was rejected\");\r\n        }\r\n\r\n        if (this.extConnectionResolve) {\r\n            this.extContentConnecting = true;\r\n            this.logger.debug(\"The extension connection was approved, proceeding.\");\r\n            this.extConnectionResolve();\r\n            delete this.extConnectionResolve;\r\n        }\r\n    }\r\n\r\n    private handleExtSetupRequest(): void {\r\n        // this is handled by the associated content script\r\n        return;\r\n    }\r\n\r\n    private waitForContentScript(): Promise<void> {\r\n        const contentReady = !!(window as any).glue42ext?.content;\r\n\r\n        if (contentReady) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return PromisePlus<void>((resolve) => {\r\n\r\n            window.addEventListener(\"Glue42EXTReady\", () => {\r\n                resolve();\r\n            });\r\n\r\n        }, this.connectionRequestTimeout, \"The content script was available, but was never heard to be ready\");\r\n    }\r\n}\r\n","import {\r\n    default as CallbackFactory,\r\n    CallbackRegistry,\r\n} from \"callback-registry\";\r\nimport {\r\n    GW3Protocol,\r\n    Transport,\r\n    ConnectionSettings,\r\n    Identity,\r\n} from \"./types\";\r\nimport { Logger } from \"../logger/logger\";\r\n\r\nimport { Glue42Core } from \"../../glue\";\r\nimport InProcTransport from \"./transports/inProc\";\r\nimport SharedWorkerTransport from \"./transports/worker\";\r\nimport WS from \"./transports/ws\";\r\nimport GW3ProtocolImpl from \"./protocols/gw3\";\r\nimport { MessageReplayerImpl } from \"./replayer\";\r\nimport timer from \"../utils/timer\";\r\nimport WebPlatformTransport from \"./transports/webPlatform\";\r\n\r\n/**\r\n * A template for gateway connections - this is extended from specific protocols and transports.\r\n */\r\nexport default class Connection implements Glue42Core.Connection.API {\r\n\r\n    public peerId!: string;\r\n    public token!: string;\r\n    public info!: object;\r\n    public resolvedIdentity!: any;\r\n    public availableDomains!: Glue42Core.Connection.GWDomainInfo[];\r\n    public gatewayToken: string | undefined;\r\n    public replayer?: MessageReplayerImpl;\r\n\r\n    protected protocol: GW3Protocol;\r\n\r\n    // The message handlers that have to be executed for each received message\r\n    protected messageHandlers: {\r\n        [key: string]: { [key: string]: (msg: any) => void };\r\n    } = {};\r\n    protected ids = 1;\r\n    protected registry: CallbackRegistry = CallbackFactory();\r\n    protected _connected = false;\r\n    private isTrace = false;\r\n    private transport: Transport;\r\n\r\n    public get protocolVersion() {\r\n        return this.protocol?.protocolVersion;\r\n    }\r\n\r\n    constructor(private settings: ConnectionSettings, private logger: Logger) {\r\n        settings = settings || {};\r\n        settings.reconnectAttempts = settings.reconnectAttempts || 10;\r\n        settings.reconnectInterval = settings.reconnectInterval || 1000;\r\n\r\n        if (settings.inproc) {\r\n            this.transport = new InProcTransport(settings.inproc, logger.subLogger(\"inMemory\"));\r\n        } else if (settings.sharedWorker) {\r\n            this.transport = new SharedWorkerTransport(settings.sharedWorker, logger.subLogger(\"shared-worker\"));\r\n        } else if (settings.webPlatform) {\r\n            this.transport = new WebPlatformTransport(settings.webPlatform, logger.subLogger(\"web-platform\"), settings.identity);\r\n        } else if (settings.ws !== undefined) {\r\n            this.transport = new WS(settings, logger.subLogger(\"ws\"));\r\n        } else {\r\n            throw new Error(\"No connection information specified\");\r\n        }\r\n\r\n        this.isTrace = logger.canPublish(\"trace\");\r\n        logger.debug(`starting with ${this.transport.name()} transport`);\r\n\r\n        this.protocol = new GW3ProtocolImpl(this, settings, logger.subLogger(\"protocol\"));\r\n        this.transport.onConnectedChanged(\r\n            this.handleConnectionChanged.bind(this)\r\n        );\r\n        this.transport.onMessage(this.handleTransportMessage.bind(this));\r\n\r\n        if (settings.replaySpecs && settings.replaySpecs.length) {\r\n            this.replayer = new MessageReplayerImpl(settings.replaySpecs);\r\n            this.replayer.init(this);\r\n        }\r\n    }\r\n\r\n    public send(message: object, options?: Glue42Core.Connection.SendMessageOptions): Promise<void> {\r\n        // create a message using the protocol\r\n        if (\r\n            this.transport.sendObject &&\r\n            this.transport.isObjectBasedTransport\r\n        ) {\r\n            const msg = this.protocol.createObjectMessage(message);\r\n            if (this.isTrace) {\r\n                this.logger.trace(`>> ${JSON.stringify(msg)}`);\r\n            }\r\n            return this.transport.sendObject(msg, options);\r\n        } else {\r\n            const strMessage = this.protocol.createStringMessage(message);\r\n            if (this.isTrace) {\r\n                this.logger.trace(`>> ${strMessage}`);\r\n            }\r\n            return this.transport.send(strMessage, options);\r\n        }\r\n    }\r\n\r\n    public on<T>(\r\n        type: string,\r\n        messageHandler: (msg: T) => void\r\n    ): any {\r\n        type = type.toLowerCase();\r\n        if (this.messageHandlers[type] === undefined) {\r\n            this.messageHandlers[type] = {};\r\n        }\r\n\r\n        const id = this.ids++;\r\n        this.messageHandlers[type][id] = messageHandler;\r\n\r\n        return {\r\n            type,\r\n            id,\r\n        };\r\n    }\r\n\r\n    // Remove a handler\r\n    public off(info: { type: string; id: number }) {\r\n        delete this.messageHandlers[info.type.toLowerCase()][info.id];\r\n    }\r\n\r\n    public get isConnected() {\r\n        return this.protocol.isLoggedIn;\r\n    }\r\n\r\n    public connected(callback: (server: string) => void): () => void {\r\n        return this.protocol.loggedIn(() => {\r\n            callback(this.settings.ws || this.settings.sharedWorker || \"\");\r\n        });\r\n    }\r\n\r\n    public disconnected(callback: () => void): () => void {\r\n        return this.registry.add(\"disconnected\", callback);\r\n    }\r\n\r\n    public async login(authRequest: Glue42Core.Auth, reconnect?: boolean): Promise<Identity> {\r\n        // open the protocol in case it was closed by explicity logout\r\n        await this.transport.open();\r\n        timer(\"connection\").mark(\"transport-opened\");\r\n        const identity = this.protocol.login(authRequest, reconnect);\r\n        timer(\"connection\").mark(\"protocol-logged-in\");\r\n        return identity;\r\n    }\r\n\r\n    public async logout() {\r\n        await this.protocol.logout();\r\n        await this.transport.close();\r\n    }\r\n\r\n    public loggedIn(callback: () => void) {\r\n        return this.protocol.loggedIn(callback);\r\n    }\r\n\r\n    public domain(\r\n        domain: string,\r\n        successMessages?: string[],\r\n        errorMessages?: string[]\r\n    ): Glue42Core.Connection.GW3DomainSession {\r\n        return this.protocol.domain(\r\n            domain,\r\n            this.logger.subLogger(`domain=${domain}`),\r\n            successMessages,\r\n            errorMessages\r\n        );\r\n    }\r\n\r\n    public authToken(): Promise<string> {\r\n        return this.protocol.authToken();\r\n    }\r\n\r\n    public reconnect(): Promise<void> {\r\n        return this.transport.reconnect();\r\n    }\r\n\r\n    private distributeMessage(message: object, type: string) {\r\n        // Retrieve handlers for the message type\r\n        const handlers = this.messageHandlers[type.toLowerCase()];\r\n        if (handlers !== undefined) {\r\n            // Execute them\r\n            Object.keys(handlers).forEach((handlerId) => {\r\n                const handler = handlers[handlerId];\r\n                if (handler !== undefined) {\r\n                    try {\r\n                        handler(message);\r\n                    } catch (error) {\r\n                        try {\r\n                            // logger might not be there yet\r\n                            this.logger.error(`Message handler failed with ${error.stack}`, error);\r\n                        } catch (loggerError) {\r\n                            // tslint:disable-next-line:no-console\r\n                            console.log(\"Message handler failed\", error);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private handleConnectionChanged(connected: boolean) {\r\n        if (this._connected === connected) {\r\n            return;\r\n        }\r\n        this._connected = connected;\r\n\r\n        if (connected) {\r\n            this.registry.execute(\"connected\");\r\n        } else {\r\n            this.registry.execute(\"disconnected\");\r\n        }\r\n    }\r\n\r\n    private handleTransportMessage(msg: string | object) {\r\n        let msgObj;\r\n        if (typeof msg === \"string\") {\r\n            msgObj = this.protocol.processStringMessage(msg);\r\n        } else {\r\n            msgObj = this.protocol.processObjectMessage(msg);\r\n        }\r\n\r\n        if (this.isTrace) {\r\n            this.logger.trace(`<< ${JSON.stringify(msgObj)}`);\r\n        }\r\n\r\n        this.distributeMessage(msgObj.msg, msgObj.msgType);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\n\r\nconst order: Glue42Core.LogLevel[] = [\"trace\", \"debug\", \"info\", \"warn\", \"error\", \"off\"];\r\n\r\nexport class Logger implements Glue42Core.Logger.API {\r\n    public static Interop: Glue42Core.Interop.API;\r\n    public static InteropMethodName = \"T42.AppLogger.Log\";\r\n\r\n    public static Instance: string;\r\n    public readonly path: string;\r\n\r\n    private subLoggers: Logger[] = [];\r\n    private _consoleLevel: Glue42Core.LogLevel | undefined;\r\n    private _publishLevel: Glue42Core.LogLevel | undefined;\r\n    private loggerFullName: string;\r\n    private includeTimeAndLevel: boolean;\r\n    private logFn: Glue42Core.CustomLogger = console;\r\n    private customLogFn: boolean = false;\r\n\r\n    constructor(public readonly name: string, private parent?: Logger, logFn?: Glue42Core.CustomLogger) {\r\n        this.name = name;\r\n\r\n        if (parent) {\r\n            this.path = `${parent.path}.${name}`;\r\n        } else {\r\n            this.path = name;\r\n        }\r\n\r\n        this.loggerFullName = `[${this.path}]`;\r\n        this.includeTimeAndLevel = !logFn;\r\n        if (logFn) {\r\n            this.logFn = logFn;\r\n            this.customLogFn = true;\r\n        }\r\n    }\r\n\r\n    public subLogger(name: string): Logger {\r\n        // Check if the sub-logger is already created\r\n        const existingSub = this.subLoggers.filter((subLogger) => {\r\n            return subLogger.name === name;\r\n        })[0];\r\n\r\n        if (existingSub !== undefined) {\r\n            return existingSub;\r\n        }\r\n\r\n        // Check if the name isn't the same as one of the parent properties\r\n        Object.keys(this).forEach((key) => {\r\n            if (key === name) {\r\n                throw new Error(\"This sub logger name is not allowed.\");\r\n            }\r\n        });\r\n\r\n        const sub = new Logger(name, this, this.customLogFn ? this.logFn : undefined);\r\n\r\n        // add sub-logger to sub-loggers array\r\n        this.subLoggers.push(sub);\r\n\r\n        return sub;\r\n    }\r\n\r\n    public publishLevel(level?: Glue42Core.LogLevel): Glue42Core.LogLevel | undefined {\r\n        if (level) {\r\n            this._publishLevel = level;\r\n        }\r\n\r\n        return this._publishLevel || this.parent?.publishLevel();\r\n    }\r\n\r\n    public consoleLevel(level?: Glue42Core.LogLevel): Glue42Core.LogLevel | undefined {\r\n        if (level) {\r\n            this._consoleLevel = level;\r\n        }\r\n\r\n        return this._consoleLevel || this.parent?.consoleLevel();\r\n    }\r\n\r\n    public log(message: string, level?: Glue42Core.LogLevel, error?: Error) {\r\n        this.publishMessage(level || \"info\", message, error);\r\n    }\r\n\r\n    public trace(message: string) {\r\n        this.log(message, \"trace\");\r\n    }\r\n\r\n    public debug(message: string) {\r\n        this.log(message, \"debug\");\r\n    }\r\n\r\n    public info(message: string) {\r\n        this.log(message, \"info\");\r\n    }\r\n\r\n    public warn(message: string) {\r\n        this.log(message, \"warn\");\r\n    }\r\n\r\n    public error(message: string, err?: Error) {\r\n        this.log(message, \"error\");\r\n    }\r\n\r\n    public canPublish(level: Glue42Core.LogLevel, compareWith?: Glue42Core.LogLevel) {\r\n        const levelIdx = order.indexOf(level);\r\n        const restrictionIdx = order.indexOf(compareWith || this.consoleLevel() || \"trace\");\r\n\r\n        return levelIdx >= restrictionIdx;\r\n    }\r\n\r\n    private publishMessage(level: Glue42Core.LogLevel, message: string, error?: Error) {\r\n        // Retrieve logger name and levels\r\n        const loggerName = this.loggerFullName;\r\n\r\n        // Add stack trace if the message is an error\r\n        if (level === \"error\" && !error) {\r\n            const e = new Error();\r\n            if (e.stack) {\r\n                message =\r\n                    message +\r\n                    \"\\n\" +\r\n                    e.stack\r\n                        .split(\"\\n\")\r\n                        .slice(3)\r\n                        .join(\"\\n\");\r\n            }\r\n        }\r\n\r\n        if (this.canPublish(level, this.publishLevel())) {\r\n            const interop = Logger.Interop;\r\n            if (interop) {\r\n                try {\r\n                    if (interop.methods({ name: Logger.InteropMethodName }).length > 0) {\r\n                        interop.invoke(Logger.InteropMethodName, {\r\n                            msg: `${message}`,\r\n                            logger: loggerName,\r\n                            level\r\n                        });\r\n                    }\r\n                } catch {\r\n                    // interop might not be ready yet\r\n                }\r\n            }\r\n        }\r\n\r\n        // Publish in console\r\n        if (this.canPublish(level)) {\r\n            let prefix = \"\";\r\n            if (this.includeTimeAndLevel) {\r\n                const date = new Date();\r\n                const time = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}:${date.getMilliseconds()}`;\r\n                prefix = `[${time}] [${level}] `;\r\n            }\r\n            const toPrint = `${prefix}${loggerName}: ${message}`;\r\n            switch (level) {\r\n                case \"trace\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.debug(toPrint);\r\n                    break;\r\n                case \"debug\":\r\n                    // tslint:disable-next-line:no-console\r\n                    if (this.logFn.debug) {\r\n                        // tslint:disable-next-line:no-console\r\n                        this.logFn.debug(toPrint);\r\n                    } else {\r\n                        // tslint:disable-next-line:no-console\r\n                        this.logFn.log(toPrint);\r\n                    }\r\n                    break;\r\n                case \"info\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.info(toPrint);\r\n                    break;\r\n                case \"warn\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.warn(toPrint);\r\n                    break;\r\n                case \"error\":\r\n                    // tslint:disable-next-line:no-console\r\n                    this.logFn.error(toPrint, error);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","export const GW_MESSAGE_CREATE_CONTEXT = \"create-context\";\r\nexport const GW_MESSAGE_ACTIVITY_CREATED = \"created\";\r\nexport const GW_MESSAGE_ACTIVITY_DESTROYED = \"destroyed\";\r\nexport const GW_MESSAGE_CONTEXT_CREATED = \"context-created\";\r\nexport const GW_MESSAGE_CONTEXT_ADDED = \"context-added\";\r\n\r\nexport const GW_MESSAGE_SUBSCRIBE_CONTEXT = \"subscribe-context\";\r\nexport const GW_MESSAGE_SUBSCRIBED_CONTEXT = \"subscribed-context\";\r\nexport const GW_MESSAGE_UNSUBSCRIBE_CONTEXT = \"unsubscribe-context\";\r\n\r\nexport const GW_MESSAGE_DESTROY_CONTEXT = \"destroy-context\";\r\nexport const GW_MESSAGE_CONTEXT_DESTROYED = \"context-destroyed\";\r\n\r\nexport const GW_MESSAGE_UPDATE_CONTEXT = \"update-context\";\r\nexport const GW_MESSAGE_CONTEXT_UPDATED = \"context-updated\";\r\nexport const GW_MESSAGE_JOINED_ACTIVITY = \"joined\";\r\n","import { Glue42Core} from \"../../glue\";\r\n\r\nimport * as msg from \"./bridges/gw3/messages\";\r\n\r\nexport const ContextMessageReplaySpec: Glue42Core.Connection.MessageReplaySpec = {\r\n    get name(): string {\r\n        return \"context\";\r\n    },\r\n\r\n    get types(): string[] {\r\n        return [\r\n            msg.GW_MESSAGE_CREATE_CONTEXT,\r\n            msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            msg.GW_MESSAGE_CONTEXT_CREATED,\r\n            msg.GW_MESSAGE_CONTEXT_ADDED,\r\n            msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n            msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n            msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n            msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n            msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            msg.GW_MESSAGE_JOINED_ACTIVITY\r\n        ];\r\n    }\r\n};\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { ContextSubscriptionKey } from \"../types\";\r\n\r\nexport class GW3ContextData {\r\n    // invariants:\r\n    // - at least one of { isAnnounced, hasCallbacks() } must be truthy\r\n    //     (so no state (0) instances are kept)\r\n    // - name is defined\r\n    // - isAnnounced cannot go from true to false\r\n    // - !isAnnounced => activityId === undefined\r\n    // - !isAnnounced => contextId === undefined\r\n    // - isAnnounced => contextId !== undefined\r\n    // - !isAnnounced => context == {}\r\n    // - !isAnnounced => !joinedActivity\r\n    // - activityId === undefined => !joinedActivity\r\n    // - joinedActivity => activityId !== undefined !\r\n    // - activityId != undefined => name === activityId\r\n    // - !isAnnounced => sentExplicitSubscription === false\r\n    // - !hasCallbacks => sentExplicitSubscription === false\r\n    // - context is defaulted to {}, not null or undefined\r\n\r\n    // the name of this context; it's what our clients use to (un)subscribe\r\n    // to it; for an activity context it's the same as activityId\r\n    public name: string;\r\n\r\n    // the id of the context as assigned by the GW; only known after it has\r\n    // been announced\r\n    public contextId: string | undefined;\r\n\r\n    // since GW3 only sends a snapshot on subscription/activity creation,\r\n    // we need to keep track of the context state ourselves, for the sake\r\n    // of any additional subsequent subscribers (i.e. so we can give them\r\n    // the context snapshot so far)\r\n    public context: {};\r\n\r\n    // has the context been announced by the GW?\r\n    public isAnnounced: boolean;\r\n\r\n    public joinedActivity: boolean | undefined;\r\n\r\n    // callbacks to invoke on context update\r\n    public updateCallbacks: { [index: number]: (data: any, delta: any, removed: string[], key: ContextSubscriptionKey, extraData?: any) => void } = {};\r\n\r\n    // iff activity context, the id of the activity to which it belongs\r\n    public activityId: string | undefined;\r\n\r\n    public sentExplicitSubscription: boolean | undefined;\r\n\r\n    public hasReceivedSnapshot: boolean | undefined;\r\n\r\n    constructor(contextId: string | undefined, name: string, isAnnounced: boolean, activityId?: string) {\r\n        this.contextId = contextId;\r\n        this.name = name;\r\n        this.isAnnounced = isAnnounced;\r\n        this.activityId = activityId;\r\n        this.context = {};\r\n    }\r\n\r\n    public hasCallbacks() {\r\n        return Object.keys(this.updateCallbacks).length > 0;\r\n    }\r\n\r\n    // for reference only\r\n    // should never return 0\r\n    public getState(): number {\r\n        if (this.isAnnounced && this.hasCallbacks()) {\r\n            return 3;\r\n        }\r\n\r\n        if (this.isAnnounced) {\r\n            return 2;\r\n        }\r\n\r\n        if (this.hasCallbacks()) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { ContextDelta } from \"./bridges/types\";\r\nimport { Logger } from \"../logger/logger\";\r\n\r\nexport function applyContextDelta(\r\n    context: any,\r\n    delta: ContextDelta,\r\n    logger: Logger) {\r\n\r\n    try {\r\n        if (logger?.canPublish(\"trace\")) {\r\n            logger?.trace(`applying context delta ${JSON.stringify(delta)} on context ${JSON.stringify(context)}`);\r\n        }\r\n        if (!delta) {\r\n            return context;\r\n        }\r\n\r\n        if (delta.reset) {\r\n            context = { ...delta.reset };\r\n            return context;\r\n        }\r\n\r\n        context = deepClone(context, undefined);\r\n\r\n        if (delta.commands) {\r\n            for (const command of delta.commands) {\r\n                if (command.type === \"remove\") {\r\n                    deletePath(context, command.path);\r\n                } else if (command.type === \"set\") {\r\n                    setValueToPath(context, command.value, command.path);\r\n                }\r\n            }\r\n            // if there is a commands property ignore the rest (v1 added/updated/removed)\r\n            return context;\r\n        }\r\n\r\n        const added = delta.added;\r\n        const updated = delta.updated;\r\n        const removed = delta.removed;\r\n\r\n        if (added) {\r\n            Object.keys(added).forEach((key) => {\r\n                context[key] = added[key];\r\n            });\r\n        }\r\n\r\n        if (updated) {\r\n            Object.keys(updated).forEach((key) => {\r\n                mergeObjectsProperties(key, context, updated);\r\n            });\r\n        }\r\n\r\n        if (removed) {\r\n            removed.forEach((key) => {\r\n                delete context[key];\r\n            });\r\n        }\r\n\r\n        return context;\r\n    } catch (e) {\r\n        logger?.error(`error applying context delta ${JSON.stringify(delta)} on context ${JSON.stringify(context)}`, e);\r\n        return context;\r\n    }\r\n}\r\n\r\n// https://stackoverflow.com/a/40294058/1527706\r\nexport function deepClone(obj: any, hash?: WeakMap<any, any>): any {\r\n    hash = hash || new WeakMap<any, any>();\r\n    if (Object(obj) !== obj) { return obj; } // primitives\r\n    if (obj instanceof Set) { return new Set(obj); } // See note about this!\r\n    if (hash.has(obj)) { return hash.get(obj); } // cyclic reference\r\n    const result = obj instanceof Date ? new Date(obj)\r\n        : obj instanceof RegExp ? new RegExp(obj.source, obj.flags)\r\n            : obj.constructor ? new obj.constructor()\r\n                : Object.create(null);\r\n    hash.set(obj, result);\r\n    if (obj instanceof Map) {\r\n        Array.from(obj, ([key, val]) => result.set(key, deepClone(val, hash)));\r\n    }\r\n    return Object.assign(result, ...Object.keys(obj).map(\r\n        (key) => ({ [key]: deepClone(obj[key], hash) })));\r\n}\r\n\r\n/*\r\nmergeObjectsProperties(\r\n    \"a\",\r\n    { a: { b: { c: 1, e: 1 }, x: { y: 1 }, foo: { moo: \"bar\" } } },\r\n    { a: { b: { d: 1, e: 2 }, foo: \"bar\" } });\r\n\r\n    => { a: { b: { c: 1, e: 2 } }, x: { y: 1 }, foo: \"bar\" }\r\n*/\r\n\r\nconst mergeObjectsProperties = (key: string, what: any, withWhat: any) => {\r\n\r\n    const right = withWhat[key];\r\n\r\n    if (right === undefined) {\r\n        return what;\r\n    }\r\n\r\n    const left = what[key];\r\n\r\n    if (!left || !right) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n\r\n    if (typeof left === \"string\" ||\r\n        typeof left === \"number\" ||\r\n        typeof left === \"boolean\" ||\r\n        typeof right === \"string\" ||\r\n        typeof right === \"number\" ||\r\n        typeof right === \"boolean\" ||\r\n        Array.isArray(left) ||\r\n        Array.isArray(right)) {\r\n        what[key] = right;\r\n        return what;\r\n    }\r\n\r\n    what[key] = Object.assign({}, left, right);\r\n\r\n    return what;\r\n};\r\n\r\n// https://stackoverflow.com/a/6713782/1527706\r\nexport function deepEqual(x: any, y: any) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    // if both x and y are null or undefined and exactly the same\r\n\r\n    if (!(x instanceof Object) || !(y instanceof Object)) {\r\n        return false;\r\n    }\r\n    // if they are not strictly equal, they both need to be Objects\r\n\r\n    if (x.constructor !== y.constructor) {\r\n        return false;\r\n    }\r\n    // they must have the exact same prototype chain, the closest we can do is\r\n    // test there constructor.\r\n\r\n    for (const p in x) {\r\n        if (!x.hasOwnProperty(p)) {\r\n            continue;\r\n        }\r\n        // other properties were tested using x.constructor === y.constructor\r\n\r\n        if (!y.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        // allows to compare x[ p ] and y[ p ] when set to undefined\r\n\r\n        if (x[p] === y[p]) {\r\n            continue;\r\n        }\r\n        // if they have the same strict value or identity then they are equal\r\n\r\n        if (typeof (x[p]) !== \"object\") {\r\n            return false;\r\n        }\r\n        // Numbers, Strings, Functions, Booleans must be strictly equal\r\n\r\n        if (!deepEqual(x[p], y[p])) {\r\n            return false;\r\n        }\r\n        // Objects and Arrays must be tested recursively\r\n    }\r\n\r\n    for (const p in y) {\r\n        if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {\r\n            return false;\r\n        }\r\n        // allows x[ p ] to be set to undefined\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function setValueToPath(obj: any, value: any, path: string) {\r\n    const pathArr = path.split(\".\");\r\n    let i;\r\n    for (i = 0; i < pathArr.length - 1; i++) {\r\n        if (!obj[pathArr[i]]) {\r\n            // path does not exist, create empty object\r\n            obj[pathArr[i]] = {};\r\n        }\r\n        if (typeof obj[pathArr[i]] !== \"object\") {\r\n            // handle the case where we have {a: 1} and we call set({a: {aa: 2}})\r\n            obj[pathArr[i]] = {};\r\n        }\r\n        obj = obj[pathArr[i]];\r\n    }\r\n    obj[pathArr[i]] = value;\r\n}\r\n\r\nexport function isSubset(superObj: any, subObj: any): boolean {\r\n    return Object.keys(subObj).every((ele) => {\r\n        if (typeof subObj[ele] === \"object\") {\r\n            return isSubset(superObj?.[ele] || {}, subObj[ele] || {});\r\n        }\r\n        return subObj[ele] === superObj?.[ele];\r\n    });\r\n}\r\n\r\nfunction deletePath(obj: any, path: string) {\r\n    const pathArr = path.split(\".\");\r\n    let i;\r\n    for (i = 0; i < pathArr.length - 1; i++) {\r\n        if (!obj[pathArr[i]]) {\r\n            // path does not exist, we're not removing anything\r\n            return;\r\n        }\r\n        obj = obj[pathArr[i]];\r\n    }\r\n    delete obj[pathArr[i]];\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { ContextBridge } from \"../../contextBridge\";\r\nimport { GW3ContextData as ContextData } from \"./contextData\";\r\nimport { applyContextDelta, deepEqual, deepClone, setValueToPath } from \"../../helpers\";\r\nimport * as msg from \"./messages\";\r\nimport { ContextMessage } from \"./contextMessage\";\r\nimport { ContextMessageReplaySpec } from \"../../contextMessageReplaySpec\";\r\nimport { Logger } from \"../../../logger/logger\";\r\nimport Connection from \"../../../connection/connection\";\r\nimport { ContextsConfig } from \"../../contextsModule\";\r\nimport { ContextName, ContextSubscriptionKey, ContextDelta, ContextDeltaCommand } from \"../types\";\r\n\r\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n// GW3Bridge implementation notes\r\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n//\r\n// ===========================\r\n// Terminology used\r\n// ===========================\r\n//\r\n// - gw-subscribe (verb):\r\n//      send SUBSCRIBE CONTEXT to GW se we see CONTEXT UPDATED messages,\r\n//      or\r\n//      get implicitly subscribed as consequence of joining activity\r\n//      sending the SUBSCRIBE CONTEXT message is done internally by this\r\n//      class whenever a ContextData item in _contextNameToData reaches\r\n//      state (3) (see 'States of a context' in gw3ContextData.ts)\r\n// - bridge-subscribe (verb):\r\n//      call gw3Bridge.subscribe method; we need to make sure we've\r\n//      gw-subscribed if/as soon as the target context is announced\r\n//      this is what consumers of this class do\r\n// - bridge-subscription (noun):\r\n//      the result of bridge-subscribe, and the state of having a handler\r\n//      subscribed to a context\r\n// - active subscription: bridge-subscription which will cause the handler\r\n//      to observe context changes until someone calls unsubscribe() here\r\n//      or the subscription becomes 'inactive'\r\n// - inactive subscription: bridge-subscription which will NOT cause the\r\n//      handler to observe context changes; this happens to\r\n//      bridge-subscriptions on activity contexts if we leave the activity.\r\n//      There is NO way to check if a subscription is active or not and it's\r\n//      not reflected in the contextData state.\r\n//\r\n// ===========================\r\n// General information\r\n// ===========================\r\n//\r\n// This class exposes the GW context subscription and updating features\r\n// using the subscribe/unsubscribe/update/createContext methods.\r\n//\r\n// The main logic is related to tracking the states of contexts (shared or\r\n// activity), represented by ContextData entries in _contextNameToData, and\r\n// reacting to gateway messages accordingly.\r\n//\r\n// ===========================\r\n// States of an ContextData object\r\n// ===========================\r\n//\r\n// (0) nothing (not defined, or deleted) - such entries are NOT kept in collections\r\n// (1) unknown but bridge-subscribed to\r\n// (2) announced but not bridge-subscribed to\r\n// (3) both announced and bridge-subscribed to (so also gw-subscribed)\r\n//\r\n//       sub/unsub   GW ann\r\n//      +-------->(1)-----+\r\n//      |                 |\r\n//      |                 |\r\n//      V       destroy   v\r\n// *-->(0)<--------------(3)\r\n//      |^---------+      ^\r\n//      |  destroy |      |\r\n//      |          |      |\r\n//      +-------->(2)<----+\r\n//        GW ann    subscribe/unsub\r\n//\r\n// You can look for the states and transitions in the code below, e.g.\r\n// (0) -> (1)\r\n//\r\n// Note: if it's not our activity context, we need to gw-(un)subscribe to the\r\n// GW update messages on certain transitions:\r\n// - on changes from { (1), (2) } -> (3) we send a subscribe message\r\n// - on changes from (3) -> (2) we send an unsubscribe message\r\n// - on destruction, we drop all the information about the context; let\r\n// anyone subscribe to it and create a new contextData in state (1), we don't\r\n// care - these subscriptions are inactive from the get go, since the context\r\n// can't be created again.\r\n//\r\n// The contextData also contains the current snapshot of the context if it's\r\n// currently gw-subscribed to (so states (2\"') and (3) below).\r\n//\r\n// Note: We're mostly going to the trouble of keeping unannounced contexts\r\n// (state (1)) in order to allow other GW message subscribers to see a new\r\n// context being created and subscribe to it before the message has reached\r\n// our handler. Also, only sending a CONTEXT SUBSCRIBE on state (3) instead\r\n// of on GW announce means no unnecessary updates are being distributed to\r\n// every instance of this library.\r\n//\r\n// Also, in the HC subscribing to an unknown context is OK as well so we're\r\n// keeping this behavior.\r\n//\r\n// Note: above is an abridged version of the state machine; states (2) and (3)\r\n// have three substates depending on whether the context is a global context,\r\n// our own activity context, or a foreign activity's context. Subscription\r\n// messages are only sent on { (1), (2'), (2\") } -> { (3'), (3\") }, with the\r\n// unsubscribe message sent on { (3'), (3\"), (3\"') } -> { (1), (2'), (2\") }\r\n// if a  subscribe was sent previously (so we'll send a final unsubscribe if\r\n// we subscribe to a foreign activity's context, then join the activity, then\r\n// unsubscribe - this is to avoid still potentially receiving unwanted updates\r\n// if we leave the activity).\r\n//\r\n// Full state diagram (not showing 'destroy' transitions):\r\n//\r\n//        join activity\r\n//      +------------------>(3\"')<------+\r\n//      |                    ^          |\r\n//      |                    | join     |\r\n//      |                    | activity |\r\n//      | activity created   |          |\r\n//      +------------------>(3\")<----+  |\r\n//      |                            |  |\r\n//      | global ctx ann             |  |\r\n//      +------------------>(3')<-+  |  |\r\n//      |                         |  |  |\r\n//      |                         |  |  |\r\n//     (1)                        |  |  |\r\n//      ^                         |  |  |\r\n//      | bridge-(un)subscribe   bridge-(un)subscribe\r\n//      |                         |  |  |\r\n//      V                         |  |  |\r\n// *-->(0)                        |  |  |\r\n//      |                         |  |  |\r\n//      | global ctx ann          |  |  |\r\n//      +------------------>(2')<-+  |  |\r\n//      |                            |  |\r\n//      | activity created           |  |\r\n//      +------------------>(2\")<----+  |\r\n//      |                    |          |\r\n//      |                    | join     |\r\n//      |                    | activity |\r\n//      | join activity      V          |\r\n//      +------------------>(2\"')<------+\r\n//\r\n// ===========================\r\n// Supported use cases\r\n// ===========================\r\n//\r\n// - bridge-(un)subscribe to shared context by name\r\n// - bridge-(un)subscribe to activity context for activity we ARE a member of\r\n//      - the context name is the activity id\r\n//      - here the subscriptions become inactive if we leave the activity\r\n//      - HOWEVER these subscriptions will become inactive if we leave the\r\n//      activity, and any further subscriptions to the activity's context\r\n//      will be inactive.\r\n//          The protocol provides no way for us to know other than through\r\n//      the LEAVE ACTIVITY success message which is sent by our peer and we\r\n//      can't observe it here, so we have no way to know to send an explicit\r\n//      subscription in order to reactivate the bridge-subscription.\r\n//          We could deal with this by extending the GW connection to allow\r\n//      us to inspect outgoing messages and react to the LEAVE ACTIVITY, but\r\n//      keeping a few stale objects around isn't worth the code complexity.\r\n//          This transition would be represented by (2\"') -> (2\") and\r\n//      (3\"') -> (3\") in the state diagram, where (3\"') -> (3\") would prompt\r\n//      a subscribe message.\r\n// - bridge-(un)subscribe to context of activity we're NOT in\r\n//      - the context name is the activity id\r\n//      - the subscription will stay active even if we join the activity later\r\n//      - again, these subscriptions will become inactive if we leave the\r\n//      activity\r\n//\r\n// Also note that unsubscribing from destroyed contexts is not required,\r\n// as the data is cleared up automatically (but it doesn't hurt).\r\n// Unsubscriptions are guaranteed to be safe and idempotent.\r\nexport class GW3Bridge implements ContextBridge {\r\n    private _logger: Logger;\r\n    private _connection: Connection;\r\n    // used for sending messages as it provides a promise-based interface\r\n    private _gw3Session: Glue42Core.Connection.GW3DomainSession;\r\n\r\n    // contexts in state { (1), (2), (3) }\r\n    private _contextNameToData: { [contextName: string]: ContextData } = {};\r\n\r\n    // for disposing purposes only\r\n    private _gw3Subscriptions: any[] = [];\r\n\r\n    // increment for every bridge-subscribe; used to unsubscribe()\r\n    private _nextCallbackSubscriptionNumber = 0;\r\n\r\n    // mapping announced contexts' name <-> id\r\n    private _contextNameToId: { [contextName: string]: string } = {};\r\n    private _contextIdToName: { [contextId: string]: string } = {};\r\n    private _protocolVersion?: number = undefined;\r\n    private get protocolVersion(): number {\r\n        if (!this._protocolVersion) {\r\n            const contextsDomainInfo = this._connection.availableDomains.find((d) => d.uri === \"context\");\r\n            this._protocolVersion = contextsDomainInfo?.version ?? 1;\r\n        }\r\n        return this._protocolVersion;\r\n    }\r\n\r\n    public get setPathSupported() {\r\n        return this.protocolVersion >= 2;\r\n    }\r\n\r\n    public constructor(config: ContextsConfig) {\r\n        this._connection = config.connection;\r\n        this._logger = config.logger;\r\n        this._gw3Session = this._connection.domain(\r\n            \"global\",\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_CREATED,\r\n                msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n                msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n                msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n            ]);\r\n\r\n        // TODO: logging, validation and error handling\r\n\r\n        this.subscribeToContextCreatedMessages();\r\n\r\n        this.subscribeToContextUpdatedMessages();\r\n\r\n        this.subscribeToContextDestroyedMessages();\r\n\r\n        this._connection.replayer?.drain(\r\n            ContextMessageReplaySpec.name,\r\n            (message) => {\r\n                const type = (message as any).type;\r\n                if (!type) {\r\n                    return;\r\n                }\r\n\r\n                if (type === msg.GW_MESSAGE_CONTEXT_CREATED ||\r\n                    type === msg.GW_MESSAGE_CONTEXT_ADDED ||\r\n                    type === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n                    this.handleContextCreatedMessage(message as ContextMessage);\r\n                } else if (type === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT ||\r\n                    type === msg.GW_MESSAGE_CONTEXT_UPDATED ||\r\n                    type === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n                    this.handleContextUpdatedMessage(message as ContextMessage);\r\n                } else if (type === msg.GW_MESSAGE_CONTEXT_DESTROYED ||\r\n                    type === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n                    this.handleContextDestroyedMessage(message as ContextMessage);\r\n                }\r\n            });\r\n    }\r\n\r\n    public dispose(): void {\r\n        for (const sub of this._gw3Subscriptions) {\r\n            this._connection.off(sub);\r\n        }\r\n        this._gw3Subscriptions.length = 0;\r\n        for (const contextName in this._contextNameToData) {\r\n            if (this._contextNameToId.hasOwnProperty(contextName)) {\r\n                delete this._contextNameToData[contextName];\r\n            }\r\n        }\r\n    }\r\n\r\n    public createContext(name: ContextName, data: any): Promise<string> {\r\n        return this._gw3Session\r\n            .send<ContextMessage>({\r\n                type: msg.GW_MESSAGE_CREATE_CONTEXT,\r\n                domain: \"global\",\r\n                name,\r\n                data,\r\n                lifetime: \"retained\",\r\n            })\r\n            .then((createContextMsg: ContextMessage) => {\r\n                this._contextNameToId[name] = createContextMsg.context_id;\r\n                this._contextIdToName[createContextMsg.context_id] = name;\r\n                const contextData = this._contextNameToData[name] || new ContextData(createContextMsg.context_id, name, true, undefined);\r\n                contextData.isAnnounced = true;\r\n                contextData.name = name;\r\n                contextData.contextId = createContextMsg.context_id;\r\n                contextData.context = createContextMsg.data || data;\r\n                contextData.hasReceivedSnapshot = true;\r\n                this._contextNameToData[name] = contextData;\r\n                return createContextMsg.context_id;\r\n            });\r\n    }\r\n\r\n    public all(): ContextName[] {\r\n        return Object.keys(this._contextNameToData)\r\n            .filter((name) => this._contextNameToData[name].isAnnounced);\r\n    }\r\n\r\n    public async update(name: ContextName, delta: any): Promise<void> {\r\n\r\n        // - send context update message\r\n        //\r\n        // - on success, apply delta to context currently in contextData\r\n\r\n        // should we implicitly create the context?\r\n\r\n        const contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, delta) as any as Promise<void>;\r\n        }\r\n\r\n        // TODO: explain why --> because this\r\n        let currentContext = contextData.context;\r\n        if (!contextData.hasCallbacks()) {\r\n            currentContext = await this.get(contextData.name);\r\n        }\r\n\r\n        const calculatedDelta =\r\n            this.protocolVersion === 2 ?\r\n                this.calculateContextDeltaV2(currentContext, delta) :\r\n                this.calculateContextDeltaV1(currentContext, delta);\r\n\r\n        if (!Object.keys(calculatedDelta.added).length\r\n            && !Object.keys(calculatedDelta.updated).length\r\n            && !calculatedDelta.removed.length\r\n            && !calculatedDelta.commands?.length) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n                delta: calculatedDelta,\r\n            }, {}, { skipPeerId: false })\r\n            .then((gwResponse: any) => {\r\n                this.handleUpdated(contextData, calculatedDelta, {\r\n                    updaterId: gwResponse.peer_id\r\n                });\r\n            });\r\n    }\r\n\r\n    public set(name: ContextName, data: any): Promise<void> {\r\n\r\n        const contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return this.createContext(name, data) as any as Promise<void>;\r\n        }\r\n\r\n        // SBGW_D-194\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n                delta: { reset: data },\r\n            }, {}, { skipPeerId: false })\r\n            .then((gwResponse: any) => {\r\n                this.handleUpdated(contextData, { reset: data, added: {}, removed: [], updated: {} }, { updaterId: gwResponse.peer_id });\r\n            });\r\n    }\r\n\r\n    public setPath(name: ContextName, path: string, value: any): Promise<void> {\r\n        if (!this.setPathSupported) {\r\n            return Promise.reject(\"glue.contexts.setPath operation is not supported, use Glue42 3.10 or later\");\r\n        }\r\n        return this.setPaths(name, [{ path, value }]);\r\n    }\r\n\r\n    public setPaths(name: ContextName, pathValues: Glue42Core.Contexts.PathValue[]): Promise<void> {\r\n        if (!this.setPathSupported) {\r\n            return Promise.reject(\"glue.contexts.setPaths operation is not supported, use Glue42 3.10 or later\");\r\n        }\r\n        const contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            const obj = {};\r\n            for (const pathValue of pathValues) {\r\n                setValueToPath(obj, pathValue.value, pathValue.path);\r\n            }\r\n\r\n            return this.createContext(name, obj) as any as Promise<void>;\r\n        }\r\n\r\n        const commands: ContextDeltaCommand[] = [];\r\n        for (const pathValue of pathValues) {\r\n            if (pathValue.value === null) {\r\n                commands.push({ type: \"remove\", path: pathValue.path });\r\n            } else {\r\n                commands.push({ type: \"set\", path: pathValue.path, value: pathValue.value });\r\n            }\r\n        }\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UPDATE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n                delta: { commands }\r\n            }, {}, { skipPeerId: false })\r\n            .then((gwResponse: any) => {\r\n                this.handleUpdated(contextData, { added: {}, removed: [], updated: {}, commands }, { updaterId: gwResponse.peer_id });\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Return a context's data asynchronously as soon as any becomes available\r\n     */\r\n    public get(name: ContextName): Promise<any> {\r\n\r\n        const contextData = this._contextNameToData[name];\r\n        // Three cases here:\r\n        // 1) The context does not exist and is not announced by the GW -> return {}\r\n        // 2) The context exists but we don't track it -> subscribe and return the object when we get the subscription result from GW\r\n        // 3) The context exists and we're tracking it -> just return the last state we have\r\n\r\n        // 1)\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            return Promise.resolve({});\r\n        }\r\n\r\n        // 2)\r\n        if (contextData && (!contextData.hasCallbacks() || !contextData.hasReceivedSnapshot)) {\r\n            return new Promise<any>(async (resolve, _) => {\r\n                this.subscribe(name, (data: any, _d: any, _r: string[], un: ContextSubscriptionKey) => {\r\n                    this.unsubscribe(un);\r\n                    resolve(data);\r\n                });\r\n            });\r\n        }\r\n\r\n        // 3)\r\n        const context = contextData?.context ?? {};\r\n        return Promise.resolve(context);\r\n    }\r\n\r\n    /**\r\n     * Creates a subscription to a given context which may or may not exist/be\r\n     * announced as of yet.\r\n     *\r\n     * NB: This method publishes an initial snapshot on subscription. Note that\r\n     * at this point the method itself may not have returned and the returned\r\n     * ContextSubscriptionKey is not saved in the return variable; if you want\r\n     * to unsubscribe from within the subscription callback, use the key argument\r\n     * of the callback.\r\n     */\r\n    public subscribe(\r\n        name: ContextName,\r\n        callback: (\r\n            data: any,\r\n            delta: any,\r\n            removed: string[],\r\n            key: ContextSubscriptionKey,\r\n            extraData?: any) => void)\r\n        : Promise<ContextSubscriptionKey> {\r\n\r\n        // - populate contextData's updateCallbacks with new entry\r\n        //\r\n        // - examine contextData and determine if we need to send a subscribe\r\n        //\r\n        // - if the context is announced, ensure handler gets snapshot\r\n\r\n        const thisCallbackSubscriptionNumber = this._nextCallbackSubscriptionNumber;\r\n        this._nextCallbackSubscriptionNumber += 1;\r\n\r\n        let contextData = this._contextNameToData[name];\r\n\r\n        if (!contextData ||\r\n            !contextData.isAnnounced) {\r\n            // (0) -> (1)\r\n            contextData = contextData || new ContextData(undefined, name, false, undefined);\r\n            this._contextNameToData[name] = contextData;\r\n            contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n\r\n            // this will end up in handleContextUpdate which will cause a snapshot to get sent\r\n            // return this.createContext(name, {})\r\n            // \t.then(() => thisCallbackSubscriptionNumber);\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n\r\n        const hadCallbacks = contextData.hasCallbacks();\r\n\r\n        contextData.updateCallbacks[thisCallbackSubscriptionNumber] = callback;\r\n\r\n        if (!hadCallbacks) {\r\n            // first subscriber: (2) -> (3)\r\n\r\n            if (!contextData.joinedActivity) {\r\n\r\n                // if we've created the context ourselves using\r\n                // createContext\r\n                if (contextData.context && contextData.sentExplicitSubscription) {\r\n                    if (contextData.hasReceivedSnapshot) {\r\n                        const clone = deepClone(contextData.context);\r\n                        callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n                    }\r\n                    return Promise.resolve(thisCallbackSubscriptionNumber);\r\n                }\r\n\r\n                // (2') -> (3') or (2\") -> (3\")\r\n                // shared context or not our activity;\r\n                // we need to gw-subscribe\r\n\r\n                // OTOH, no need to explicitly push a snapshot here,\r\n                // the GW will reply with a SUBSCRIBED CONTEXT with a snapshot\r\n                // which we'll push through subscribeToContextUpdatedMessages\r\n                // (not that we have a snapshot right now - it's not our activity,\r\n                // and we haven't subscribed already so we can't have received updates)\r\n\r\n                return this.sendSubscribe(contextData)\r\n                    .then(() => thisCallbackSubscriptionNumber);\r\n            } else {\r\n\r\n                // (2\"') -> (3\"')\r\n                // our activity, which we're tracking anyway\r\n                // no need to gw-subscribe, just push the snapshot to the new subscriber\r\n\r\n                if (contextData.hasReceivedSnapshot) {\r\n                    const clone = deepClone(contextData.context);\r\n                    callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n                }\r\n                return Promise.resolve(thisCallbackSubscriptionNumber);\r\n            }\r\n        } else {\r\n            // not first subscriber; no need to gw-subscribe, just push snapshot\r\n            // (3) -> (3)\r\n\r\n            if (contextData.hasReceivedSnapshot) {\r\n                const clone = deepClone(contextData.context);\r\n                callback(clone, clone, [], thisCallbackSubscriptionNumber);\r\n            }\r\n            return Promise.resolve(thisCallbackSubscriptionNumber);\r\n        }\r\n    }\r\n\r\n    public unsubscribe(subscriptionKey: ContextSubscriptionKey): void {\r\n        for (const name of Object.keys(this._contextNameToData)) {\r\n            const contextId = this._contextNameToId[name];\r\n            const contextData = this._contextNameToData[name];\r\n\r\n            if (!contextData) {\r\n                return;\r\n            }\r\n\r\n            const hadCallbacks = contextData.hasCallbacks();\r\n\r\n            delete contextData.updateCallbacks[subscriptionKey];\r\n\r\n            if (contextData.isAnnounced &&\r\n                hadCallbacks &&\r\n                !contextData.hasCallbacks() &&\r\n                contextData.sentExplicitSubscription) {\r\n                // (3) -> (2)\r\n                this.sendUnsubscribe(contextData);\r\n            }\r\n\r\n            if (!contextData.isAnnounced &&\r\n                // (1) -> (0)\r\n                !contextData.hasCallbacks()) {\r\n                delete this._contextNameToData[name];\r\n            }\r\n        }\r\n    }\r\n\r\n    public destroy(name: string) {\r\n        const contextData = this._contextNameToData[name];\r\n        if (!contextData) {\r\n            return Promise.reject(`context with ${name} does not exist`);\r\n        }\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_DESTROY_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n            }).then((_) => undefined);\r\n    }\r\n\r\n    private handleUpdated(contextData: ContextData, delta: ContextDelta, extraData?: any) {\r\n        // for correctness proof, see note about serialized context\r\n        // updates in subscribeToContextUpdatedMessages\r\n\r\n        const oldContext = contextData.context;\r\n        contextData.context = applyContextDelta(contextData.context, delta, this._logger);\r\n        contextData.hasReceivedSnapshot = true;\r\n\r\n        if (this._contextNameToData[contextData.name] === contextData &&\r\n            !deepEqual(oldContext, contextData.context)) {\r\n            this.invokeUpdateCallbacks(contextData, delta, extraData);\r\n        }\r\n    }\r\n\r\n    private subscribeToContextCreatedMessages() {\r\n\r\n        // when a new context is announced:\r\n        //\r\n        // - record the fact that it's announced, so when the first\r\n        //      bridge-subscribers come in, we do a gw-subscribe\r\n        //\r\n        // - record its name/contextId association\r\n        //\r\n        // - record its activity information, and the fact that this\r\n        //      activity exists and that we're not joined in it (yet?)\r\n        //\r\n        // - if any bridge-subscribers already present, do a gw-subscribe\r\n\r\n        const createdMessageTypes =\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_ADDED,\r\n                msg.GW_MESSAGE_CONTEXT_CREATED,\r\n                msg.GW_MESSAGE_ACTIVITY_CREATED,\r\n            ];\r\n\r\n        for (const createdMessageType of createdMessageTypes) {\r\n            const sub = this._connection.on(\r\n                createdMessageType,\r\n                this.handleContextCreatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    }\r\n\r\n    private handleContextCreatedMessage(contextCreatedMsg: ContextMessage): void {\r\n        const createdMessageType = contextCreatedMsg.type;\r\n        if (createdMessageType === msg.GW_MESSAGE_ACTIVITY_CREATED) {\r\n            // activity context\r\n\r\n            this._contextNameToId[contextCreatedMsg.activity_id] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.activity_id;\r\n        } else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_ADDED) {\r\n            // shared context\r\n\r\n            this._contextNameToId[contextCreatedMsg.name] = contextCreatedMsg.context_id;\r\n            this._contextIdToName[contextCreatedMsg.context_id] = contextCreatedMsg.name;\r\n        } else if (createdMessageType === msg.GW_MESSAGE_CONTEXT_CREATED) {\r\n            // created by us, data already populated\r\n\r\n            // NB: the promise resolution from createContext is supposed to run *before*\r\n            // we see the CONTEXT CREATED here, so _contextIdToName/_contextNameToId\r\n            // are supposed to already be populated (this is because the gw connection\r\n            // success handler is subscribed long before this one)\r\n        }\r\n\r\n        const name = this._contextIdToName[contextCreatedMsg.context_id];\r\n\r\n        if (!name) {\r\n            // we're supposed to have recorded the name\r\n            throw new Error(\"Received created event for context with unknown name: \" + contextCreatedMsg.context_id);\r\n        }\r\n\r\n        if (!this._contextNameToId[name]) {\r\n            // we're also supposed to have recorded it in the opposite direction\r\n            throw new Error(\"Received created event for context with unknown id: \" + contextCreatedMsg.context_id);\r\n        }\r\n\r\n        let contextData = this._contextNameToData[name];\r\n\r\n        if (contextData) {\r\n            if (contextData.isAnnounced) {\r\n                return;\r\n            } else {\r\n                // (1) -> (3') or (1) -> (3\")\r\n\r\n                // someone's already expressed interest in this context and now\r\n                // it's being announced\r\n\r\n                // you might think that since the activity context's id is\r\n                // auto-generated no one could have already context-subscribed, but\r\n                // there might be another ACTIVITY CREATED observer on the same\r\n                // GW connection who saw this message before us and reacted by\r\n                // subscribing to the context - so we need to handle this case\r\n\r\n                if (!contextData.hasCallbacks()) {\r\n                    throw new Error(\"Assertion failure: contextData.hasCallbacks()\");\r\n                }\r\n\r\n                // update its state and send a gw-subscribe; we're expecting an update message\r\n\r\n                contextData.isAnnounced = true;\r\n                contextData.contextId = contextCreatedMsg.context_id;\r\n                contextData.activityId = contextCreatedMsg.activity_id;\r\n\r\n                // if we're observing the ACTIVITY CREATED message,\r\n                // we're not one of its members and we need to gw-subscribe\r\n                // explicitly; of course we could be getting joined to the activity\r\n                // pretty soon which would subscribe us to context updates implicitly\r\n\r\n                // long story short, if we're about to be joined to the activity\r\n                // and an observer to ACTIVITY CREATED subscribes to the activity's context\r\n                // before we get to this point, we'll send a needless SUBSCRIBE CONTEXT\r\n                // but there's no harm done by beating that to the punch, and there's\r\n                // no clean way to avoid this situation so we leave this as an artifact\r\n                // of the implementation\r\n\r\n                // whether activity or not, we'll push the initial snapshot in the\r\n                // subscribeToContextUpdatedMessages handler\r\n\r\n                if (!contextData.sentExplicitSubscription) {\r\n                    this.sendSubscribe(contextData);\r\n                }\r\n            }\r\n        } else {\r\n            // (0) -> (2') or (0) -> (2\")\r\n            // first time we hear about this context\r\n            // we're not subscribed to it in the GW so just create a placeholder\r\n            // and wait for someone to subscribe to it - we'll THEN send a subscribe to the GW\r\n\r\n            this._contextNameToData[name] = contextData =\r\n                new ContextData(contextCreatedMsg.context_id, name, true, contextCreatedMsg.activity_id);\r\n        }\r\n    }\r\n\r\n    private subscribeToContextUpdatedMessages() {\r\n\r\n        // receiving a context update or snapshot\r\n        //\r\n        // if it's JOINED ACTIVITY, we may be a new peer as part of activity\r\n        // creation, so it's the first time we've heard about it -\r\n        // record the activity information in the contextData\r\n        //\r\n        // otherwise, this message is a response/consequence of our gw-subscribe\r\n        // message sent on entering state (3)\r\n        //\r\n        // in any case, apply any deltas to the contextData.context, and\r\n        // propagate the context data and delta to any bridge-subscription\r\n        // handlers\r\n        //\r\n        // note that context updates are always performed when reacting to\r\n        // a GW message, so the data over time is tied to the flow of\r\n        // messages coming in through the gateway connection; the GW decides\r\n        // which update comes before which and our view of the changes to\r\n        // the context is consistent with it (i.e. the GW is the serializing\r\n        // agent)\r\n\r\n        const updatedMessageTypes =\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_UPDATED,\r\n                msg.GW_MESSAGE_SUBSCRIBED_CONTEXT,\r\n                msg.GW_MESSAGE_JOINED_ACTIVITY,\r\n            ];\r\n\r\n        for (const updatedMessageType of updatedMessageTypes) {\r\n            const sub = this._connection.on(\r\n                updatedMessageType,\r\n                this.handleContextUpdatedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    }\r\n\r\n    private handleContextUpdatedMessage(contextUpdatedMsg: ContextMessage): void {\r\n        const updatedMessageType = contextUpdatedMsg.type;\r\n        const contextId = contextUpdatedMsg.context_id;\r\n        let contextData = this._contextNameToData[this._contextIdToName[contextId]];\r\n        // this flag is basically used to make sure we raise an update for a new activity\r\n        // even if its initial context is empty\r\n        // see \"long analysis for callback behavior in GW3: several cases\" comment in\r\n        // activityMyApi.ts in js-activity, case 1-1-1\r\n        // it serves a similar purpose for gw_message_subscribed_context\r\n        const justSeen = !contextData || !contextData.isAnnounced;\r\n\r\n        if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            if (!contextData) {\r\n                // (0) -> (2\"')\r\n\r\n                // we're in the middle of activity creation\r\n                contextData = new ContextData(contextId, contextUpdatedMsg.activity_id, true, contextUpdatedMsg.activity_id);\r\n                this._contextNameToData[contextUpdatedMsg.activity_id] = contextData;\r\n                this._contextIdToName[contextId] = contextUpdatedMsg.activity_id;\r\n                this._contextNameToId[contextUpdatedMsg.activity_id] = contextId;\r\n            } else {\r\n                // (1) -> (3\"'), (2\") -> (2\"') or (3\") -> (3\"')\r\n\r\n                contextData.contextId = contextId;\r\n                contextData.isAnnounced = true;\r\n                contextData.activityId = contextUpdatedMsg.activity_id;\r\n            }\r\n            contextData.joinedActivity = true;\r\n        } else {\r\n            if (!contextData || !contextData.isAnnounced) {\r\n                if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n                    // we've tried to create a context that already exists\r\n                    contextData = contextData || new ContextData(contextId, contextUpdatedMsg.name, true, undefined);\r\n                    contextData.sentExplicitSubscription = true;\r\n                    this._contextNameToData[contextUpdatedMsg.name] = contextData;\r\n                    this._contextIdToName[contextId] = contextUpdatedMsg.name;\r\n                    this._contextNameToId[contextUpdatedMsg.name] = contextId;\r\n                } else {\r\n                    this._logger.error(`Received 'update' for unknown context: ${contextId}`);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        const oldContext = contextData.context;\r\n\r\n        contextData.hasReceivedSnapshot = true;\r\n        if (updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            contextData.context = contextUpdatedMsg.data || {};\r\n        } else if (updatedMessageType === msg.GW_MESSAGE_JOINED_ACTIVITY) {\r\n            contextData.context = contextUpdatedMsg.context_snapshot || {};\r\n        } else if (updatedMessageType === msg.GW_MESSAGE_CONTEXT_UPDATED) {\r\n            contextData.context = applyContextDelta(\r\n                contextData.context,\r\n                contextUpdatedMsg.delta as ContextDelta,\r\n                this._logger);\r\n        } else {\r\n            throw new Error(\"Unrecognized context update message \" + updatedMessageType);\r\n        }\r\n\r\n        if (justSeen ||\r\n            !deepEqual(contextData.context, oldContext) ||\r\n            updatedMessageType === msg.GW_MESSAGE_SUBSCRIBED_CONTEXT) {\r\n            this.invokeUpdateCallbacks(contextData, contextUpdatedMsg.delta, { updaterId: contextUpdatedMsg.updater_id });\r\n        }\r\n    }\r\n\r\n    private invokeUpdateCallbacks(contextData: ContextData, delta?: ContextDelta, extraData?: any) {\r\n        delta = delta || { added: {}, updated: {}, reset: {}, removed: [] };\r\n        if (delta.commands) {\r\n            // clear added, updated, removed, reset\r\n            delta.added = delta.updated = delta.reset = {};\r\n            delta.removed = [];\r\n            for (const command of delta.commands) {\r\n                if (command.type === \"remove\") {\r\n                    // push the removal of top level props only\r\n                    if (command.path.indexOf(\".\") === -1) {\r\n                        delta.removed.push(command.path);\r\n                    }\r\n                    setValueToPath(delta.updated, null, command.path);\r\n                } else if (command.type === \"set\") {\r\n                    setValueToPath(delta.updated, command.value, command.path);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        for (const updateCallbackIndex in contextData.updateCallbacks) {\r\n            if (contextData.updateCallbacks.hasOwnProperty(updateCallbackIndex)) {\r\n                try {\r\n                    const updateCallback = contextData.updateCallbacks[updateCallbackIndex];\r\n                    updateCallback(deepClone(contextData.context), Object.assign({}, delta.added || {}, delta.updated || {}, delta.reset || {}), delta.removed, parseInt(updateCallbackIndex, 10), extraData);\r\n                } catch (err) {\r\n                    this._logger.debug(\"callback error: \" + JSON.stringify(err));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private subscribeToContextDestroyedMessages() {\r\n        // wipe all bookkeeping related to this context\r\n\r\n        const destroyedMessageTypes =\r\n            [\r\n                msg.GW_MESSAGE_CONTEXT_DESTROYED,\r\n                msg.GW_MESSAGE_ACTIVITY_DESTROYED,\r\n            ];\r\n\r\n        for (const destroyedMessageType of destroyedMessageTypes) {\r\n            const sub = this._connection.on(\r\n                destroyedMessageType,\r\n                this.handleContextDestroyedMessage.bind(this));\r\n            this._gw3Subscriptions.push(sub);\r\n        }\r\n    }\r\n\r\n    private handleContextDestroyedMessage(destroyedMsg: ContextMessage): void {\r\n        const destroyedMessageType = destroyedMsg.type;\r\n        let contextId;\r\n        let name;\r\n\r\n        // (?) -> (0)\r\n\r\n        if (destroyedMessageType === msg.GW_MESSAGE_ACTIVITY_DESTROYED) {\r\n            name = destroyedMsg.activity_id;\r\n            contextId = this._contextNameToId[name];\r\n            if (!contextId) {\r\n                this._logger.error(`Received 'destroyed' for unknown activity: ${destroyedMsg.activity_id}`);\r\n                return;\r\n            }\r\n        } else {\r\n            contextId = destroyedMsg.context_id;\r\n            name = this._contextIdToName[contextId];\r\n            if (!name) {\r\n                this._logger.error(`Received 'destroyed' for unknown context: ${destroyedMsg.context_id}`);\r\n                return;\r\n            }\r\n        }\r\n\r\n        delete this._contextIdToName[contextId];\r\n        delete this._contextNameToId[name];\r\n\r\n        const contextData = this._contextNameToData[name];\r\n        delete this._contextNameToData[name];\r\n\r\n        if (!contextData || !contextData.isAnnounced) {\r\n            this._logger.error(`Received 'destroyed' for unknown context: ${contextId}`);\r\n            return;\r\n        }\r\n    }\r\n\r\n    private sendSubscribe(contextData: ContextData): Promise<void> {\r\n        contextData.sentExplicitSubscription = true;\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_SUBSCRIBE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n            }).then((_) => undefined);\r\n    }\r\n\r\n    private sendUnsubscribe(contextData: ContextData): Promise<void> {\r\n        contextData.sentExplicitSubscription = false;\r\n\r\n        return this._gw3Session\r\n            .send({\r\n                type: msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT,\r\n                domain: \"global\",\r\n                context_id: contextData.contextId,\r\n            }).then((_) => undefined);\r\n    }\r\n\r\n    private calculateContextDeltaV1(from: any, to: any): ContextDelta {\r\n        const delta: ContextDelta = { added: {}, updated: {}, removed: [], reset: undefined };\r\n        if (from) {\r\n            for (const x of Object.keys(from)) {\r\n                if (Object.keys(to).indexOf(x) !== -1\r\n                    && to[x] !== null\r\n                    && !deepEqual(from[x], to[x])) {\r\n                    delta.updated[x] = to[x];\r\n                }\r\n            }\r\n        }\r\n        for (const x of Object.keys(to)) {\r\n            if (!from || (Object.keys(from).indexOf(x) === -1)) {\r\n                if (to[x] !== null) {\r\n                    delta.added[x] = to[x];\r\n                }\r\n            } else if (to[x] === null) {\r\n                delta.removed.push(x);\r\n            }\r\n        }\r\n        return delta;\r\n    }\r\n\r\n    private calculateContextDeltaV2(from: any, to: any): ContextDelta {\r\n        const delta: ContextDelta = { added: {}, updated: {}, removed: [], reset: undefined, commands: [] };\r\n\r\n        for (const x of Object.keys(to)) {\r\n            if (to[x] !== null) {\r\n                const fromX = from ? from[x] : null;\r\n                if (!deepEqual(fromX, to[x])) {\r\n                    delta.commands?.push({ type: \"set\", path: x, value: to[x] });\r\n                }\r\n            } else {\r\n                delta.commands?.push({ type: \"remove\", path: x });\r\n            }\r\n        }\r\n\r\n        return delta;\r\n    }\r\n}\r\n","/*\r\n  The AGM Client analyses server presences, collects information about their methods and allows users to invoke these methods.\r\n */\r\nimport promisify from \"../helpers/promisify\";\r\nimport { Protocol, SubscribeError, InteropSettings, SubscriptionInner } from \"../types\";\r\nimport { ClientMethodInfo, ServerInfo, ServerMethodsPair } from \"./types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport ClientRepository from \"./repository\";\r\nimport { UnsubscribeFunction } from \"callback-registry\";\r\nimport random from \"shortid\";\r\nimport { rejectAfter } from \"../helpers/promiseHelpers\";\r\nimport { isSubset } from \"../../contexts/helpers\";\r\nimport InvocationResult = Glue42Core.AGM.InvocationResult;\r\nimport MethodDefinition = Glue42Core.AGM.MethodDefinition;\r\nimport Method = Glue42Core.Interop.Method;\r\n\r\nexport enum InvokeStatus {\r\n    Success = 0,\r\n    Error = 1,\r\n}\r\n\r\nexport interface InvokeResultMessage {\r\n    invocationId: string;\r\n    result?: object;\r\n    instance?: Glue42Core.AGM.Instance;\r\n    status: InvokeStatus;\r\n    message: string;\r\n    error?: Error;\r\n}\r\n\r\nexport default class Client {\r\n    constructor(private protocol: Protocol, private repo: ClientRepository, private instance: Glue42Core.AGM.Instance, private configuration: InteropSettings) {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * Subscribes to an AGM streaming method\r\n     */\r\n    public subscribe(method: string | Glue42Core.AGM.MethodDefinition, options: Glue42Core.AGM.SubscriptionParams, successCallback?: (subscription: Glue42Core.AGM.Subscription) => void, errorCallback?: (err: SubscribeError) => void, existingSub?: SubscriptionInner): Promise<Glue42Core.AGM.Subscription> {\r\n        // options can have arguments:{}, target: 'best'/'all'/{server_instance}, waitTimeoutMs:10000\r\n\r\n        const callProtocolSubscribe = (targetServers: ServerMethodsPair[], stream: Glue42Core.AGM.MethodDefinition, successProxy: (sub: Glue42Core.AGM.Subscription) => void, errorProxy: (err: SubscribeError) => void) => {\r\n\r\n            options.methodResponseTimeout = options.methodResponseTimeout ?? options.waitTimeoutMs;\r\n\r\n            this.protocol.client.subscribe(\r\n                stream,\r\n                options,\r\n                targetServers,\r\n                successProxy,\r\n                errorProxy,\r\n                existingSub\r\n            );\r\n        };\r\n\r\n        const promise = new Promise<Glue42Core.AGM.Subscription>((resolve, reject) => {\r\n\r\n            const successProxy = (sub: Glue42Core.AGM.Subscription) => {\r\n                resolve(sub);\r\n            };\r\n            const errorProxy = (err: SubscribeError) => {\r\n                reject(err);\r\n            };\r\n\r\n            if (!method) {\r\n                reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n                return;\r\n            }\r\n\r\n            let methodDef: Glue42Core.AGM.MethodDefinition;\r\n            if (typeof method === \"string\") {\r\n                methodDef = { name: method };\r\n            } else {\r\n                methodDef = method;\r\n            }\r\n\r\n            if (!methodDef.name) {\r\n                reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n                return;\r\n            }\r\n\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            let target = options.target;\r\n            if (target === undefined) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\") {\r\n                reject(new Error(`\"${target}\" is not a valid target. Valid targets are \"all\", \"best\", or an instance.`));\r\n                return;\r\n            }\r\n\r\n            if (options.methodResponseTimeout === undefined) {\r\n                // legacy support\r\n                options.methodResponseTimeout = (options as any).method_response_timeout;\r\n                if (options.methodResponseTimeout === undefined) {\r\n                    // fallback to default\r\n                    options.methodResponseTimeout = this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n\r\n            if (options.waitTimeoutMs === undefined) {\r\n                // legacy support\r\n                options.waitTimeoutMs = (options as any).wait_for_method_timeout;\r\n                if (options.waitTimeoutMs === undefined) {\r\n                    // fallback to default\r\n                    options.waitTimeoutMs = this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n\r\n            const delayStep = 500;\r\n            let delayTillNow = 0;\r\n\r\n            // don't check if the method is streaming or not, subscribing to non-streaming method has to invoke it\r\n\r\n            // get all servers that have method(s) matching the filter\r\n            let currentServers = this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n            if (currentServers.length > 0) {\r\n                callProtocolSubscribe(currentServers, currentServers[0].methods[0], successProxy, errorProxy);\r\n            } else {\r\n                const retry = () => {\r\n                    if (!target || !(options.waitTimeoutMs)) {\r\n                        return;\r\n                    }\r\n                    delayTillNow += delayStep;\r\n                    // get all servers that have method(s) matching the filter\r\n                    currentServers = this.getServerMethodsByFilterAndTarget(methodDef, target);\r\n                    if (currentServers.length > 0) {\r\n                        const streamInfo = currentServers[0].methods[0];\r\n                        callProtocolSubscribe(currentServers, streamInfo, successProxy, errorProxy);\r\n                    } else if (delayTillNow >= options.waitTimeoutMs) {\r\n                        const def = typeof method === \"string\" ? { name: method } : method;\r\n                        callProtocolSubscribe(currentServers, def, successProxy, errorProxy);\r\n                    } else {\r\n                        setTimeout(retry, delayStep);\r\n                    }\r\n                };\r\n                setTimeout(retry, delayStep);\r\n            }\r\n        });\r\n\r\n        return promisify(promise, successCallback, errorCallback);\r\n    }\r\n\r\n    /**\r\n     * Returns all servers. If methodFilter is specified will return a list of servers\r\n     * having a method matching the filter.\r\n     */\r\n    public servers(methodFilter: Glue42Core.AGM.MethodDefinition): Glue42Core.AGM.Instance[] {\r\n        const filterCopy = methodFilter === undefined\r\n            ? undefined\r\n            : { ...methodFilter };\r\n\r\n        // We want only the announced servers\r\n        return this.getServers(filterCopy).map((serverMethodMap) => {\r\n            return serverMethodMap.server.instance;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns all methods that match the given filter. If no filter specified returns all methods.\r\n     */\r\n    public methods(methodFilter: Glue42Core.AGM.MethodDefinition | string): Glue42Core.AGM.Method[] {\r\n        if (typeof methodFilter === \"string\") {\r\n            methodFilter = { name: methodFilter };\r\n        } else {\r\n            // Must not be mutated\r\n            methodFilter = { ...methodFilter };\r\n        }\r\n\r\n        return this.getMethods(methodFilter);\r\n    }\r\n\r\n    /**\r\n     * Returns all agm method registered by some server\r\n     */\r\n    public methodsForInstance(instance: Glue42Core.AGM.Instance): Glue42Core.AGM.Method[] {\r\n        return this.getMethodsForInstance(instance);\r\n    }\r\n\r\n    /**\r\n     * Called when a method is added for the first time by any application\r\n     */\r\n    public methodAdded(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.repo.onMethodAdded(callback);\r\n    }\r\n\r\n    /**\r\n     * Called when a method is removed from the last application offering it\r\n     * @function methodRemoved\r\n     * @param {MethodCallback} callback\r\n     */\r\n    public methodRemoved(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.repo.onMethodRemoved(callback);\r\n    }\r\n\r\n    /**\r\n     * Called when an application offering methods (server) is discovered\r\n     * @param {InstanceCallback} callback Callback that will be invoked with the {@link Instance} of the new sever\r\n     */\r\n    public serverAdded(callback: (instance: Glue42Core.AGM.Instance) => void): UnsubscribeFunction {\r\n        return this.repo.onServerAdded(callback);\r\n    }\r\n\r\n    /**\r\n     * Called when an app offering methods stops offering them or exits\r\n     * @param {InstanceCallback} callback Callback that will be invoked with the {@link Instance} of the removed server\r\n     */\r\n    public serverRemoved(callback: (instance: Glue42Core.AGM.Instance, reason: string) => void): UnsubscribeFunction {\r\n        return this.repo.onServerRemoved((server: Glue42Core.AGM.Instance, reason: string) => {\r\n            callback(server, reason);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when a method is offered by an application. This will be called for each server offering the method\r\n     * where {@link methodAdded} will be called only for the first time the method is registered.\r\n     *\r\n     * @param {ServerMethodCallback} callback\r\n     */\r\n    public serverMethodAdded(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.Method }) => void): UnsubscribeFunction {\r\n        return this.repo.onServerMethodAdded((server: Glue42Core.AGM.Instance, method: ClientMethodInfo) => {\r\n            callback({ server, method });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when a server stops offering a method\r\n     * @param {ServerMethodCallback} callback\r\n     */\r\n    public serverMethodRemoved(callback: (info: { server: Glue42Core.AGM.Instance, method: Glue42Core.AGM.Method }) => void): UnsubscribeFunction {\r\n        return this.repo.onServerMethodRemoved((server: Glue42Core.AGM.Instance, method: ClientMethodInfo) => {\r\n            callback({ server, method });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invokes an AGM method\r\n     * @param {MethodDefinition} methodFilter Method to invoke\r\n     * @param {Object} argumentObj Arguments for the invocation\r\n     * @param {Instance|Instance[]|string} [target] Defines which server(s) to target with the invocation - can be one of:\r\n     * * best' - executes the method on the best (or first) server\r\n     * * 'all' - executes the method on all servers offering it\r\n     * * AGM instance (or a subset, used for filtering), e.g. { application: 'appName' }\r\n     * * an array of AGM instances/filters\r\n     * @param {InvocationOptions} [additionalOptions] Additional options for the invocation\r\n     * @param {function} [success] - (use this if you prefer callback style instead of promises)\r\n     * Callback that will be called with {@link InvocationResult} object when the invocation is successful\r\n     * @param {function} [error] -  (use this if you prefer callback style instead of promises)\r\n     * Callback that will be called with {@link InvocationError} object when the invocation is not successful\r\n     * @returns {Promise<InvocationResult>}\r\n     * @example\r\n     * const result = await glue.agm.invoke(\"Sum\", { a: 37, b: 5 }); // everything else is optional\r\n     * console.log('37 + 5 = ' + result.returned.answer);\r\n     */\r\n\r\n    public async invoke(methodFilter: string | Glue42Core.AGM.MethodDefinition, argumentObj?: object, target?: Glue42Core.AGM.InstanceTarget, additionalOptions?: Glue42Core.AGM.InvokeOptions, success?: Glue42Core.AGM.InvokeSuccessHandler<any>, error?: Glue42Core.AGM.InvokeErrorHandler)\r\n        : Promise<Glue42Core.AGM.InvocationResult<any>> {\r\n        const getInvokePromise = async () => {\r\n\r\n            let methodDefinition: Glue42Core.AGM.MethodDefinition;\r\n            if (typeof methodFilter === \"string\") {\r\n                methodDefinition = { name: methodFilter };\r\n            } else {\r\n                methodDefinition = { ...methodFilter };\r\n            }\r\n\r\n            if (!methodDefinition.name) {\r\n                return Promise.reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n            }\r\n\r\n            if (!argumentObj) {\r\n                argumentObj = {};\r\n            }\r\n            if (!target) {\r\n                target = \"best\";\r\n            }\r\n            if (typeof target === \"string\" && target !== \"all\" && target !== \"best\" && target !== \"skipMine\") {\r\n                return Promise.reject(new Error(`\"${target}\" is not a valid target. Valid targets are \"all\" and \"best\".`));\r\n            }\r\n            if (!additionalOptions) {\r\n                additionalOptions = {};\r\n            }\r\n\r\n            if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                // legacy support\r\n                additionalOptions.methodResponseTimeoutMs = (additionalOptions as any).method_response_timeout;\r\n                if (additionalOptions.methodResponseTimeoutMs === undefined) {\r\n                    // fallback to default\r\n                    additionalOptions.methodResponseTimeoutMs = this.configuration.methodResponseTimeout;\r\n                }\r\n            }\r\n\r\n            if (additionalOptions.waitTimeoutMs === undefined) {\r\n                // legacy support\r\n                additionalOptions.waitTimeoutMs = (additionalOptions as any).wait_for_method_timeout;\r\n                if (additionalOptions.waitTimeoutMs === undefined) {\r\n                    // fallback to default\r\n                    additionalOptions.waitTimeoutMs = this.configuration.waitTimeoutMs;\r\n                }\r\n            }\r\n\r\n            if (additionalOptions.waitTimeoutMs !== undefined && typeof additionalOptions.waitTimeoutMs !== \"number\") {\r\n                return Promise.reject(new Error(`\"${additionalOptions.waitTimeoutMs}\" is not a valid number for \"waitTimeoutMs\" `));\r\n            }\r\n\r\n            // Check if the arguments are an object\r\n            if (typeof argumentObj !== \"object\") {\r\n                return Promise.reject(new Error(`The method arguments must be an object. method: ${methodDefinition.name}`));\r\n            }\r\n\r\n            let serversMethodMap: ServerMethodsPair[] = this.getServerMethodsByFilterAndTarget(methodDefinition, target);\r\n\r\n            // Try to await them and then continue\r\n            if (serversMethodMap.length === 0) {\r\n                try {\r\n                    // because of the additionalOptions\r\n                    serversMethodMap = await this.tryToAwaitForMethods(methodDefinition, target, additionalOptions);\r\n                } catch (err) {\r\n                    const method: Glue42Core.Interop.Method = {\r\n                        ...methodDefinition,\r\n                        getServers: () => [],\r\n                        supportsStreaming: false,\r\n                        objectTypes: methodDefinition.objectTypes ?? [],\r\n                        flags: methodDefinition.flags?.metadata ?? {}\r\n                    };\r\n                    const errorObj: InvocationResult = {\r\n                        method,\r\n                        called_with: argumentObj,\r\n                        message: `Can not find a method matching ${JSON.stringify(methodFilter)} with server filter ${JSON.stringify(target)}`,\r\n                        executed_by: undefined,\r\n                        returned: undefined,\r\n                        status: undefined,\r\n                    };\r\n\r\n                    return Promise.reject(errorObj);\r\n                }\r\n            }\r\n\r\n            const timeout = additionalOptions.methodResponseTimeoutMs;\r\n            // ts be happy\r\n            const additionalOptionsCopy: Glue42Core.AGM.InvokeOptions = additionalOptions;\r\n            const invokePromises: Array<Promise<InvokeResultMessage>> = serversMethodMap.map(\r\n                (serversMethodPair) => {\r\n                    const invId = random();\r\n                    const method = serversMethodPair.methods[0];\r\n                    const server = serversMethodPair.server;\r\n                    const invokePromise = this.protocol.client.invoke(invId, method, argumentObj, server, additionalOptionsCopy);\r\n\r\n                    return Promise.race([\r\n                        invokePromise,\r\n                        rejectAfter(timeout, invokePromise, {\r\n                            invocationId: invId,\r\n                            message: `Invocation timeout (${timeout} ms) reached for method name: ${method?.name}, target instance: ${JSON.stringify(server.instance)}, options: ${JSON.stringify(additionalOptionsCopy)}`,\r\n                            status: InvokeStatus.Error,\r\n                        })\r\n                    ]);\r\n                }\r\n            );\r\n\r\n            const invocationMessages: InvokeResultMessage[] = await Promise.all(invokePromises);\r\n\r\n            const results = this.getInvocationResultObj(invocationMessages, methodDefinition, argumentObj);\r\n\r\n            const allRejected = invocationMessages.every((result) => result.status === InvokeStatus.Error);\r\n            if (allRejected) {\r\n                return Promise.reject(results);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        // I would call this\r\n        return promisify(getInvokePromise(), success, error);\r\n    }\r\n\r\n    private getInvocationResultObj(invocationResults: InvokeResultMessage[], method: MethodDefinition, calledWith: object): InvocationResult<any> {\r\n        /* tslint:disable:variable-name*/\r\n        const all_return_values = invocationResults\r\n            .filter((invokeMessage) => invokeMessage.status === InvokeStatus.Success)\r\n            .reduce<InvocationResult[]>(\r\n                (allValues, currentValue) => {\r\n                    allValues = [\r\n                        ...allValues,\r\n                        {\r\n                            executed_by: currentValue.instance,\r\n                            returned: currentValue.result,\r\n                            called_with: calledWith,\r\n                            method,\r\n                            message: currentValue.message,\r\n                            status: currentValue.status,\r\n                        }\r\n                    ];\r\n\r\n                    return allValues;\r\n                }, []\r\n            );\r\n\r\n        /* tslint:disable:variable-name*/\r\n        const all_errors = invocationResults\r\n            .filter((invokeMessage) => invokeMessage.status === InvokeStatus.Error)\r\n            .reduce<object[]>((allErrors, currError) => {\r\n                allErrors = [\r\n                    ...allErrors,\r\n                    {\r\n                        executed_by: currError.instance,\r\n                        called_with: calledWith,\r\n                        name: method.name,\r\n                        message: currError.message,\r\n                    }\r\n                ];\r\n\r\n                return allErrors;\r\n            }, []);\r\n\r\n        const invResult = invocationResults[0];\r\n\r\n        const result: InvocationResult = {\r\n            method,\r\n            called_with: calledWith,\r\n            returned: invResult.result,\r\n            executed_by: invResult.instance,\r\n            all_return_values,\r\n            all_errors,\r\n            message: invResult.message,\r\n            status: invResult.status\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Called when the user tries to invoke a method which does not exist\r\n     */\r\n    private tryToAwaitForMethods(methodDefinition: MethodDefinition, target: Glue42Core.AGM.InstanceTarget, additionalOptions: Glue42Core.AGM.InvokeOptions): Promise<ServerMethodsPair[]> {\r\n        return new Promise((resolve, reject) => {\r\n            if (additionalOptions.waitTimeoutMs === 0) {\r\n                reject();\r\n                return;\r\n            }\r\n\r\n            const delayStep = 500;\r\n            let delayTillNow = 0;\r\n\r\n            const retry = () => {\r\n                delayTillNow += delayStep;\r\n\r\n                // get all servers that have method(s) matching the filter\r\n                const serversMethodMap = this.getServerMethodsByFilterAndTarget(methodDefinition, target);\r\n                if (serversMethodMap.length > 0) {\r\n                    clearInterval(interval);\r\n                    resolve(serversMethodMap);\r\n                } else if (delayTillNow >= (additionalOptions.waitTimeoutMs || 10000)) {\r\n                    clearInterval(interval);\r\n                    reject();\r\n                    return;\r\n                }\r\n            };\r\n            const interval = setInterval(retry, delayStep);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Filters an array of servers and returns the ones which match the target criteria\r\n     */\r\n    private filterByTarget(target: Glue42Core.AGM.InstanceTarget, serverMethodMap: ServerMethodsPair[]): ServerMethodsPair[] {\r\n        // If the user specified target as string:\r\n        if (typeof target === \"string\") {\r\n            if (target === \"all\") {\r\n                return [...serverMethodMap];\r\n            } else if (target === \"best\") {\r\n                // Returns first app found\r\n                const localMachine = serverMethodMap\r\n                    .find((s) => s.server.instance.isLocal);\r\n\r\n                if (localMachine) {\r\n                    return [localMachine];\r\n                }\r\n\r\n                if (serverMethodMap[0] !== undefined) {\r\n                    return [serverMethodMap[0]];\r\n                }\r\n            } else if (target === \"skipMine\") {\r\n                return serverMethodMap.filter(({ server }) => server.instance.peerId !== this.instance.peerId);\r\n            }\r\n        } else {\r\n            let targetArray: Glue42Core.AGM.Instance[];\r\n            if (!Array.isArray(target)) {\r\n                targetArray = [target];\r\n            } else {\r\n                targetArray = target;\r\n            }\r\n\r\n            // Retrieve all getServers that match the filters\r\n            const allServersMatching = targetArray.reduce((matches: ServerMethodsPair[], filter) => {\r\n                // Add matches for each filter\r\n                const myMatches = serverMethodMap.filter((serverMethodPair) => {\r\n                    return this.instanceMatch(filter, serverMethodPair.server.instance);\r\n                });\r\n                return matches.concat(myMatches);\r\n            }, []);\r\n\r\n            return allServersMatching;\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Matches a server definition against a server filter\r\n     */\r\n    private instanceMatch(instanceFilter: Glue42Core.AGM.Instance, instanceDefinition: Glue42Core.AGM.Instance): boolean {\r\n        return this.containsProps(instanceFilter, instanceDefinition);\r\n    }\r\n\r\n    /**\r\n     * Matches a method definition against a method filter\r\n     */\r\n    private methodMatch(methodFilter: Glue42Core.AGM.MethodDefinition, methodDefinition: Glue42Core.AGM.MethodDefinition): boolean {\r\n        return this.containsProps(methodFilter, methodDefinition);\r\n    }\r\n\r\n    /**\r\n     * Checks if all properties of filter match properties in object\r\n     */\r\n    private containsProps(filter: any, repoMethod: any): boolean {\r\n        const filterProps = Object.keys(filter)\r\n            .filter((prop) => {\r\n                return filter[prop] !== undefined\r\n                    && typeof filter[prop] !== \"function\"\r\n                    && prop !== \"object_types\"\r\n                    && prop !== \"display_name\"\r\n                    && prop !== \"id\"\r\n                    && prop !== \"gatewayId\"\r\n                    && prop !== \"identifier\"\r\n                    && prop[0] !== \"_\";\r\n            });\r\n\r\n        return filterProps.every((prop) => {\r\n            let isMatch;\r\n\r\n            const filterValue = filter[prop];\r\n            const repoMethodValue = repoMethod[prop];\r\n\r\n            switch (prop) {\r\n                case \"objectTypes\":\r\n                    // filterValue needs to be a subset of repoMethodValue.\r\n                    isMatch = ((filterValue || []) as string[]).every((filterValueEl) => {\r\n                        return ((repoMethodValue || []) as string[]).includes(filterValueEl);\r\n                    });\r\n                    break;\r\n                case \"flags\":\r\n                    // filterValue needs to be a subset of repoMethodValue.\r\n                    isMatch = isSubset(repoMethodValue || {}, filterValue || {});\r\n                    break;\r\n                default:\r\n                    isMatch = String(filterValue).toLowerCase() === String(repoMethodValue).toLowerCase();\r\n            }\r\n\r\n            return isMatch;\r\n        });\r\n    }\r\n\r\n    private getMethods(methodFilter: Glue42Core.AGM.MethodDefinition): ClientMethodInfo[] {\r\n        if (methodFilter === undefined) {\r\n            return this.repo.getMethods();\r\n        }\r\n\r\n        const methods = this.repo.getMethods().filter((method) => {\r\n            return this.methodMatch(methodFilter, method);\r\n        });\r\n\r\n        return methods;\r\n    }\r\n\r\n    private getMethodsForInstance(instanceFilter: Glue42Core.AGM.Instance): ClientMethodInfo[] {\r\n        const allServers: ServerInfo[] = this.repo.getServers();\r\n\r\n        const matchingServers = allServers.filter((server) => {\r\n            return this.instanceMatch(instanceFilter, server.instance);\r\n        });\r\n\r\n        if (matchingServers.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        let resultMethodsObject: { [key: string]: ClientMethodInfo } = {};\r\n\r\n        if (matchingServers.length === 1) {\r\n            resultMethodsObject = matchingServers[0].methods;\r\n        } else {\r\n            // we have more than one server matching, join all methods\r\n            matchingServers.forEach((server) => {\r\n                Object.keys(server.methods).forEach((methodKey) => {\r\n                    const method = server.methods[methodKey];\r\n                    // group by method identifier\r\n                    resultMethodsObject[method.identifier] = method;\r\n                });\r\n            });\r\n        }\r\n\r\n        // transform the object to array\r\n        return Object.keys(resultMethodsObject)\r\n            .map((key) => {\r\n                return resultMethodsObject[key];\r\n            });\r\n    }\r\n\r\n    private getServers(methodFilter?: Glue42Core.AGM.MethodDefinition): ServerMethodsPair[] {\r\n        const servers = this.repo.getServers();\r\n\r\n        // No method - get all getServers\r\n        if (methodFilter === undefined) {\r\n            return servers.map((server) => {\r\n                return { server, methods: [] };\r\n            });\r\n        }\r\n\r\n        // // Non-existing method - return an empty array\r\n        // const methods = this.getMethods(methodFilter);\r\n        // if (methods === undefined) {\r\n        //     return [];\r\n        // }\r\n\r\n        return servers.reduce<ServerMethodsPair[]>((prev, current) => {\r\n\r\n            const methodsForServer = Object.values(current.methods);\r\n\r\n            const matchingMethods = methodsForServer.filter((method) => {\r\n                return this.methodMatch(methodFilter, method);\r\n            });\r\n\r\n            if (matchingMethods.length > 0) {\r\n                prev.push({ server: current, methods: matchingMethods });\r\n            }\r\n\r\n            return prev;\r\n        }, []);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of server-methods pairs for all servers that match the target and have at lease one method matching the method filter\r\n     */\r\n    private getServerMethodsByFilterAndTarget(methodFilter: Glue42Core.AGM.MethodDefinition, target: Glue42Core.AGM.InstanceTarget): ServerMethodsPair[] {\r\n        // get all servers that have method(s) matching the filter\r\n        const serversMethodMap = this.getServers(methodFilter);\r\n        // filter the server-method map by target\r\n        return this.filterByTarget(target, serversMethodMap);\r\n    }\r\n\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport { GW3Bridge } from \"./bridges/gw3/bridge\";\r\nimport { ContextBridge } from \"./contextBridge\";\r\nimport Connection from \"../connection/connection\";\r\nimport { Logger } from \"../logger/logger\";\r\nimport { ContextName, ContextSubscriptionKey } from \"./bridges/types\";\r\n\r\n/** @ignore */\r\nexport interface ContextsConfig {\r\n    connection: Connection;\r\n    logger: Logger;\r\n}\r\n\r\nexport class ContextsModule implements Glue42Core.Contexts.API {\r\n\r\n    public initTime: number | undefined;\r\n    public initStartTime: number | undefined;\r\n    public initEndTime?: number;\r\n    private _bridge: ContextBridge;\r\n\r\n    public constructor(config: ContextsConfig) {\r\n        this._bridge = new GW3Bridge(config);\r\n    }\r\n\r\n    public all(): string[] {\r\n        return this._bridge.all();\r\n    }\r\n\r\n    /**\r\n     * Updates a context with some object. The object properties will replace the context properties, any other\r\n     * context properties will remain in the context. If the context does not exists the update call will create it.\r\n     *\r\n     * @example\r\n     * // if theme does not exists creates a context called theme with initial value\r\n     * glue.contexts.update(\"theme\", {font:10, font-family:\"Arial\"})\r\n     *\r\n     * // increases font to 11, after that call context is {font:10, font-family:\"Arial\"}\r\n     * glue.contexts.update(\"theme\", {font:11})\r\n     *\r\n     * @function\r\n     * @param name Name of the context to be updated\r\n     * @param data The object that will be applied to the context\r\n     */\r\n    public update(name: ContextName, data: any): Promise<void> {\r\n        this.checkName(name);\r\n        this.checkData(data);\r\n\r\n        return this._bridge.update(name, data);\r\n    }\r\n\r\n    /**\r\n     * Replaces a context\r\n     * @function\r\n     * @param name Name of the context to be updated\r\n     * @param data The object that will be applied to the context\r\n     */\r\n    public set(name: ContextName, data: any): Promise<void> {\r\n        this.checkName(name);\r\n        this.checkData(data);\r\n\r\n        return this._bridge.set(name, data);\r\n    }\r\n\r\n    public setPath(name: ContextName, path: string, data: any): Promise<void> {\r\n        this.checkName(name);\r\n        this.checkPath(path);\r\n        const isTopLevelPath = path === \"\";\r\n\r\n        if (isTopLevelPath) {\r\n            // Check the data only in the case of a top level path as the inner props can be of type any.\r\n            this.checkData(data);\r\n\r\n            return this.set(name, data);\r\n        }\r\n\r\n        return this._bridge.setPath(name, path, data);\r\n    }\r\n\r\n    public setPaths(name: ContextName, paths: Glue42Core.Contexts.PathValue[]): Promise<void> {\r\n        this.checkName(name);\r\n\r\n        if (!Array.isArray(paths)) {\r\n            throw new Error(\"Please provide the paths as an array of PathValues!\");\r\n        }\r\n\r\n        for (const { path, value } of paths) {\r\n            this.checkPath(path);\r\n            const isTopLevelPath = path === \"\";\r\n\r\n            if (isTopLevelPath) {\r\n                // Check the value only in the case of a top level path as the inner props can be of type any.\r\n                this.checkData(value);\r\n            }\r\n        }\r\n\r\n        return this._bridge.setPaths(name, paths);\r\n    }\r\n\r\n    /**\r\n     * Subscribe for context events\r\n     *\r\n     * NB: This method publishes an initial snapshot on subscription.\r\n     * To unsubscribe from within the callback, use the unsubscribe argument\r\n     * of the callback, since the method itself may not have returned and the returned\r\n     * callback is not available in the calling code.\r\n     *\r\n     * @function\r\n     *\r\n     * @param name name of the context to subscribe for\r\n     * @param callback function that will receive updates.\r\n     * @returns Function execute the returned function to unsubscribe\r\n     */\r\n    public subscribe(\r\n        name: ContextName,\r\n        callback: (data: any, delta: any, removed: string[], unsubscribe: () => void, extraData?: any) => void): Promise<() => void> {\r\n        this.checkName(name);\r\n        if (typeof callback !== \"function\") {\r\n            throw new Error(\"Please provide the callback as a function!\");\r\n        }\r\n\r\n        return this._bridge\r\n            .subscribe(name, (data: any, delta: any, removed: string[], key: ContextSubscriptionKey, extraData?: any) => callback(data, delta, removed, () => this._bridge.unsubscribe(key), extraData))\r\n            .then((key) =>\r\n                () => {\r\n                    this._bridge.unsubscribe(key);\r\n                });\r\n\r\n    }\r\n\r\n    /**\r\n     * Return a context's data\r\n     */\r\n    public get(name: ContextName): Promise<any> {\r\n        this.checkName(name);\r\n\r\n        return this._bridge.get(name);\r\n    }\r\n\r\n    public ready(): Promise<any> {\r\n        return Promise.resolve(this);\r\n    }\r\n\r\n    public destroy(name: string): Promise<any> {\r\n        this.checkName(name);\r\n\r\n        return this._bridge.destroy(name);\r\n    }\r\n\r\n    public get setPathSupported() {\r\n        return this._bridge.setPathSupported;\r\n    }\r\n\r\n    private checkName(name: ContextName) {\r\n        if (typeof name !== \"string\" || name === \"\") {\r\n            throw new Error(\"Please provide the name as a non-empty string!\");\r\n        }\r\n    }\r\n\r\n    private checkPath(path: string) {\r\n        if (typeof path !== \"string\") {\r\n            throw new Error(\"Please provide the path as a dot delimited string!\");\r\n        }\r\n    }\r\n\r\n    // TODO: Update the typings everywhere to disallow strings, numbers, etc.\r\n    private checkData(data: any) {\r\n        // Allows null.\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Please provide the data as an object!\");\r\n        }\r\n    }\r\n}\r\n","export default function <T>(promise: Promise<any>, successCallback: any, errorCallback: any): Promise<T> {\r\n\r\n    if (typeof successCallback !== \"function\" && typeof errorCallback !== \"function\") {\r\n        return promise;\r\n    }\r\n\r\n    if (typeof successCallback !== \"function\") {\r\n        successCallback = () => { /* DO NOTHING */ };\r\n    } else if (typeof errorCallback !== \"function\") {\r\n        errorCallback = () => {  /* DO NOTHING */ };\r\n    }\r\n\r\n    return promise.then(successCallback, errorCallback);\r\n}\r\n","export const waitFor = async (ms: number = 0, callback: () => void) => {\r\n    await resolveAfter(ms);\r\n    callback();\r\n};\r\n\r\nfunction resolveAfter<T>(ms: number = 0, result?: T): Promise<T> {\r\n    return new Promise((resolve) => setTimeout(() => resolve(result), ms));\r\n}\r\n\r\nexport function rejectAfter<T>(ms: number = 0, promise: Promise<T>, error?: T): Promise<T> {\r\n    let timeout: any;\r\n    const clearTimeoutIfThere = () => {\r\n        if (timeout) {\r\n            clearTimeout(timeout);\r\n        }\r\n    };\r\n    promise\r\n        .then(() => {\r\n            clearTimeoutIfThere();\r\n        })\r\n        .catch(() => {\r\n            clearTimeoutIfThere();\r\n        });\r\n\r\n    return new Promise((resolve, reject) => {\r\n        timeout = setTimeout(() => reject(error), ms);\r\n    });\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\n\r\nimport { WrappedCallbackFunction, ResultContext, ServerMethodInfo, ServerSubscriptionInfo } from \"./types\";\r\n\r\nexport default class ServerSubscription implements Glue42Core.AGM.StreamSubscription {\r\n\r\n    constructor(private protocol: Protocol, private repoMethod: ServerMethodInfo, private subscription: ServerSubscriptionInfo) {\r\n    }\r\n\r\n    public get stream(): Glue42Core.AGM.Stream {\r\n        if (!this.repoMethod.stream) {\r\n            throw new Error(\"no stream\");\r\n        }\r\n        return this.repoMethod.stream;\r\n    }\r\n    public get arguments() { return this.subscription.arguments || {}; }\r\n    public get branchKey(): string { return this.subscription.branchKey; }\r\n    public get instance(): Glue42Core.AGM.Instance {\r\n        if (!this.subscription.instance) {\r\n            throw new Error(\"no instance\");\r\n        }\r\n        return this.subscription.instance;\r\n    }\r\n\r\n    public close() {\r\n        this.protocol.server.closeSingleSubscription(this.repoMethod, this.subscription);\r\n    }\r\n\r\n    public push(data: object) {\r\n        this.protocol.server.pushDataToSingle(this.repoMethod, this.subscription, data);\r\n    }\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { ServerMethodInfo, RequestContext } from \"./types\";\r\n\r\nexport default class Request implements Glue42Core.AGM.SubscriptionRequest {\r\n    public arguments: object;\r\n    public instance: Glue42Core.AGM.Instance;\r\n\r\n    constructor(private protocol: Protocol, private repoMethod: ServerMethodInfo, private requestContext: RequestContext) {\r\n        this.arguments = requestContext.arguments;\r\n        this.instance = requestContext.instance;\r\n    }\r\n\r\n    public accept() {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, \"\");\r\n    }\r\n\r\n    public acceptOnBranch(branch: string) {\r\n        this.protocol.server.acceptRequestOnBranch(this.requestContext, this.repoMethod, branch);\r\n    }\r\n\r\n    public reject(reason: string) {\r\n        this.protocol.server.rejectRequest(this.requestContext, this.repoMethod, reason);\r\n    }\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { ServerMethodInfo, RequestContext, ServerSubscriptionInfo } from \"./types\";\r\nimport ServerSubscription from \"./subscription\";\r\nimport Server from \"./server\";\r\nimport Request from \"./request\";\r\n\r\n/*\r\n The streaming module defines the user objects relevant to the streaming api, and\r\n attaches to relevant events exposed by the protocol.\r\n */\r\nexport default class ServerStreaming {\r\n    constructor(public protocol: Protocol, private server: Server) {\r\n\r\n        /** Attach to stream 'events' */\r\n        protocol.server.onSubRequest((rc, rm) => this.handleSubRequest(rc, rm));\r\n\r\n        protocol.server.onSubAdded((sub, rm) => this.handleSubAdded(sub, rm));\r\n\r\n        protocol.server.onSubRemoved((sub, rm) => this.handleSubRemoved(sub, rm));\r\n    }\r\n\r\n    private handleSubRequest(requestContext: RequestContext, repoMethod: ServerMethodInfo) {\r\n\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRequestHandler === \"function\")) {\r\n            return;\r\n        }\r\n\r\n        const request = new Request(this.protocol, repoMethod, requestContext);\r\n        repoMethod.streamCallbacks.subscriptionRequestHandler(request);\r\n    }\r\n\r\n    private handleSubAdded(subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionAddedHandler === \"function\")) {\r\n            return;\r\n        }\r\n\r\n        const sub = new ServerSubscription(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionAddedHandler(sub);\r\n    }\r\n\r\n    private handleSubRemoved(subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) {\r\n        if (!(repoMethod &&\r\n            repoMethod.streamCallbacks &&\r\n            typeof repoMethod.streamCallbacks.subscriptionRemovedHandler === \"function\")) {\r\n            return;\r\n        }\r\n\r\n        const sub = new ServerSubscription(this.protocol, repoMethod, subscription);\r\n        repoMethod.streamCallbacks.subscriptionRemovedHandler(sub);\r\n    }\r\n}\r\n","import { Protocol } from \"../types\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport ServerSubscription from \"./subscription\";\r\nimport { ServerMethodInfo } from \"./types\";\r\n\r\nexport default class ServerBranch implements Glue42Core.AGM.StreamBranch {\r\n\r\n    constructor(public key: string, private protocol: Protocol, private repoMethod: ServerMethodInfo) {\r\n    }\r\n\r\n    public subscriptions() {\r\n        const subList = this.protocol.server.getSubscriptionList(this.repoMethod, this.key);\r\n        return subList.map((sub) => {\r\n            return new ServerSubscription(this.protocol, this.repoMethod, sub);\r\n        });\r\n    }\r\n\r\n    public close() {\r\n        this.protocol.server.closeAllSubscriptions(this.repoMethod, this.key);\r\n    }\r\n\r\n    public push(data: object) {\r\n        this.protocol.server.pushData(this.repoMethod, data, [this.key]);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../glue\";\r\nimport { Protocol } from \"../types\";\r\nimport { ServerMethodInfo } from \"./types\";\r\nimport ServerSubscription from \"./subscription\";\r\nimport ServerBranch from \"./branch\";\r\nimport Server from \"./server\";\r\n\r\nexport default class ServerStream implements Glue42Core.AGM.Stream {\r\n    public readonly name: string;\r\n\r\n    constructor(private _protocol: Protocol, private _repoMethod: ServerMethodInfo, private _server: Server) {\r\n        this.name = this._repoMethod.definition.name;\r\n    }\r\n\r\n    public branches(): Glue42Core.AGM.StreamBranch[];\r\n    public branches(key: string): Glue42Core.AGM.StreamBranch | undefined;\r\n    public branches(key?: string): Glue42Core.AGM.StreamBranch[] | Glue42Core.AGM.StreamBranch | undefined {\r\n        const bList: string[] = this._protocol.server.getBranchList(this._repoMethod);\r\n        if (key) {\r\n            if (bList.indexOf(key) > -1) {\r\n                return new ServerBranch(key, this._protocol, this._repoMethod);\r\n            }\r\n            return undefined;\r\n\r\n        } else {\r\n            return bList.map((branchKey: string) => {\r\n                return new ServerBranch(branchKey, this._protocol, this._repoMethod);\r\n            });\r\n        }\r\n    }\r\n\r\n    public branch(key: string) {\r\n        return this.branches(key);\r\n    }\r\n\r\n    public subscriptions(): Glue42Core.AGM.StreamSubscription[] {\r\n        const subList = this._protocol.server.getSubscriptionList(this._repoMethod);\r\n        return subList.map((sub) => {\r\n            return new ServerSubscription(this._protocol, this._repoMethod, sub);\r\n        });\r\n    }\r\n\r\n    public get definition(): Glue42Core.AGM.MethodDefinition {\r\n        const def2 = this._repoMethod.definition;\r\n        return {\r\n            accepts: def2.accepts,\r\n            description: def2.description,\r\n            displayName: def2.displayName,\r\n            name: def2.name,\r\n            objectTypes: def2.objectTypes,\r\n            returns: def2.returns,\r\n            supportsStreaming: def2.supportsStreaming,\r\n            flags: def2.flags?.metadata,\r\n        };\r\n    }\r\n\r\n    public close() {\r\n        this._protocol.server.closeAllSubscriptions(this._repoMethod);\r\n        this._server.unregister(this._repoMethod.definition, true);\r\n    }\r\n\r\n    public push(data: object, branches: string[]) {\r\n        if (typeof branches !== \"string\" && !Array.isArray(branches) && branches !== undefined) {\r\n            throw new Error(\"invalid branches should be string or string array\");\r\n        }\r\n        // TODO validate if is plain object\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n        this._protocol.server.pushData(this._repoMethod, data, branches);\r\n    }\r\n\r\n    public updateRepoMethod(repoMethod: ServerMethodInfo) {\r\n        this._repoMethod = repoMethod;\r\n    }\r\n}\r\n","import promisify from \"../helpers/promisify\";\r\nimport ServerStreaming from \"./streaming\";\r\nimport { Protocol, InteropSettings } from \"../types\";\r\nimport ServerRepository from \"./repository\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { WrappedCallbackFunction, ResultContext, ServerMethodInfo } from \"./types\";\r\nimport ServerStream from \"./stream\";\r\n\r\n/*\r\n The AGM Server allows users register AGM methods.\r\n It exposes these methods to AGM clients (using presence messages) and listens for their invocation\r\n */\r\nexport default class Server {\r\n    private streaming: ServerStreaming;\r\n    private invocations: number = 0;\r\n    private currentlyUnregistering: { [method: string]: Promise<void> } = {};\r\n\r\n    constructor(private protocol: Protocol, private serverRepository: ServerRepository) {\r\n        // An array of the server's methods\r\n        this.streaming = new ServerStreaming(protocol, this);\r\n\r\n        this.protocol.server.onInvoked(this.onMethodInvoked.bind(this));\r\n    }\r\n\r\n    // Registers a new streaming agm method\r\n    public createStream(streamDef: string | Glue42Core.AGM.MethodDefinition, callbacks?: Glue42Core.AGM.StreamOptions, successCallback?: (args?: object) => void, errorCallback?: (error?: string | object) => void, existingStream?: ServerStream): Promise<Glue42Core.AGM.Stream> {\r\n        // in callbacks we have subscriptionRequestHandler, subscriptionAddedHandler, subscriptionRemovedHandler\r\n        const promise = new Promise((resolve, reject) => {\r\n            if (!streamDef) {\r\n                reject(`The stream name must be unique! Please, provide either a unique string for a stream name to glue.interop.createStream() or a methodDefinition object with a unique name property for the stream.`);\r\n                return;\r\n            }\r\n\r\n            // transform to a definition\r\n            let streamMethodDefinition: Glue42Core.AGM.MethodDefinition;\r\n\r\n            // This is important because if you change the name for example this will change here as well and it shouldn't change by reference\r\n            if (typeof streamDef === \"string\") {\r\n                streamMethodDefinition = { name: \"\" + streamDef };\r\n            } else {\r\n                streamMethodDefinition = { ...streamDef };\r\n            }\r\n\r\n            if (!streamMethodDefinition.name) {\r\n                return reject(`The name property is required for the streamDefinition object and must be unique. Stream definition: ${JSON.stringify(streamMethodDefinition)}`);\r\n            }\r\n\r\n            const nameAlreadyExists = this.serverRepository.getList()\r\n                .some((serverMethod) => serverMethod.definition.name === streamMethodDefinition.name);\r\n\r\n            if (nameAlreadyExists) {\r\n                return reject(`A stream with the name \"${streamMethodDefinition.name}\" already exists! Please, provide a unique name for the stream.`);\r\n            }\r\n\r\n            streamMethodDefinition.supportsStreaming = true;\r\n\r\n            // User-supplied subscription callbacks\r\n            if (!callbacks) {\r\n                callbacks = {};\r\n            }\r\n\r\n            if (typeof callbacks.subscriptionRequestHandler !== \"function\") {\r\n                callbacks.subscriptionRequestHandler = (request: Glue42Core.AGM.SubscriptionRequest) => {\r\n                    request.accept();\r\n                };\r\n            }\r\n            // Add the method\r\n            const repoMethod = this.serverRepository.add({\r\n                definition: streamMethodDefinition, // store un-formatted definition for checkups in un-register method\r\n                streamCallbacks: callbacks,\r\n                protocolState: {},\r\n            });\r\n\r\n            this.protocol.server.createStream(repoMethod)\r\n                .then(() => {\r\n                    let streamUserObject: ServerStream;\r\n                    if (existingStream) {\r\n                        streamUserObject = existingStream;\r\n                        existingStream.updateRepoMethod(repoMethod);\r\n                    } else {\r\n                        streamUserObject = new ServerStream(this.protocol, repoMethod, this);\r\n                    }\r\n                    repoMethod.stream = streamUserObject;\r\n                    resolve(streamUserObject);\r\n                })\r\n                .catch((err) => {\r\n                    if (repoMethod.repoId) {\r\n                        this.serverRepository.remove(repoMethod.repoId);\r\n                    }\r\n                    reject(err);\r\n                });\r\n        });\r\n\r\n        return promisify(promise, successCallback, errorCallback);\r\n    }\r\n\r\n    /**\r\n     * Registers a new agm method\r\n     * @param {MethodDefinition} methodDefinition\r\n     * @param {MethodHandler} callback Callback that will be called when the AGM server is invoked\r\n     */\r\n\r\n    public register(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: object, caller: Glue42Core.AGM.Instance) => object | Promise<object>): Promise<void> {\r\n        if (!methodDefinition) {\r\n            return Promise.reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n        }\r\n\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(`The second parameter must be a callback function. Method: ${typeof methodDefinition === \"string\" ? methodDefinition : methodDefinition.name}`);\r\n        }\r\n\r\n        const wrappedCallbackFunction: WrappedCallbackFunction = async (context: ResultContext, resultCallback: (err: string | undefined, result: object) => void) => {\r\n            // get the result as direct invocation of the callback and return it using resultCallback\r\n            try {\r\n                const result = callback(context.args, context.instance);\r\n                if (result && typeof (result as any).then === \"function\") {\r\n                    const resultValue = await result;\r\n                    resultCallback(undefined, resultValue);\r\n                } else {\r\n                    resultCallback(undefined, result);\r\n                }\r\n            } catch (e) {\r\n                if (!e) {\r\n                    e = \"\";\r\n                }\r\n                resultCallback(e, e);\r\n            }\r\n        };\r\n\r\n        wrappedCallbackFunction.userCallback = callback;\r\n\r\n        return this.registerCore(methodDefinition, wrappedCallbackFunction);\r\n    }\r\n\r\n    // registers a new async agm method (the result can be returned in async way)\r\n    public registerAsync(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: object, caller: Glue42Core.AGM.Instance, successCallback: (args?: object) => void, errorCallback: (error?: string | object) => void) => Promise<object> | void): Promise<void> {\r\n        if (!methodDefinition) {\r\n            return Promise.reject(`Method definition is required. Please, provide either a unique string for a method name or a methodDefinition object with a required name property.`);\r\n        }\r\n\r\n        if (typeof callback !== \"function\") {\r\n            return Promise.reject(`The second parameter must be a callback function. Method: ${typeof methodDefinition === \"string\" ? methodDefinition : methodDefinition.name}`);\r\n        }\r\n\r\n        const wrappedCallback: WrappedCallbackFunction = (context: ResultContext, resultCallback: (err: string | undefined, result: object | undefined) => void) => {\r\n            // invoke the callback passing success and error callbacks\r\n            try {\r\n                let resultCalled = false;\r\n                const success = (result?: object) => {\r\n                    if (!resultCalled) {\r\n                        resultCallback(undefined, result);\r\n                    }\r\n                    resultCalled = true;\r\n                };\r\n                const error = (e: any) => {\r\n                    if (!resultCalled) {\r\n                        if (!e) {\r\n                            e = \"\";\r\n                        }\r\n                        resultCallback(e, e);\r\n                    }\r\n                    resultCalled = true;\r\n                };\r\n\r\n                const methodResult = callback(context.args,\r\n                    context.instance,\r\n                    success,\r\n                    error\r\n                );\r\n\r\n                if (methodResult && typeof methodResult.then === \"function\") {\r\n                    methodResult\r\n                        .then(success)\r\n                        .catch(error);\r\n                }\r\n            } catch (e) {\r\n                resultCallback(e, undefined);\r\n            }\r\n        };\r\n        wrappedCallback.userCallbackAsync = callback;\r\n\r\n        return this.registerCore(methodDefinition, wrappedCallback);\r\n    }\r\n\r\n    // Unregisters a previously registered AGM method\r\n    public async unregister(methodFilter: string | Glue42Core.AGM.MethodDefinition, forStream: boolean = false): Promise<void> {\r\n        if (methodFilter === undefined) {\r\n            return Promise.reject(`Please, provide either a unique string for a name or an object containing a name property.`);\r\n        }\r\n\r\n        // WHEN A FUNCTION IS PASSED\r\n        if (typeof methodFilter === \"function\") {\r\n            await this.unregisterWithPredicate(methodFilter, forStream);\r\n            return;\r\n        }\r\n\r\n        // WHEN string / object is passed\r\n        let methodDefinition: Glue42Core.AGM.MethodDefinition;\r\n        if (typeof methodFilter === \"string\") {\r\n            methodDefinition = { name: methodFilter };\r\n        } else {\r\n            methodDefinition = methodFilter;\r\n        }\r\n\r\n        if (methodDefinition.name === undefined) {\r\n            return Promise.reject(`Method name is required. Cannot find a method if the method name is undefined!`);\r\n        }\r\n\r\n        const methodToBeRemoved: ServerMethodInfo | undefined = this.serverRepository.getList().find((serverMethod) => {\r\n            return serverMethod.definition.name === methodDefinition.name\r\n                && (serverMethod.definition.supportsStreaming || false) === forStream;\r\n            // return this.containsProps(methodFilter, method.definition);\r\n        });\r\n\r\n        if (!methodToBeRemoved) {\r\n            return Promise.reject(`Method with a name \"${methodDefinition.name}\" does not exist or is not registered by your application!`);\r\n        }\r\n\r\n        await this.removeMethodsOrStreams([methodToBeRemoved]);\r\n    }\r\n\r\n    private async unregisterWithPredicate(filterPredicate: (methodDefinition: Glue42Core.AGM.MethodDefinition) => ServerMethodInfo, forStream?: boolean) {\r\n        const methodsOrStreamsToRemove = this.serverRepository.getList()\r\n            .filter((sm) => filterPredicate(sm.definition))\r\n            .filter((serverMethod) =>\r\n                // because both can be undefined or false\r\n                (serverMethod.definition.supportsStreaming || false) === forStream\r\n            );\r\n\r\n        if (!methodsOrStreamsToRemove || methodsOrStreamsToRemove.length === 0) {\r\n            return Promise.reject(`Could not find a ${forStream ? \"stream\" : \"method\"} matching the specified condition!`);\r\n        }\r\n\r\n        await this.removeMethodsOrStreams(methodsOrStreamsToRemove);\r\n    }\r\n\r\n    private removeMethodsOrStreams(methodsToRemove: ServerMethodInfo[]) {\r\n        const methodUnregPromises: Array<Promise<void>> = [];\r\n\r\n        methodsToRemove.forEach((method) => {\r\n            const promise = this.protocol.server.unregister(method)\r\n                .then(() => {\r\n                    if (method.repoId) {\r\n                        this.serverRepository.remove(method.repoId);\r\n                    }\r\n                });\r\n\r\n            methodUnregPromises.push(promise);\r\n            this.addAsCurrentlyUnregistering(method.definition.name, promise);\r\n        });\r\n\r\n        return Promise.all(methodUnregPromises);\r\n    }\r\n\r\n    private async addAsCurrentlyUnregistering(methodName: string, promise: Promise<void>) {\r\n        const timeout = new Promise((resolve) => setTimeout(resolve, 5000));\r\n\r\n        // will be cleared when promise resolved\r\n        this.currentlyUnregistering[methodName] = Promise.race([promise, timeout]).then(() => {\r\n            delete this.currentlyUnregistering[methodName];\r\n        });\r\n    }\r\n\r\n    // Core method for registering agm method\r\n    private async registerCore(method: string | Glue42Core.AGM.MethodDefinition, theFunction: WrappedCallbackFunction): Promise<void> {\r\n        // transform to a definition\r\n        let methodDefinition: Glue42Core.AGM.MethodDefinition;\r\n\r\n        // This is important because if you change the name for example this will change here as well and it shouldn't change by reference\r\n        if (typeof method === \"string\") {\r\n            methodDefinition = { name: \"\" + method };\r\n        } else {\r\n            methodDefinition = { ...method };\r\n        }\r\n\r\n        if (!methodDefinition.name) {\r\n            return Promise.reject(`Please, provide a (unique) string value for the name property in the methodDefinition object: ${JSON.stringify(method)}`);\r\n        }\r\n\r\n        const unregisterInProgress = this.currentlyUnregistering[methodDefinition.name];\r\n        if (unregisterInProgress) {\r\n            await unregisterInProgress;\r\n        }\r\n\r\n        const nameAlreadyExists = this.serverRepository.getList()\r\n            .some((serverMethod) => serverMethod.definition.name === methodDefinition.name);\r\n\r\n        if (nameAlreadyExists) {\r\n            return Promise.reject(`A method with the name \"${methodDefinition.name}\" already exists! Please, provide a unique name for the method.`);\r\n        }\r\n\r\n        if (methodDefinition.supportsStreaming) {\r\n            return Promise.reject(`When you create methods with glue.interop.register() or glue.interop.registerAsync() the property supportsStreaming cannot be true. If you want ${methodDefinition.name} to be a stream, please use the glue.interop.createStream() method.`);\r\n        }\r\n\r\n        // Add the method ()\r\n        const repoMethod = this.serverRepository.add({\r\n            definition: methodDefinition, // store un-formatted definition for checkups in un-register method\r\n            theFunction,\r\n            protocolState: {},\r\n        });\r\n\r\n        // make it then .catch for those error/success callbacks\r\n        return this.protocol.server.register(repoMethod)\r\n            .catch((err: any) => {\r\n                if (repoMethod?.repoId) {\r\n                    this.serverRepository.remove(repoMethod.repoId);\r\n                }\r\n                throw err;\r\n            });\r\n    }\r\n\r\n    private onMethodInvoked(methodToExecute: ServerMethodInfo, invocationId: string, invocationArgs: ResultContext) {\r\n        if (!methodToExecute || !methodToExecute.theFunction) {\r\n            return;\r\n        }\r\n\r\n        // Execute it and save the result\r\n        methodToExecute.theFunction(invocationArgs, (err: any, result) => {\r\n            if (err !== undefined && err !== null) {\r\n                // handle error case\r\n                if (err.message && typeof err.message === \"string\") {\r\n                    err = err.message;\r\n                } else if (typeof err !== \"string\") {\r\n                    try {\r\n                        err = JSON.stringify(err);\r\n                    } catch (unStrException) {\r\n                        err = `un-stringifyable error in onMethodInvoked! Top level prop names: ${Object.keys(err)}`;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!result) {\r\n                result = {};\r\n            } else if (typeof result !== \"object\" || Array.isArray(result)) {\r\n                // The AGM library only transfers objects. If the result is not an object, put it in one\r\n                result = { _value: result };\r\n            }\r\n\r\n            this.protocol.server.methodInvocationResult(methodToExecute, invocationId, err, result);\r\n        });\r\n    }\r\n}\r\n","import generate from \"shortid\";\r\nimport { Glue42Core } from \"./../../glue\";\r\n\r\nexport class InstanceWrapper {\r\n    private wrapped: Glue42Core.Interop.Instance = {};\r\n\r\n    constructor(API: Glue42Core.AGM.API, instance?: Glue42Core.AGM.Instance, connection?: Glue42Core.Connection.API) {\r\n        this.wrapped.getMethods = function (): Glue42Core.Interop.Method[] {\r\n            return API.methodsForInstance(this);\r\n        };\r\n        this.wrapped.getStreams = function (): Glue42Core.Interop.Method[] {\r\n            return API.methodsForInstance(this).filter((m) => m.supportsStreaming);\r\n        };\r\n\r\n        if (instance) {\r\n            this.refreshWrappedObject(instance);\r\n        }\r\n        if (connection) {\r\n            connection.loggedIn(() => {\r\n                this.refresh(connection);\r\n            });\r\n            this.refresh(connection);\r\n        }\r\n    }\r\n\r\n    public unwrap(): Glue42Core.Interop.Instance {\r\n        return this.wrapped;\r\n    }\r\n\r\n    private refresh(connection: Glue42Core.Connection.API) {\r\n        if (!connection) {\r\n            return;\r\n        }\r\n\r\n        // Apply resolved identity (GW3 case)\r\n        const resolvedIdentity = connection?.resolvedIdentity;\r\n        const instance = Object.assign({}, resolvedIdentity ?? {}, { peerId: connection?.peerId });\r\n        this.refreshWrappedObject(instance);\r\n    }\r\n\r\n    private refreshWrappedObject(resolvedIdentity: Glue42Core.Interop.Instance) {\r\n        Object.keys(resolvedIdentity).forEach((key) => {\r\n            (this.wrapped as any)[key] = (resolvedIdentity as any)[key];\r\n        });\r\n\r\n        this.wrapped.user = resolvedIdentity.user;\r\n        this.wrapped.instance = resolvedIdentity.instance;\r\n        this.wrapped.application = resolvedIdentity.application ?? generate();\r\n        this.wrapped.applicationName = resolvedIdentity.applicationName;\r\n        this.wrapped.pid = resolvedIdentity.pid ?? (resolvedIdentity as any).process ?? Math.floor(Math.random() * 10000000000);\r\n        this.wrapped.machine = resolvedIdentity.machine;\r\n        this.wrapped.environment = resolvedIdentity.environment;\r\n        this.wrapped.region = resolvedIdentity.region;\r\n        this.wrapped.windowId = resolvedIdentity.windowId;\r\n        this.wrapped.isLocal = resolvedIdentity.isLocal ?? true;\r\n        this.wrapped.api = resolvedIdentity.api;\r\n        this.wrapped.service = resolvedIdentity.service;\r\n        this.wrapped.peerId = resolvedIdentity.peerId;\r\n    }\r\n}\r\n","/*\r\n * Repository holding servers and methods visible by this peer including those created by the peer itself.\r\n */\r\nimport { default as CallbackRegistryFactory, UnsubscribeFunction } from \"callback-registry\";\r\nimport { Glue42Core } from \"../../../glue\";\r\nimport { ClientMethodInfo, ServerInfo } from \"./types\";\r\nimport { MethodInfoMessage } from \"../protocols/gw3/messages\";\r\nimport { Logger } from \"../../logger/logger\";\r\nimport { InstanceWrapper } from \"../instance\";\r\nimport Client from \"./client\";\r\n\r\nconst hideMethodSystemFlags = (method: ClientMethodInfo): ClientMethodInfo => {\r\n    return {\r\n        ...method,\r\n        flags: method.flags.metadata || {}\r\n    };\r\n};\r\n\r\nexport default class ClientRepository {\r\n\r\n    // each server has format {id:'', info:{}, methods:{}}\r\n    // where methods has format {id:'', info:{}}\r\n    private servers: { [id: string]: ServerInfo } = {};\r\n    private myServer: ServerInfo;\r\n\r\n    // object keyed by method identifier - value is number of servers that offer that method\r\n    private methodsCount: { [id: string]: number } = {};\r\n\r\n    // store for callbacks\r\n    private callbacks = CallbackRegistryFactory();\r\n\r\n    constructor(private logger: Logger, private API: Glue42Core.AGM.API & { unwrappedInstance: InstanceWrapper }) {\r\n        const peerId = this.API.instance.peerId as string;\r\n        this.myServer = {\r\n            id: peerId,\r\n            methods: {},\r\n            instance: this.API.instance,\r\n            wrapper: this.API.unwrappedInstance,\r\n        };\r\n        this.servers[peerId] = this.myServer;\r\n    }\r\n\r\n    // add a new server to internal collection\r\n    public addServer(info: Glue42Core.AGM.Instance, serverId: string): string {\r\n        this.logger.debug(`adding server ${serverId}`);\r\n\r\n        const current = this.servers[serverId];\r\n        if (current) {\r\n            return current.id;\r\n        }\r\n\r\n        const wrapper = new InstanceWrapper(this.API, info);\r\n        const serverEntry: ServerInfo = {\r\n            id: serverId,\r\n            methods: {},\r\n            instance: wrapper.unwrap(),\r\n            wrapper,\r\n        };\r\n\r\n        this.servers[serverId] = serverEntry;\r\n        this.callbacks.execute(\"onServerAdded\", serverEntry.instance);\r\n        return serverId;\r\n    }\r\n\r\n    public removeServerById(id: string, reason?: string) {\r\n        const server = this.servers[id];\r\n        if (!server) {\r\n            // tslint:disable-next-line:no-console\r\n            this.logger.warn(`not aware of server ${id}, my state ${JSON.stringify(Object.keys(this.servers))}`);\r\n            return;\r\n        } else {\r\n            // tslint:disable-next-line:no-console\r\n            this.logger.debug(`removing server ${id}`);\r\n        }\r\n\r\n        Object.keys(server.methods).forEach((methodId) => {\r\n            this.removeServerMethod(id, methodId);\r\n        });\r\n\r\n        delete this.servers[id];\r\n        this.callbacks.execute(\"onServerRemoved\", server.instance, reason);\r\n    }\r\n\r\n    public addServerMethod(serverId: string, method: MethodInfoMessage) {\r\n\r\n        const server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n\r\n        // server already has that method\r\n        if (server.methods[method.id]) {\r\n            return;\r\n        }\r\n\r\n        const identifier = this.createMethodIdentifier(method);\r\n        const that = this;\r\n        const methodDefinition: ClientMethodInfo = {\r\n            identifier,\r\n            gatewayId: method.id,\r\n            name: method.name,\r\n            displayName: method.display_name,\r\n            description: method.description,\r\n            version: method.version,\r\n            objectTypes: method.object_types || [],\r\n            accepts: method.input_signature,\r\n            returns: method.result_signature,\r\n            supportsStreaming: typeof method.flags !== \"undefined\" ? method.flags.streaming : false,\r\n            flags: method.flags ?? {},\r\n            getServers: () => {\r\n                return that.getServersByMethod(identifier);\r\n            }\r\n        };\r\n        // now add some legacy stuff\r\n        (methodDefinition as any).object_types = methodDefinition.objectTypes;\r\n        (methodDefinition as any).display_name = methodDefinition.displayName;\r\n        (methodDefinition as any).version = methodDefinition.version;\r\n\r\n        server.methods[method.id] = methodDefinition;\r\n\r\n        const clientMethodDefinition = hideMethodSystemFlags(methodDefinition);\r\n\r\n        // increase the ref and notify listeners\r\n        if (!this.methodsCount[identifier]) {\r\n            this.methodsCount[identifier] = 0;\r\n            this.callbacks.execute(\"onMethodAdded\", clientMethodDefinition);\r\n        }\r\n        this.methodsCount[identifier] = this.methodsCount[identifier] + 1;\r\n\r\n        this.callbacks.execute(\"onServerMethodAdded\", server.instance, clientMethodDefinition);\r\n        return methodDefinition;\r\n    }\r\n\r\n    public removeServerMethod(serverId: string, methodId: string) {\r\n        const server = this.servers[serverId];\r\n        if (!server) {\r\n            throw new Error(\"server does not exists\");\r\n        }\r\n\r\n        const method = server.methods[methodId];\r\n        delete server.methods[methodId];\r\n\r\n        const clientMethodDefinition = hideMethodSystemFlags(method);\r\n\r\n        // update ref counting\r\n        this.methodsCount[method.identifier] = this.methodsCount[method.identifier] - 1;\r\n        if (this.methodsCount[method.identifier] === 0) {\r\n            this.callbacks.execute(\"onMethodRemoved\", clientMethodDefinition);\r\n        }\r\n\r\n        this.callbacks.execute(\"onServerMethodRemoved\", server.instance, clientMethodDefinition);\r\n    }\r\n\r\n    public getMethods(): ClientMethodInfo[] {\r\n        return this.extractMethodsFromServers(Object.values(this.servers)).map(hideMethodSystemFlags);\r\n    }\r\n\r\n    public getServers(): ServerInfo[] {\r\n        return Object.values(this.servers).map(this.hideServerMethodSystemFlags);\r\n    }\r\n\r\n    public onServerAdded(callback: (server: Glue42Core.Interop.Instance) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerAdded\", callback);\r\n\r\n        // because we need the servers shapshot before we exist this stack\r\n        const serversWithMethodsToReplay = this.getServers().map((s) => s.instance);\r\n\r\n        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, serversWithMethodsToReplay, callback);\r\n    }\r\n\r\n    public onMethodAdded(callback: (method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onMethodAdded\", callback);\r\n\r\n        // because we need the servers snapshot before we return to the application code\r\n        const methodsToReplay = this.getMethods();\r\n\r\n        return this.returnUnsubWithDelayedReplay(unsubscribeFunc, methodsToReplay, callback);\r\n    }\r\n\r\n    public onServerMethodAdded(callback: (server: Glue42Core.AGM.Instance, method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerMethodAdded\", callback);\r\n\r\n        // because we want to interrupt the loop with the existing methods\r\n        let unsubCalled = false;\r\n\r\n        // because we need the servers shapshot before we return to the application code\r\n        const servers = this.getServers();\r\n\r\n        // because we want to have the unsub function before the callback is called with all existing methods\r\n        setTimeout(() => {\r\n            servers.forEach((server) => {\r\n                const methods = server.methods;\r\n                Object.keys(methods).forEach((methodId) => {\r\n                    if (!unsubCalled) {\r\n                        callback(server.instance, methods[methodId]);\r\n                    }\r\n                });\r\n            });\r\n        }, 0);\r\n\r\n        return () => {\r\n            unsubCalled = true;\r\n            unsubscribeFunc();\r\n        };\r\n    }\r\n\r\n    public onMethodRemoved(callback: (method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onMethodRemoved\", callback);\r\n\r\n        return unsubscribeFunc;\r\n    }\r\n\r\n    public onServerRemoved(callback: (server: Glue42Core.Interop.Instance, reason: string) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerRemoved\", callback);\r\n\r\n        return unsubscribeFunc;\r\n    }\r\n\r\n    public onServerMethodRemoved(callback: (server: Glue42Core.Interop.Instance, method: ClientMethodInfo) => void): UnsubscribeFunction {\r\n        const unsubscribeFunc = this.callbacks.add(\"onServerMethodRemoved\", callback);\r\n\r\n        return unsubscribeFunc;\r\n    }\r\n\r\n    public getServerById(id: string) {\r\n        return this.hideServerMethodSystemFlags(this.servers[id]);\r\n    }\r\n\r\n    public reset() {\r\n        Object.keys(this.servers).forEach((key) => {\r\n            this.removeServerById(key, \"reset\");\r\n        });\r\n        this.servers = {\r\n            [this.myServer.id]: this.myServer\r\n        };\r\n        this.methodsCount = {};\r\n    }\r\n\r\n    private createMethodIdentifier(methodInfo: MethodInfoMessage) {\r\n        // Setting properties to defaults:\r\n        const accepts = methodInfo.input_signature !== undefined ? methodInfo.input_signature : \"\";\r\n        const returns = methodInfo.result_signature !== undefined ? methodInfo.result_signature : \"\";\r\n        return (methodInfo.name + accepts + returns).toLowerCase();\r\n    }\r\n\r\n    private getServersByMethod(identifier: string): Glue42Core.AGM.Instance[] {\r\n        const allServers: Glue42Core.AGM.Instance[] = [];\r\n        Object.values(this.servers).forEach((server) => {\r\n            Object.values(server.methods).forEach((method) => {\r\n                if (method.identifier === identifier) {\r\n                    allServers.push(server.instance);\r\n                }\r\n            });\r\n        });\r\n        return allServers;\r\n    }\r\n\r\n    // collectionToReplay: because we need a snapshot before we exist this stack\r\n    private returnUnsubWithDelayedReplay(unsubscribeFunc: UnsubscribeFunction, collectionToReplay: any[], callback: any) {\r\n\r\n        // because we want to interrupt the loop with the existing methods\r\n        let unsubCalled = false;\r\n\r\n        // because we want to have the unsub function before the callback is called with all existing methods\r\n        setTimeout(() => {\r\n            collectionToReplay.forEach((item) => {\r\n                if (!unsubCalled) {\r\n                    callback(item);\r\n                }\r\n            });\r\n        }, 0);\r\n\r\n        return () => {\r\n            unsubCalled = true;\r\n            unsubscribeFunc();\r\n        };\r\n    }\r\n\r\n    private hideServerMethodSystemFlags(server: ServerInfo): ServerInfo {\r\n        const clientMethods: { [name: string]: ClientMethodInfo } = {};\r\n\r\n        Object.entries(server.methods).forEach(([name, method]) => {\r\n            clientMethods[name] = hideMethodSystemFlags(method);\r\n        });\r\n\r\n        return {\r\n            ...server,\r\n            methods: clientMethods\r\n        };\r\n    }\r\n\r\n    private extractMethodsFromServers(servers: ServerInfo[]): ClientMethodInfo[] {\r\n        const methods = Object.values(servers).reduce<ClientMethodInfo[]>((clientMethods, server) => {\r\n            return [...clientMethods, ...Object.values(server.methods)];\r\n        }, []);\r\n\r\n        return methods;\r\n    }\r\n}\r\n","/*\r\n * A store for holding method back-objects registered by this instance's server\r\n */\r\nimport { ServerMethodInfo } from \"./types\";\r\n\r\nexport default class ServerRepository {\r\n\r\n    private nextId = 0;\r\n    private methods: ServerMethodInfo[] = [];\r\n\r\n    public add(method: Partial<ServerMethodInfo>): ServerMethodInfo {\r\n        method.repoId = String(this.nextId);\r\n        this.nextId += 1;\r\n        this.methods.push(method as ServerMethodInfo);\r\n        return method as ServerMethodInfo;\r\n    }\r\n\r\n    public remove(repoId: string) {\r\n        if (typeof repoId !== \"string\") {\r\n            return new TypeError(\"Expecting a string\");\r\n        }\r\n\r\n        this.methods = this.methods.filter((m) => {\r\n            return m.repoId !== repoId;\r\n        });\r\n    }\r\n\r\n    public getById(id: string): ServerMethodInfo | undefined {\r\n        if (typeof id !== \"string\") {\r\n            return undefined;\r\n        }\r\n\r\n        return this.methods.find((m) => {\r\n            return m.repoId === id;\r\n        });\r\n    }\r\n\r\n    public getList() {\r\n        return this.methods.map((m) => m);\r\n    }\r\n\r\n    public length() {\r\n        return this.methods.length;\r\n    }\r\n\r\n    public reset() {\r\n        this.methods = [];\r\n    }\r\n}\r\n","import { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport { RequestContext, ServerMethodInfo, ServerSubscriptionInfo } from \"../../server/types\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport ServerRepository from \"../../server/repository\";\r\nimport {\r\n    AddInterestMessage,\r\n    PublishMessage,\r\n    PostMessage,\r\n    DropSubscriptionMessage,\r\n    RemoveInterestMessage\r\n} from \"./messages\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport { Logger } from \"../../../logger/logger\";\r\n\r\nconst SUBSCRIPTION_REQUEST = \"onSubscriptionRequest\";\r\nconst SUBSCRIPTION_ADDED = \"onSubscriptionAdded\";\r\nconst SUBSCRIPTION_REMOVED = \"onSubscriptionRemoved\";\r\n\r\n/**\r\n * Handles registering methods and sending data to clients\r\n */\r\nexport default class ServerStreaming {\r\n\r\n    private ERR_URI_SUBSCRIPTION_FAILED = \"com.tick42.agm.errors.subscription.failure\";\r\n    private callbacks = CallbackRegistryFactory();\r\n    private nextStreamId = 0;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private repository: ClientRepository, private serverRepository: ServerRepository) {\r\n        session.on(\"add-interest\", (msg: AddInterestMessage) => {\r\n            this.handleAddInterest(msg);\r\n        });\r\n        session.on(\"remove-interest\", (msg: RemoveInterestMessage) => {\r\n            this.handleRemoveInterest(msg);\r\n        });\r\n    }\r\n\r\n    public acceptRequestOnBranch(requestContext: RequestContext, streamingMethod: ServerMethodInfo, branch: string) {\r\n        if (typeof branch !== \"string\") {\r\n            branch = \"\";\r\n        }\r\n\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            throw new TypeError(\"The streaming method is missing its subscriptions.\");\r\n        }\r\n\r\n        if (!Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            throw new TypeError(\"The streaming method is missing its branches.\");\r\n        }\r\n\r\n        const streamId = this.getStreamId(streamingMethod, branch);\r\n\r\n        // Add a new subscription to the method\r\n        const key = requestContext.msg.subscription_id;\r\n\r\n        const subscription: ServerSubscriptionInfo = {\r\n            id: key,\r\n            arguments: requestContext.arguments,\r\n            instance: requestContext.instance,\r\n            branchKey: branch,\r\n            streamId,\r\n            subscribeMsg: requestContext.msg,\r\n        };\r\n\r\n        streamingMethod.protocolState.subscriptionsMap[key] = subscription;\r\n\r\n        // Inform the gw\r\n        this.session.sendFireAndForget({\r\n            type: \"accepted\",\r\n            subscription_id: key,\r\n            stream_id: streamId,\r\n        });\r\n\r\n        // Pass state above-protocol for user objects\r\n        this.callbacks.execute(SUBSCRIPTION_ADDED, subscription, streamingMethod);\r\n    }\r\n\r\n    public rejectRequest(requestContext: RequestContext, streamingMethod: ServerMethodInfo, reason: string) {\r\n        if (typeof reason !== \"string\") {\r\n            reason = \"\";\r\n        }\r\n\r\n        this.sendSubscriptionFailed(\r\n            \"Subscription rejected by user. \" + reason,\r\n            requestContext.msg.subscription_id,\r\n        );\r\n    }\r\n\r\n    public pushData(streamingMethod: ServerMethodInfo, data: object, branches: string | string[]) {\r\n        if (typeof streamingMethod !== \"object\" || !Array.isArray(streamingMethod.protocolState.branchKeyToStreamIdMap)) {\r\n            return;\r\n        }\r\n\r\n        // TODO validate data is a plain object\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n\r\n        if (typeof branches === \"string\") {\r\n            branches = [branches]; // user wants to push to single branch\r\n        } else if (!Array.isArray(branches) || branches.length <= 0) {\r\n            branches = [];\r\n        }\r\n\r\n        // get the StreamId's from the method's branch map\r\n        const streamIdList = streamingMethod.protocolState.branchKeyToStreamIdMap\r\n            .filter((br) => {\r\n                if (!branches || branches.length === 0) {\r\n                    return true;\r\n                }\r\n                return branches.indexOf(br.key) >= 0;\r\n            }).map((br) => {\r\n                return br.streamId;\r\n            });\r\n\r\n        // if (streamIdList.length === 0) {\r\n        //     throw new Error(\"0 branches exist with the supplied name/s !\");\r\n        // }\r\n\r\n        streamIdList.forEach((streamId) => {\r\n            const publishMessage: PublishMessage = {\r\n                type: \"publish\",\r\n                stream_id: streamId,\r\n                // sequence: null,  // the streamingMethod might be used for this\r\n                // snapshot: false, // ...and this\r\n                data,\r\n            };\r\n\r\n            this.session.sendFireAndForget(publishMessage);\r\n        });\r\n    }\r\n\r\n    public pushDataToSingle(method: ServerMethodInfo, subscription: ServerSubscriptionInfo, data: object) {\r\n        // TODO validate data is a plain object\r\n        if (typeof data !== \"object\") {\r\n            throw new Error(\"Invalid arguments. Data must be an object.\");\r\n        }\r\n\r\n        const postMessage: PostMessage = {\r\n            type: \"post\",\r\n            subscription_id: subscription.id,\r\n            // sequence: null,  // the streamingMethod might be used for this\r\n            // snapshot: false, // ...and this\r\n            data,\r\n        };\r\n\r\n        this.session.sendFireAndForget(postMessage);\r\n    }\r\n\r\n    public closeSingleSubscription(streamingMethod: ServerMethodInfo, subscription: ServerSubscriptionInfo) {\r\n\r\n        if (streamingMethod.protocolState.subscriptionsMap) {\r\n            delete streamingMethod.protocolState.subscriptionsMap[subscription.id];\r\n        }\r\n\r\n        const dropSubscriptionMessage: DropSubscriptionMessage = {\r\n            type: \"drop-subscription\",\r\n            subscription_id: subscription.id,\r\n            reason: \"Server dropping a single subscription\",\r\n        };\r\n\r\n        this.session.sendFireAndForget(dropSubscriptionMessage);\r\n\r\n        const subscriber = subscription.instance;\r\n\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    }\r\n\r\n    public closeMultipleSubscriptions(streamingMethod: ServerMethodInfo, branchKey?: string) {\r\n        if (typeof streamingMethod !== \"object\" || typeof streamingMethod.protocolState.subscriptionsMap !== \"object\") {\r\n            return;\r\n        }\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return;\r\n        }\r\n\r\n        const subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n        let subscriptionsToClose = Object.keys(subscriptionsMap)\r\n            .map((key) => {\r\n                return subscriptionsMap[key];\r\n            });\r\n\r\n        if (typeof branchKey === \"string\") {\r\n            subscriptionsToClose = subscriptionsToClose.filter((sub) => {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n\r\n        subscriptionsToClose.forEach((subscription) => {\r\n            delete subscriptionsMap[subscription.id];\r\n\r\n            const drop: DropSubscriptionMessage = {\r\n                type: \"drop-subscription\",\r\n                subscription_id: subscription.id,\r\n                reason: \"Server dropping all subscriptions on stream_id: \" + subscription.streamId,\r\n            };\r\n            this.session.sendFireAndForget(drop);\r\n        });\r\n    }\r\n\r\n    public getSubscriptionList(streamingMethod: ServerMethodInfo, branchKey?: string): ServerSubscriptionInfo[] {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n\r\n        let subscriptions = [];\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return [];\r\n        }\r\n        const subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n\r\n        const allSubscriptions = Object.keys(subscriptionsMap)\r\n            .map((key) => {\r\n                return subscriptionsMap[key];\r\n            });\r\n\r\n        if (typeof branchKey !== \"string\") {\r\n            subscriptions = allSubscriptions;\r\n        } else {\r\n            subscriptions = allSubscriptions.filter((sub) => {\r\n                return sub.branchKey === branchKey;\r\n            });\r\n        }\r\n\r\n        return subscriptions;\r\n    }\r\n\r\n    public getBranchList(streamingMethod: ServerMethodInfo): string[] {\r\n        if (typeof streamingMethod !== \"object\") {\r\n            return [];\r\n        }\r\n\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return [];\r\n        }\r\n        const subscriptionsMap = streamingMethod.protocolState.subscriptionsMap;\r\n\r\n        const allSubscriptions =\r\n            Object.keys(subscriptionsMap)\r\n                .map((key) => {\r\n                    return subscriptionsMap[key];\r\n                });\r\n\r\n        const result: string[] = [];\r\n        allSubscriptions.forEach((sub) => {\r\n            let branch = \"\";\r\n            if (typeof sub === \"object\" && typeof sub.branchKey === \"string\") {\r\n                branch = sub.branchKey;\r\n            }\r\n\r\n            if (result.indexOf(branch) === -1) {\r\n                result.push(branch);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    public onSubAdded(callback: (subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_ADDED, callback);\r\n    }\r\n\r\n    public onSubRequest(callback: (requestContext: RequestContext, repoMethod: ServerMethodInfo) => void) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REQUEST, callback);\r\n    }\r\n\r\n    public onSubRemoved(callback: (subscriber: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void) {\r\n        this.onSubscriptionLifetimeEvent(SUBSCRIPTION_REMOVED, callback);\r\n    }\r\n\r\n    private handleRemoveInterest(msg: RemoveInterestMessage) {\r\n        const streamingMethod = this.serverRepository.getById(msg.method_id);\r\n\r\n        if (typeof msg.subscription_id !== \"string\" ||\r\n            typeof streamingMethod !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        if (!streamingMethod.protocolState.subscriptionsMap) {\r\n            return;\r\n        }\r\n\r\n        if (typeof streamingMethod.protocolState.subscriptionsMap[msg.subscription_id] !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        const subscription = streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n\r\n        delete streamingMethod.protocolState.subscriptionsMap[msg.subscription_id];\r\n\r\n        this.callbacks.execute(SUBSCRIPTION_REMOVED, subscription, streamingMethod);\r\n    }\r\n\r\n    private onSubscriptionLifetimeEvent(eventName: string, handlerFunc: any) {\r\n        this.callbacks.add(eventName, handlerFunc);\r\n    }\r\n\r\n    private getNextStreamId(): string {\r\n        return this.nextStreamId++ + \"\";\r\n    }\r\n\r\n    /**\r\n     * Processes a subscription request\r\n     */\r\n    private handleAddInterest(msg: AddInterestMessage) {\r\n\r\n        const caller = this.repository.getServerById(msg.caller_id);\r\n        const instance = caller.instance;\r\n\r\n        // call subscriptionRequestHandler\r\n        const requestContext: RequestContext = {\r\n            msg,\r\n            arguments: msg.arguments_kv || {},\r\n            instance,\r\n        };\r\n\r\n        const streamingMethod = this.serverRepository.getById(msg.method_id);\r\n\r\n        if (streamingMethod === undefined) {\r\n            const errorMsg = \"No method with id \" + msg.method_id + \" on this server.\";\r\n            this.sendSubscriptionFailed(errorMsg, msg.subscription_id);\r\n            return;\r\n        }\r\n\r\n        if (streamingMethod.protocolState.subscriptionsMap &&\r\n            streamingMethod.protocolState.subscriptionsMap[msg.subscription_id]) {\r\n            this.sendSubscriptionFailed(\"A subscription with id \" + msg.subscription_id + \" already exists.\",\r\n                msg.subscription_id,\r\n            );\r\n            return;\r\n        }\r\n\r\n        this.callbacks.execute(SUBSCRIPTION_REQUEST, requestContext, streamingMethod);\r\n    }\r\n\r\n    private sendSubscriptionFailed(reason: string, subscriptionId: string) {\r\n        const errorMessage = {\r\n            type: \"error\",\r\n            reason_uri: this.ERR_URI_SUBSCRIPTION_FAILED,\r\n            reason,\r\n            request_id: subscriptionId, // this overrides connection wrapper\r\n        };\r\n\r\n        this.session.sendFireAndForget(errorMessage);\r\n    }\r\n\r\n    private getStreamId(streamingMethod: ServerMethodInfo, branchKey: string) {\r\n        if (typeof branchKey !== \"string\") {\r\n            branchKey = \"\";\r\n        }\r\n\r\n        if (!streamingMethod.protocolState.branchKeyToStreamIdMap) {\r\n            throw new Error(`streaming ${streamingMethod.definition.name} method without protocol state`);\r\n        }\r\n\r\n        const needleBranch = streamingMethod.protocolState.branchKeyToStreamIdMap.filter((branch) => {\r\n            return branch.key === branchKey;\r\n        })[0];\r\n\r\n        let streamId = (needleBranch ? needleBranch.streamId : undefined);\r\n\r\n        if (typeof streamId !== \"string\" || streamId === \"\") {\r\n            streamId = this.getNextStreamId();\r\n            streamingMethod.protocolState.branchKeyToStreamIdMap.push({ key: branchKey, streamId });\r\n        }\r\n\r\n        return streamId;\r\n    }\r\n}\r\n","import { default as CallbackRegistryFactory, CallbackRegistry } from \"callback-registry\";\r\nimport ServerStreaming from \"./server-streaming\";\r\nimport {\r\n    InvokeMessage,\r\n    RegisterMethodMessage,\r\n    ErrorMessage,\r\n    YieldMessage,\r\n    UnregisterMessage,\r\n    TaggedMessage\r\n} from \"./messages\";\r\nimport ServerRepository from \"../../server/repository\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport { ServerMethodInfo, ResultContext, ServerSubscriptionInfo, RequestContext } from \"../../server/types\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport { ServerProtocolDefinition } from \"../../types\";\r\nimport { Logger } from \"../../../logger/logger\";\r\n\r\nexport default class ServerProtocol implements ServerProtocolDefinition {\r\n    private callbacks: CallbackRegistry = CallbackRegistryFactory();\r\n    private streaming: ServerStreaming;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private clientRepository: ClientRepository, private serverRepository: ServerRepository, private logger: Logger) {\r\n        this.streaming = new ServerStreaming(session, clientRepository, serverRepository);\r\n        this.session.on(\"invoke\", (msg: InvokeMessage) => this.handleInvokeMessage(msg));\r\n    }\r\n\r\n    public createStream(repoMethod: ServerMethodInfo): Promise<void> {\r\n        // Utility things for this protocol\r\n        repoMethod.protocolState.subscriptionsMap = {}; // ~subscription_id~ : {id:~, branchKey: '~', arguments: {~}, instance:{~}, etc.}\r\n        repoMethod.protocolState.branchKeyToStreamIdMap = []; // [ {branchKey: '', streamId: 7}, {...}, ...]\r\n\r\n        return this.register(repoMethod, true);\r\n    }\r\n\r\n    public register(repoMethod: ServerMethodInfo, isStreaming?: boolean): Promise<void> {\r\n        const methodDef = repoMethod.definition;\r\n        const flags = Object.assign({}, { metadata: methodDef.flags ?? {} }, { streaming: isStreaming || false });\r\n\r\n        const registerMsg: RegisterMethodMessage = {\r\n            type: \"register\",\r\n            methods: [{\r\n                id: repoMethod.repoId,\r\n                name: methodDef.name,\r\n                display_name: methodDef.displayName,\r\n                description: methodDef.description,\r\n                version: methodDef.version,\r\n                flags,\r\n                object_types: methodDef.objectTypes || (methodDef as any).object_types, // object_type for backward compatibility\r\n                input_signature: methodDef.accepts,\r\n                result_signature: methodDef.returns,\r\n                restrictions: undefined,\r\n            }],\r\n        };\r\n\r\n        return this.session.send(registerMsg, { methodId: repoMethod.repoId })\r\n            .then(() => {\r\n                this.logger.debug(\"registered method \" + repoMethod.definition.name + \" with id \" + repoMethod.repoId);\r\n            })\r\n            .catch((msg: ErrorMessage) => {\r\n                this.logger.warn(`failed to register method ${repoMethod.definition.name} with id ${repoMethod.repoId} - ${JSON.stringify(msg)}`);\r\n                throw msg;\r\n            });\r\n    }\r\n\r\n    public onInvoked(callback: (methodToExecute: ServerMethodInfo, invocationId: string, invocationArgs: ResultContext) => void) {\r\n        this.callbacks.add(\"onInvoked\", callback);\r\n    }\r\n\r\n    public methodInvocationResult(method: ServerMethodInfo, invocationId: string, err: string, result: object) {\r\n        let msg: YieldMessage | ErrorMessage;\r\n        if (err || err === \"\") {\r\n            msg = {\r\n                type: \"error\",\r\n                request_id: invocationId,\r\n                reason_uri: \"agm.errors.client_error\",\r\n                reason: err,\r\n                context: result,\r\n                peer_id: undefined,\r\n            };\r\n        } else {\r\n            msg = {\r\n                type: \"yield\",\r\n                invocation_id: invocationId,\r\n                peer_id: this.session.peerId,\r\n                result,\r\n                request_id: undefined,\r\n            };\r\n        }\r\n        this.session.sendFireAndForget(msg);\r\n    }\r\n\r\n    public async unregister(method: ServerMethodInfo): Promise<void> {\r\n        const msg: UnregisterMessage = {\r\n            type: \"unregister\",\r\n            methods: [method.repoId],\r\n        };\r\n\r\n        await this.session.send(msg);\r\n    }\r\n\r\n    public getBranchList(method: ServerMethodInfo): string[] {\r\n        return this.streaming.getBranchList(method);\r\n    }\r\n\r\n    public getSubscriptionList(method: ServerMethodInfo, branchKey?: string): ServerSubscriptionInfo[] {\r\n        return this.streaming.getSubscriptionList(method, branchKey);\r\n    }\r\n\r\n    public closeAllSubscriptions(method: ServerMethodInfo, branchKey?: string): void {\r\n        this.streaming.closeMultipleSubscriptions(method, branchKey);\r\n    }\r\n\r\n    public pushData(method: ServerMethodInfo, data: object, branches: string[]): void {\r\n        this.streaming.pushData(method, data, branches);\r\n    }\r\n\r\n    public pushDataToSingle(method: ServerMethodInfo, subscription: ServerSubscriptionInfo, data: object): void {\r\n        this.streaming.pushDataToSingle(method, subscription, data);\r\n    }\r\n\r\n    public closeSingleSubscription(method: ServerMethodInfo, subscription: ServerSubscriptionInfo): void {\r\n        this.streaming.closeSingleSubscription(method, subscription);\r\n    }\r\n\r\n    public acceptRequestOnBranch(requestContext: RequestContext, method: ServerMethodInfo, branch: string): void {\r\n        this.streaming.acceptRequestOnBranch(requestContext, method, branch);\r\n    }\r\n\r\n    public rejectRequest(requestContext: RequestContext, method: ServerMethodInfo, reason: string): void {\r\n        this.streaming.rejectRequest(requestContext, method, reason);\r\n    }\r\n\r\n    public onSubRequest(callback: (requestContext: RequestContext, repoMethod: ServerMethodInfo) => void): void {\r\n        this.streaming.onSubRequest(callback);\r\n    }\r\n\r\n    public onSubAdded(callback: (subscription: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void): void {\r\n        this.streaming.onSubAdded(callback);\r\n    }\r\n\r\n    public onSubRemoved(callback: (subscriber: ServerSubscriptionInfo, repoMethod: ServerMethodInfo) => void): void {\r\n        this.streaming.onSubRemoved(callback);\r\n    }\r\n\r\n    private handleInvokeMessage(msg: InvokeMessage) {\r\n        const invocationId = msg.invocation_id;\r\n        const callerId = msg.caller_id;\r\n        const methodId = msg.method_id;\r\n        const args = msg.arguments_kv;\r\n        const methodList = this.serverRepository.getList();\r\n\r\n        const method = methodList.filter((m) => {\r\n            return m.repoId === methodId;\r\n        })[0];\r\n\r\n        // Stop if the message isn't for us\r\n        if (method === undefined) {\r\n            return;\r\n        }\r\n\r\n        const client = this.clientRepository.getServerById(callerId).instance;\r\n        const invocationArgs = { args, instance: client };\r\n\r\n        this.callbacks.execute(\"onInvoked\", method, invocationId, invocationArgs);\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport { SubscriptionInner } from \"../../types\";\r\nimport ClientRepository from \"../../client/repository\";\r\n\r\nexport class UserSubscription implements Glue42Core.Interop.Subscription {\r\n    public get requestArguments() {\r\n        return this.subscriptionData.params.arguments || {};\r\n    }\r\n\r\n    public get servers(): Glue42Core.Interop.Instance[] {\r\n        return this.subscriptionData.trackedServers\r\n            .filter((pair) => pair.subscriptionId)\r\n            .map((pair) => this.repository.getServerById(pair.serverId).instance);\r\n    }\r\n\r\n    public get serverInstance(): Glue42Core.Interop.Instance {\r\n        return this.servers[0];\r\n    }\r\n\r\n    public get stream(): Glue42Core.Interop.MethodDefinition {\r\n        return this.subscriptionData.method;\r\n    }\r\n\r\n    constructor(private repository: ClientRepository, private subscriptionData: SubscriptionInner) {\r\n    }\r\n\r\n    public onData(dataCallback: (data: Glue42Core.Interop.StreamData) => void): void {\r\n        if (typeof dataCallback !== \"function\") {\r\n            throw new TypeError(\"The data callback must be a function.\");\r\n        }\r\n\r\n        this.subscriptionData.handlers.onData.push(dataCallback);\r\n        if (this.subscriptionData.handlers.onData.length === 1 && this.subscriptionData.queued.data.length > 0) {\r\n            this.subscriptionData.queued.data.forEach((dataItem) => {\r\n                dataCallback(dataItem);\r\n            });\r\n        }\r\n    }\r\n\r\n    public onClosed(closedCallback: (info: Glue42Core.Interop.OnClosedInfo) => void): void {\r\n        if (typeof closedCallback !== \"function\") {\r\n            throw new TypeError(\"The callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onClosed.push(closedCallback);\r\n    }\r\n\r\n    public onFailed(callback: (err: any) => void): void {\r\n        // DO NOTHING\r\n    }\r\n\r\n    public onConnected(callback: (server: Glue42Core.Interop.Instance, reconnect: boolean) => void): void {\r\n        if (typeof callback !== \"function\") {\r\n            throw new TypeError(\"The callback must be a function.\");\r\n        }\r\n        this.subscriptionData.handlers.onConnected.push(callback);\r\n    }\r\n\r\n    public close(): void {\r\n        this.subscriptionData.close();\r\n    }\r\n\r\n    public setNewSubscription(newSub: SubscriptionInner) {\r\n        this.subscriptionData = newSub;\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../../../glue\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport { ServerMethodsPair } from \"../../client/types\";\r\nimport * as GW3Messages from \"./messages\";\r\nimport { SubscriptionCancelledMessage, EventMessage, SubscribedMessage, ErrorSubscribingMessage } from \"./messages\";\r\nimport { SubscribeError, SubscriptionInner } from \"../../types\";\r\nimport { Logger } from \"../../../logger/logger\";\r\nimport { UserSubscription } from \"./subscription\";\r\n\r\nconst STATUS_AWAITING_ACCEPT = \"awaitingAccept\"; // not even one server has accepted yet\r\nconst STATUS_SUBSCRIBED = \"subscribed\"; // at least one server has responded as 'Accepting'\r\nconst ERR_MSG_SUB_FAILED = \"Subscription failed.\";\r\nconst ERR_MSG_SUB_REJECTED = \"Subscription rejected.\";\r\nconst ON_CLOSE_MSG_SERVER_INIT = \"ServerInitiated\";\r\nconst ON_CLOSE_MSG_CLIENT_INIT = \"ClientInitiated\";\r\n\r\n/**\r\n * Handles registering methods and sending data to clients\r\n */\r\nexport default class ClientStreaming {\r\n\r\n    private subscriptionsList: { [key: number]: SubscriptionInner } = {};\r\n    private subscriptionIdToLocalKeyMap: { [key: string]: number } = {};\r\n    private nextSubLocalKey = 0;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private repository: ClientRepository, private logger: Logger) {\r\n        session.on(\"subscribed\", this.handleSubscribed);\r\n        session.on(\"event\", this.handleEventData);\r\n        session.on(\"subscription-cancelled\", this.handleSubscriptionCancelled);\r\n    }\r\n\r\n    public subscribe(streamingMethod: Glue42Core.AGM.MethodDefinition, params: Glue42Core.AGM.SubscriptionParams, targetServers: ServerMethodsPair[], success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: SubscribeError) => void, existingSub: SubscriptionInner) {\r\n        if (targetServers.length === 0) {\r\n            error({\r\n                method: streamingMethod,\r\n                called_with: params.arguments,\r\n                message: ERR_MSG_SUB_FAILED + \" No available servers matched the target params.\",\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Note: used to find the subscription in subList. Do not confuse it with the gw-generated subscription_id\r\n        const subLocalKey = this.getNextSubscriptionLocalKey();\r\n\r\n        const pendingSub = this.registerSubscription(\r\n            subLocalKey,\r\n            streamingMethod,\r\n            params,\r\n            success,\r\n            error,\r\n            params.methodResponseTimeout || 10000,\r\n            existingSub\r\n        );\r\n\r\n        if (typeof pendingSub !== \"object\") {\r\n            error({\r\n                method: streamingMethod,\r\n                called_with: params.arguments,\r\n                message: ERR_MSG_SUB_FAILED + \" Unable to register the user callbacks.\",\r\n            });\r\n            return;\r\n        }\r\n\r\n        targetServers.forEach((target) => {\r\n\r\n            const serverId = target.server.id;\r\n            const method = target.methods.find((m) => m.name === streamingMethod.name);\r\n\r\n            if (!method) {\r\n                this.logger.error(`can not find method ${streamingMethod.name} for target ${target.server.id}`);\r\n                return;\r\n            }\r\n\r\n            pendingSub.trackedServers.push({\r\n                serverId,\r\n                subscriptionId: undefined,\r\n            });\r\n\r\n            const msg: GW3Messages.SubscribeMessage = {\r\n                type: \"subscribe\",\r\n                server_id: serverId,\r\n                method_id: method.gatewayId,\r\n                arguments_kv: params.arguments,\r\n            };\r\n\r\n            this.session.send<SubscribedMessage>(msg, { serverId, subLocalKey })\r\n                .then((m: SubscribedMessage) => this.handleSubscribed(m))\r\n                .catch((err: ErrorSubscribingMessage) => this.handleErrorSubscribing(err));\r\n        });\r\n    }\r\n\r\n    public drainSubscriptions() {\r\n        const existing = Object.values(this.subscriptionsList);\r\n        this.subscriptionsList = {};\r\n        this.subscriptionIdToLocalKeyMap = {};\r\n        return existing;\r\n    }\r\n\r\n    private getNextSubscriptionLocalKey() {\r\n        const current = this.nextSubLocalKey;\r\n        this.nextSubLocalKey += 1;\r\n        return current;\r\n    }\r\n\r\n    // This adds subscription and after timeout (30000 default) removes it if it isn't STATUS_SUBSCRIBED\r\n    private registerSubscription(subLocalKey: number, method: Glue42Core.AGM.MethodDefinition, params: Glue42Core.Interop.SubscriptionParams, success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: SubscribeError) => void, timeout: number, existingSub: SubscriptionInner) {\r\n        const subsInfo: SubscriptionInner = {\r\n            localKey: subLocalKey,\r\n            status: STATUS_AWAITING_ACCEPT,\r\n            method,\r\n            params,\r\n            success,\r\n            error,\r\n            trackedServers: [],\r\n            handlers: {\r\n                onData: existingSub?.handlers.onData || [],\r\n                onClosed: existingSub?.handlers.onClosed || [],\r\n                onConnected: existingSub?.handlers.onConnected || [],\r\n                // onFailed: []\r\n            },\r\n            queued: {\r\n                data: [],\r\n                closers: [],\r\n            },\r\n            timeoutId: undefined,\r\n            close: () => this.closeSubscription(subLocalKey),\r\n            subscription: existingSub?.subscription // only when re-connecting\r\n        };\r\n\r\n        if (!existingSub) {\r\n            if (params.onData) {\r\n                subsInfo.handlers.onData.push(params.onData);\r\n            }\r\n            if (params.onClosed) {\r\n                subsInfo.handlers.onClosed.push(params.onClosed);\r\n            }\r\n            if (params.onConnected) {\r\n                subsInfo.handlers.onConnected.push(params.onConnected);\r\n            }\r\n        }\r\n\r\n        this.subscriptionsList[subLocalKey] = subsInfo;\r\n\r\n        subsInfo.timeoutId = setTimeout(() => {\r\n            if (this.subscriptionsList[subLocalKey] === undefined) {\r\n                return; // no such subscription\r\n            }\r\n\r\n            const pendingSub = this.subscriptionsList[subLocalKey];\r\n\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                error({\r\n                    method,\r\n                    called_with: params.arguments,\r\n                    message: ERR_MSG_SUB_FAILED + \" Subscription attempt timed out after \" + timeout + \" ms.\",\r\n                });\r\n\r\n                // None of the target servers has answered the subscription attempt\r\n                delete this.subscriptionsList[subLocalKey];\r\n\r\n            } else if (pendingSub.status === STATUS_SUBSCRIBED && pendingSub.trackedServers.length > 0) {\r\n                // Clean the trackedServers, removing those without valid streamId\r\n                pendingSub.trackedServers = pendingSub.trackedServers.filter((server) => {\r\n                    return (typeof server.subscriptionId !== \"undefined\");\r\n                });\r\n\r\n                delete pendingSub.timeoutId;\r\n\r\n                if (pendingSub.trackedServers.length <= 0) {\r\n                    // There are no open streams, some servers accepted then closed very quickly\r\n                    //  (that's why the status changed but there's no good server with a StreamId)\r\n\r\n                    // call the onClosed handlers\r\n                    this.callOnClosedHandlers(pendingSub);\r\n\r\n                    delete this.subscriptionsList[subLocalKey];\r\n                }\r\n            }\r\n        }, timeout);\r\n\r\n        return subsInfo;\r\n    }\r\n\r\n    private handleErrorSubscribing = (errorResponse: ErrorSubscribingMessage) => {\r\n        const tag = errorResponse._tag;\r\n        const subLocalKey = tag.subLocalKey;\r\n        const pendingSub = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof pendingSub !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        pendingSub.trackedServers = pendingSub.trackedServers.filter((server) => {\r\n            return server.serverId !== tag.serverId;\r\n        });\r\n\r\n        if (pendingSub.trackedServers.length <= 0) {\r\n            clearTimeout(pendingSub.timeoutId);\r\n\r\n            if (pendingSub.status === STATUS_AWAITING_ACCEPT) {\r\n                // Reject with reason\r\n                const reason = (typeof errorResponse.reason === \"string\" && errorResponse.reason !== \"\") ?\r\n                    ' Publisher said \"' + errorResponse.reason + '\".' :\r\n                    \" No reason given.\";\r\n\r\n                const callArgs = typeof pendingSub.params.arguments === \"object\" ?\r\n                    JSON.stringify(pendingSub.params.arguments) :\r\n                    \"{}\";\r\n\r\n                pendingSub.error({\r\n                    message: ERR_MSG_SUB_REJECTED + reason + \" Called with:\" + callArgs,\r\n                    called_with: pendingSub.params.arguments,\r\n                    method: pendingSub.method,\r\n                });\r\n\r\n            } else if (pendingSub.status === STATUS_SUBSCRIBED) {\r\n                // The timeout may or may not have expired yet,\r\n                // but the status is 'subscribed' and trackedServers is now empty\r\n\r\n                this.callOnClosedHandlers(pendingSub);\r\n            }\r\n\r\n            delete this.subscriptionsList[subLocalKey];\r\n        }\r\n    }\r\n\r\n    private handleSubscribed = (msg: SubscribedMessage) => {\r\n        const subLocalKey = msg._tag.subLocalKey;\r\n        const pendingSub = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof pendingSub !== \"object\") {\r\n            return;\r\n        }\r\n        const serverId = msg._tag.serverId;\r\n\r\n        // Add a subscription_id to this trackedServer\r\n\r\n        const acceptingServer = pendingSub.trackedServers\r\n            .filter((server) => {\r\n                return server.serverId === serverId;\r\n            })[0];\r\n\r\n        if (typeof acceptingServer !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        acceptingServer.subscriptionId = msg.subscription_id;\r\n        this.subscriptionIdToLocalKeyMap[msg.subscription_id] = subLocalKey;\r\n\r\n        const isFirstResponse = (pendingSub.status === STATUS_AWAITING_ACCEPT);\r\n\r\n        pendingSub.status = STATUS_SUBSCRIBED;\r\n\r\n        if (isFirstResponse) {\r\n            let reconnect: boolean = false;\r\n            let sub = pendingSub.subscription;\r\n            if (sub) {\r\n                // re-connect case, we already have subscription object\r\n                sub.setNewSubscription(pendingSub);\r\n                pendingSub.success(sub);\r\n                reconnect = true;\r\n            } else {\r\n                sub = new UserSubscription(this.repository, pendingSub);\r\n                pendingSub.subscription = sub;\r\n                // Pass in the subscription object\r\n                pendingSub.success(sub);\r\n            }\r\n\r\n            for (const handler of pendingSub.handlers.onConnected) {\r\n                try {\r\n                    handler(sub.serverInstance, reconnect);\r\n                } catch (e) {\r\n                    // DO nothing\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private handleEventData = (msg: EventMessage) => {\r\n\r\n        const subLocalKey = this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n\r\n        if (typeof subLocalKey === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        const subscription = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        const trackedServersFound = subscription.trackedServers.filter((server) => {\r\n            return server.subscriptionId === msg.subscription_id;\r\n        });\r\n\r\n        if (trackedServersFound.length !== 1) {\r\n            return;\r\n        }\r\n\r\n        // out_of_band. (main stream band)\r\n        const isPrivateData = msg.oob;\r\n\r\n        const sendingServerId = trackedServersFound[0].serverId;\r\n\r\n        // Create the arrivedData object, new object for each handler call\r\n        const receivedStreamData = (): Glue42Core.AGM.StreamData => {\r\n            return {\r\n                data: msg.data,\r\n                server: this.repository.getServerById(sendingServerId).instance,\r\n                requestArguments: subscription.params.arguments,\r\n                message: undefined,\r\n                private: isPrivateData,\r\n            };\r\n        };\r\n\r\n        const onDataHandlers = subscription.handlers.onData;\r\n        const queuedData = subscription.queued.data;\r\n\r\n        if (onDataHandlers.length > 0) {\r\n            onDataHandlers.forEach((callback) => {\r\n                if (typeof callback === \"function\") {\r\n                    callback(receivedStreamData());\r\n                }\r\n            });\r\n        } else {\r\n            queuedData.push(receivedStreamData());\r\n        }\r\n    }\r\n\r\n    // called only on stream.close() multiple times for each subscription\r\n    private handleSubscriptionCancelled = (msg: SubscriptionCancelledMessage) => {\r\n        const subLocalKey = this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n\r\n        if (typeof subLocalKey === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        const subscription = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        // Filter tracked servers\r\n        const expectedNewLength = subscription.trackedServers.length - 1;\r\n\r\n        subscription.trackedServers = subscription.trackedServers.filter((server) => {\r\n            if (server.subscriptionId === msg.subscription_id) {\r\n                subscription.queued.closers.push(server.serverId);\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        });\r\n\r\n        // Check if a server was actually removed\r\n        if (subscription.trackedServers.length !== expectedNewLength) {\r\n            // TODO: Log some error\r\n            return;\r\n        }\r\n\r\n        // Check if this was the last remaining server\r\n        if (subscription.trackedServers.length <= 0) {\r\n            clearTimeout(subscription.timeoutId);\r\n            this.callOnClosedHandlers(subscription);\r\n            delete this.subscriptionsList[subLocalKey];\r\n        }\r\n\r\n        delete this.subscriptionIdToLocalKeyMap[msg.subscription_id];\r\n    }\r\n\r\n    private callOnClosedHandlers(subscription: SubscriptionInner, reason?: string) {\r\n\r\n        const closersCount = subscription.queued.closers.length;\r\n        const closingServerId = (closersCount > 0) ? subscription.queued.closers[closersCount - 1] : null;\r\n\r\n        let closingServer: Glue42Core.AGM.Instance;\r\n        if (closingServerId !== undefined && typeof closingServerId === \"string\") {\r\n            closingServer = this.repository.getServerById(closingServerId).instance;\r\n        }\r\n\r\n        subscription.handlers.onClosed.forEach((callback) => {\r\n            if (typeof callback !== \"function\") {\r\n                return;\r\n            }\r\n\r\n            callback({\r\n                message: reason || ON_CLOSE_MSG_SERVER_INIT,\r\n                requestArguments: subscription.params.arguments || {},\r\n                server: closingServer,\r\n                stream: subscription.method,\r\n            });\r\n        });\r\n    }\r\n\r\n    // called on client/server close (not on stream.close)\r\n    private closeSubscription(subLocalKey: number) {\r\n        const subscription = this.subscriptionsList[subLocalKey];\r\n\r\n        if (typeof subscription !== \"object\") {\r\n            return;\r\n        }\r\n\r\n        // Tell each server that we're unsubscribing\r\n        subscription.trackedServers.forEach((server) => {\r\n            if (typeof server.subscriptionId === \"undefined\") {\r\n                return;\r\n            }\r\n\r\n            subscription.queued.closers.push(server.serverId);\r\n\r\n            this.session.sendFireAndForget({\r\n                type: \"unsubscribe\",\r\n                subscription_id: server.subscriptionId,\r\n                reason_uri: \"\",\r\n                reason: ON_CLOSE_MSG_CLIENT_INIT,\r\n            });\r\n\r\n            delete this.subscriptionIdToLocalKeyMap[server.subscriptionId];\r\n        });\r\n\r\n        subscription.trackedServers = [];\r\n\r\n        this.callOnClosedHandlers(subscription, ON_CLOSE_MSG_CLIENT_INIT);\r\n\r\n        delete this.subscriptionsList[subLocalKey];\r\n    }\r\n}\r\n","import ClientStreaming from \"./client-streaming\";\r\nimport {\r\n    CallMessage,\r\n    ErrorMessage,\r\n    MethodsAddedMessage,\r\n    MethodsRemovedMessage,\r\n    PeerAddedMessage,\r\n    PeerRemovedMessage,\r\n    ResultMessage,\r\n    MethodInfoMessage\r\n} from \"./messages\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport { ClientMethodInfo, ServerInfo, ServerMethodsPair } from \"../../client/types\";\r\nimport { ClientProtocolDefinition, SubscribeError, SubscriptionInner } from \"../../types\";\r\nimport { InvokeResultMessage, InvokeStatus } from \"../../client/client\";\r\nimport { Logger } from \"../../../logger/logger\";\r\n\r\n/**\r\n * Handles session lifetime and events\r\n */\r\nexport default class ClientProtocol implements ClientProtocolDefinition {\r\n\r\n    private streaming: ClientStreaming;\r\n\r\n    constructor(private session: Glue42Core.Connection.GW3DomainSession, private repository: ClientRepository, private logger: Logger) {\r\n        session.on(\"peer-added\", (msg: PeerAddedMessage) => this.handlePeerAdded(msg));\r\n        session.on(\"peer-removed\", (msg: PeerRemovedMessage) => this.handlePeerRemoved(msg));\r\n        session.on(\"methods-added\", (msg: MethodsAddedMessage) => this.handleMethodsAddedMessage(msg));\r\n        session.on(\"methods-removed\", (msg: MethodsRemovedMessage) => this.handleMethodsRemovedMessage(msg));\r\n\r\n        this.streaming = new ClientStreaming(session, repository, logger);\r\n    }\r\n\r\n    public subscribe(stream: Glue42Core.AGM.MethodDefinition, options: Glue42Core.AGM.SubscriptionParams, targetServers: ServerMethodsPair[], success: (sub: Glue42Core.AGM.Subscription) => void, error: (err: SubscribeError) => void, existingSub: SubscriptionInner): void {\r\n        this.streaming.subscribe(stream, options, targetServers, success, error, existingSub);\r\n    }\r\n\r\n    public invoke(id: string, method: ClientMethodInfo, args: object, target: ServerInfo): Promise<InvokeResultMessage> {\r\n\r\n        const serverId = target.id;\r\n        const methodId = method.gatewayId;\r\n        const msg: CallMessage = {\r\n            type: \"call\",\r\n            server_id: serverId,\r\n            method_id: methodId,\r\n            arguments_kv: args,\r\n        };\r\n\r\n        // we transfer the invocation id as tag\r\n        return this.session.send<ResultMessage>(msg, { invocationId: id, serverId })\r\n            .then((m: ResultMessage) => this.handleResultMessage(m))\r\n            .catch((err) => this.handleInvocationError(err));\r\n    }\r\n\r\n    public drainSubscriptions(): SubscriptionInner[] {\r\n        return this.streaming.drainSubscriptions();\r\n    }\r\n\r\n    private handlePeerAdded(msg: PeerAddedMessage) {\r\n        const newPeerId = msg.new_peer_id;\r\n        const remoteId = msg.identity;\r\n        const isLocal = msg.meta ? msg.meta.local : true;\r\n        const pid = Number(remoteId.process);\r\n\r\n        const serverInfo: Glue42Core.AGM.Instance = {\r\n            machine: remoteId.machine,\r\n            pid: isNaN(pid) ? remoteId.process : pid,\r\n            instance: remoteId.instance,\r\n            application: remoteId.application,\r\n            applicationName: remoteId.applicationName,\r\n            environment: remoteId.environment,\r\n            region: remoteId.region,\r\n            user: remoteId.user,\r\n            windowId: remoteId.windowId,\r\n            peerId: newPeerId,\r\n            api: remoteId.api,\r\n            isLocal\r\n        };\r\n\r\n        this.repository.addServer(serverInfo, newPeerId);\r\n    }\r\n\r\n    private handlePeerRemoved(msg: PeerRemovedMessage) {\r\n        const removedPeerId = msg.removed_id;\r\n        const reason = msg.reason;\r\n\r\n        this.repository.removeServerById(removedPeerId, reason);\r\n    }\r\n\r\n    private handleMethodsAddedMessage(msg: MethodsAddedMessage) {\r\n        const serverId = msg.server_id;\r\n        const methods = msg.methods;\r\n\r\n        methods.forEach((method: MethodInfoMessage) => {\r\n            this.repository.addServerMethod(serverId, method);\r\n        });\r\n    }\r\n\r\n    private handleMethodsRemovedMessage(msg: MethodsRemovedMessage) {\r\n        const serverId = msg.server_id;\r\n        const methodIdList = msg.methods;\r\n\r\n        const server = this.repository.getServerById(serverId);\r\n        const serverMethodKeys = Object.keys(server.methods);\r\n\r\n        serverMethodKeys.forEach((methodKey) => {\r\n            const method = server.methods[methodKey];\r\n            if (methodIdList.indexOf(method.gatewayId) > -1) {\r\n                this.repository.removeServerMethod(serverId, methodKey);\r\n            }\r\n        });\r\n    }\r\n\r\n    private handleResultMessage(msg: ResultMessage): InvokeResultMessage {\r\n        const invocationId = msg._tag.invocationId;\r\n        const result = msg.result;\r\n        const serverId = msg._tag.serverId;\r\n        const server = this.repository.getServerById(serverId);\r\n\r\n        return {\r\n            invocationId,\r\n            result,\r\n            instance: server.instance,\r\n            status: InvokeStatus.Success,\r\n            message: \"\"\r\n        };\r\n    }\r\n\r\n    private handleInvocationError(msg: ErrorMessage | Error): InvokeResultMessage {\r\n        this.logger.debug(`handle invocation error ${JSON.stringify(msg)}`);\r\n\r\n        if (\"_tag\" in msg) {\r\n            const invocationId = msg._tag.invocationId;\r\n            const serverId = msg._tag.serverId;\r\n            const server = this.repository.getServerById(serverId);\r\n            const message = msg.reason;\r\n            const context = msg.context;\r\n\r\n            return {\r\n                invocationId,\r\n                result: context,\r\n                instance: server.instance,\r\n                status: InvokeStatus.Error,\r\n                message\r\n            };\r\n        } else {\r\n            return {\r\n                invocationId: \"\",\r\n                message: (msg as Error).message,\r\n                status: InvokeStatus.Error,\r\n                error: msg as Error\r\n            };\r\n        }\r\n    }\r\n}\r\n","import ServerProtocol from \"./server\";\r\nimport ClientProtocol from \"./client\";\r\nimport { Glue42Core } from \"../../../../glue\";\r\nimport ClientRepository from \"../../client/repository\";\r\nimport ServerRepository from \"../../server/repository\";\r\nimport Interop from \"../../interop\";\r\nimport { Protocol, InteropSettings } from \"../../types\";\r\nimport Connection from \"../../../connection/connection\";\r\n\r\nexport default function (instance: Glue42Core.AGM.Instance, connection: Connection, clientRepository: ClientRepository, serverRepository: ServerRepository, libConfig: InteropSettings, interop: Interop): Promise<Protocol> {\r\n    const logger = libConfig.logger.subLogger(\"gw3-protocol\");\r\n    let resolveReadyPromise: ((p: Protocol) => void) | undefined;\r\n\r\n    const readyPromise = new Promise<Protocol>((resolve) => {\r\n        resolveReadyPromise = resolve;\r\n    });\r\n\r\n    // start domain join handshake\r\n    const session = connection.domain(\"agm\", [\"subscribed\"]);\r\n\r\n    const server = new ServerProtocol(session, clientRepository, serverRepository, logger.subLogger(\"server\"));\r\n    const client = new ClientProtocol(session, clientRepository, logger.subLogger(\"client\"));\r\n\r\n    function handleReconnect() {\r\n        // we're reconnecting\r\n        logger.info(\"reconnected - will replay registered methods and subscriptions\");\r\n\r\n        const existingSubscriptions = client.drainSubscriptions();\r\n        for (const sub of existingSubscriptions) {\r\n            const methodInfo = sub.method;\r\n            const params = Object.assign({}, sub.params);\r\n            // remove handlers, otherwise they will be added twice\r\n            logger.info(`trying to re-subscribe to method ${methodInfo.name}`);\r\n            interop.client.subscribe(methodInfo, params, undefined, undefined, sub);\r\n        }\r\n\r\n        // server side\r\n        const registeredMethods = serverRepository.getList();\r\n        serverRepository.reset();\r\n\r\n        // replay server methods\r\n        for (const method of registeredMethods) {\r\n            const def = method.definition;\r\n            logger.info(`re-publishing method ${def.name}`);\r\n            if (method.stream) {\r\n                // streaming method\r\n                interop.server.createStream(def, method.streamCallbacks, undefined, undefined, method.stream);\r\n            } else if (method.theFunction && method.theFunction.userCallback) {\r\n                interop.register(def, method.theFunction.userCallback);\r\n            } else if (method.theFunction && method.theFunction.userCallbackAsync) {\r\n                interop.registerAsync(def, method.theFunction.userCallbackAsync);\r\n            }\r\n        }\r\n    }\r\n\r\n    function handleInitialJoin() {\r\n        if (resolveReadyPromise) {\r\n            resolveReadyPromise({\r\n                client,\r\n                server,\r\n            });\r\n\r\n            resolveReadyPromise = undefined;\r\n        }\r\n    }\r\n\r\n    session.onJoined((reconnect) => {\r\n        // add our server to the client repository\r\n        clientRepository.addServer(instance, connection.peerId);\r\n\r\n        if (reconnect) {\r\n            handleReconnect();\r\n        } else {\r\n            handleInitialJoin();\r\n        }\r\n    });\r\n\r\n    session.onLeft(() => {\r\n        // reset the client repository when the connection is down\r\n        clientRepository.reset();\r\n    });\r\n\r\n    session.join();\r\n\r\n    return readyPromise;\r\n}\r\n","import Client from \"./client/client\";\r\nimport Server from \"./server/server\";\r\nimport { Protocol, SubscribeError, InteropSettings } from \"./types\";\r\nimport { Glue42Core } from \"../../glue\";\r\nimport ClientRepository from \"./client/repository\";\r\nimport ServerRepository from \"./server/repository\";\r\nimport { UnsubscribeFunction } from \"callback-registry\";\r\nimport gW3ProtocolFactory from \"./protocols/gw3/factory\";\r\nimport { InstanceWrapper } from \"./instance\";\r\nimport { PromiseWrapper } from \"../utils/pw\";\r\n\r\nexport default class Interop implements Glue42Core.AGM.API {\r\n    public instance: Glue42Core.AGM.Instance;\r\n    public readyPromise: Promise<Interop>;\r\n\r\n    public client!: Client;\r\n    public server!: Server;\r\n    public unwrappedInstance: InstanceWrapper;\r\n    private protocol!: Protocol;\r\n    private clientRepository: ClientRepository;\r\n    private serverRepository: ServerRepository;\r\n\r\n    constructor(configuration: InteropSettings) {\r\n        if (typeof configuration === \"undefined\") {\r\n            throw new Error(\"configuration is required\");\r\n        }\r\n\r\n        if (typeof configuration.connection === \"undefined\") {\r\n            throw new Error(\"configuration.connections is required\");\r\n        }\r\n\r\n        const connection = configuration.connection;\r\n\r\n        if (typeof configuration.methodResponseTimeout !== \"number\") {\r\n            configuration.methodResponseTimeout = 30 * 1000;\r\n        }\r\n        if (typeof configuration.waitTimeoutMs !== \"number\") {\r\n            configuration.waitTimeoutMs = 30 * 1000;\r\n        }\r\n\r\n        // Initialize our modules\r\n        this.unwrappedInstance = new InstanceWrapper(this, undefined, connection);\r\n        this.instance = this.unwrappedInstance.unwrap();\r\n        this.clientRepository = new ClientRepository(configuration.logger.subLogger(\"cRep\"), this);\r\n        this.serverRepository = new ServerRepository();\r\n        let protocolPromise: Promise<Protocol>;\r\n\r\n        if (connection.protocolVersion === 3) {\r\n            protocolPromise = gW3ProtocolFactory(this.instance, connection, this.clientRepository, this.serverRepository, configuration, this);\r\n        } else {\r\n            throw new Error(`protocol ${connection.protocolVersion} not supported`);\r\n        }\r\n\r\n        // wait for protocol to resolve\r\n        this.readyPromise = protocolPromise.then((protocol: Protocol) => {\r\n            this.protocol = protocol;\r\n            this.client = new Client(this.protocol, this.clientRepository, this.instance, configuration);\r\n            this.server = new Server(this.protocol, this.serverRepository);\r\n            return this;\r\n        });\r\n    }\r\n\r\n    public ready() {\r\n        return this.readyPromise;\r\n    }\r\n\r\n    public serverRemoved(callback: (instance: Glue42Core.AGM.Instance, reason: string) => void): UnsubscribeFunction {\r\n        return this.client.serverRemoved(callback);\r\n    }\r\n\r\n    public serverAdded(callback: (instance: Glue42Core.AGM.Instance) => void): UnsubscribeFunction {\r\n        return this.client.serverAdded(callback);\r\n    }\r\n\r\n    public serverMethodRemoved(callback: (info: { server: Glue42Core.AGM.Instance; method: Glue42Core.AGM.Method; }) => void): UnsubscribeFunction {\r\n        return this.client.serverMethodRemoved(callback);\r\n    }\r\n\r\n    public serverMethodAdded(callback: (info: { server: Glue42Core.AGM.Instance; method: Glue42Core.AGM.Method; }) => void): UnsubscribeFunction {\r\n        return this.client.serverMethodAdded(callback);\r\n    }\r\n\r\n    public methodRemoved(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.client.methodRemoved(callback);\r\n    }\r\n\r\n    public methodAdded(callback: (def: Glue42Core.AGM.Method) => void): UnsubscribeFunction {\r\n        return this.client.methodAdded(callback);\r\n    }\r\n\r\n    public methodsForInstance(instance: Glue42Core.AGM.Instance): Glue42Core.Interop.Method[] {\r\n        return this.client.methodsForInstance(instance);\r\n    }\r\n\r\n    public methods(methodFilter: Glue42Core.AGM.MethodDefinition): Glue42Core.Interop.Method[] {\r\n        return this.client.methods(methodFilter);\r\n    }\r\n\r\n    public servers(methodFilter: Glue42Core.AGM.MethodDefinition): Glue42Core.AGM.Instance[] {\r\n        return this.client.servers(methodFilter);\r\n    }\r\n\r\n    public subscribe(method: string, options: Glue42Core.AGM.SubscriptionParams, successCallback?: (subscription: Glue42Core.AGM.Subscription) => void, errorCallback?: (err: SubscribeError) => void): Promise<Glue42Core.AGM.Subscription> {\r\n        return this.client.subscribe(method, options, successCallback, errorCallback);\r\n    }\r\n\r\n    public createStream(streamDef: string | Glue42Core.AGM.MethodDefinition, callbacks: Glue42Core.AGM.StreamOptions, successCallback?: (args?: object) => void, errorCallback?: (error?: string | object) => void): Promise<Glue42Core.AGM.Stream> {\r\n        return this.server.createStream(streamDef, callbacks, successCallback, errorCallback);\r\n    }\r\n\r\n    public unregister(methodFilter: string | Glue42Core.AGM.MethodDefinition): Promise<void> {\r\n        return this.server.unregister(methodFilter);\r\n    }\r\n\r\n    public registerAsync(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: any, caller: Glue42Core.AGM.Instance, successCallback: (args?: any) => void, errorCallback: (error?: string | object) => void) => void): Promise<void> {\r\n        return this.server.registerAsync(methodDefinition, callback);\r\n    }\r\n\r\n    public register(methodDefinition: string | Glue42Core.AGM.MethodDefinition, callback: (args: any, caller: Glue42Core.AGM.Instance) => any | Promise<void>): Promise<void> {\r\n        return this.server.register(methodDefinition, callback);\r\n    }\r\n\r\n    public invoke(methodFilter: string | Glue42Core.AGM.MethodDefinition, argumentObj?: object, target?: Glue42Core.AGM.InstanceTarget | Glue42Core.AGM.Instance | Glue42Core.AGM.Instance[], additionalOptions?: Glue42Core.AGM.InvokeOptions, success?: (result: Glue42Core.AGM.InvocationResult<any>) => void, error?: (error: { method: Glue42Core.AGM.MethodDefinition; called_with: object; executed_by: Glue42Core.AGM.Instance; message: string; status: number; returned: object; }) => void): Promise<Glue42Core.AGM.InvocationResult<any>> {\r\n        return this.client.invoke(methodFilter, argumentObj, target, additionalOptions, success, error);\r\n    }\r\n\r\n    public waitForMethod(name: string): Promise<Glue42Core.Interop.Method> {\r\n        const pw = new PromiseWrapper<Glue42Core.Interop.Method>();\r\n        const unsubscribe = this.client.methodAdded((m) => {\r\n            if (m.name === name) {\r\n                unsubscribe();\r\n                pw.resolve(m);\r\n            }\r\n        });\r\n\r\n        return pw.promise;\r\n    }\r\n}\r\n","import { Glue42Core } from \"../../glue\";\r\nimport Connection from \"../connection/connection\";\r\nimport { Logger } from \"../logger/logger\";\r\n\r\nexport interface BusSettings {\r\n    connection: Connection;\r\n    logger: Logger;\r\n}\r\ninterface SubscriptionEntry {\r\n    subscription_id: string;\r\n    topic: string;\r\n    callback: (data: object, topic: string, source: Glue42Core.Interop.Instance) => void;\r\n    source?: object;\r\n}\r\n\r\nconst successMessages = [\"subscribed\", \"success\"];\r\n\r\nexport class MessageBus implements Glue42Core.Bus.API {\r\n    public connection: Connection;\r\n    public logger: Logger;\r\n    public peerId: string;\r\n    public session: Glue42Core.Connection.GW3DomainSession;\r\n    public subscriptions: SubscriptionEntry[];\r\n    public readyPromise: Promise<object>;\r\n\r\n    constructor(connection: Connection, logger: Logger) {\r\n        this.connection = connection;\r\n        this.logger = logger;\r\n        this.peerId = connection.peerId;\r\n        this.subscriptions = [];\r\n        this.session = connection.domain(\"bus\", successMessages);\r\n        this.readyPromise = this.session.join();\r\n        this.readyPromise.then(() => {\r\n            this.watchOnEvent();\r\n        });\r\n    }\r\n\r\n    public ready() {\r\n        return this.readyPromise;\r\n    }\r\n\r\n    public publish = (topic: string, data: object, options?: Glue42Core.Bus.MessageOptions): void => {\r\n        const { routingKey, target } = options || {} as any;\r\n        const args = this.removeEmptyValues({\r\n            type: \"publish\",\r\n            topic,\r\n            data,\r\n            peer_id: this.peerId,\r\n            routing_key: routingKey,\r\n            target_identity: target\r\n        });\r\n        this.session.send(args);\r\n    }\r\n\r\n    public subscribe = (\r\n        topic: string,\r\n        callback: (data: object, topic: string, source: object) => void,\r\n        options?: Glue42Core.Bus.MessageOptions\r\n    ): Promise<Glue42Core.Bus.Subscription> => {\r\n        return new Promise((resolve, reject) => {\r\n            const { routingKey, target } = options || {} as any;\r\n            const args = this.removeEmptyValues({\r\n                type: \"subscribe\",\r\n                topic,\r\n                peer_id: this.peerId,\r\n                routing_key: routingKey,\r\n                source: target\r\n            });\r\n\r\n            this.session.send(args)\r\n                .then((response: any) => {\r\n                    const { subscription_id } = response;\r\n                    this.subscriptions.push({ subscription_id, topic, callback, source: target });\r\n\r\n                    resolve({\r\n                        unsubscribe: () => {\r\n                            this.session.send({ type: \"unsubscribe\", subscription_id, peer_id: this.peerId });\r\n                            this.subscriptions = this.subscriptions.filter((s) => s.subscription_id !== subscription_id);\r\n                            return Promise.resolve();\r\n                        }\r\n                    });\r\n                })\r\n                .catch((error: any) => reject(error));\r\n        });\r\n    }\r\n\r\n    public watchOnEvent = () => {\r\n        this.session.on(\"event\", (args: any) => {\r\n            const { data, subscription_id } = args;\r\n            const source = args[\"publisher-identity\"];\r\n            const subscription = this.subscriptions.find((s) => s.subscription_id === subscription_id);\r\n\r\n            if (subscription) {\r\n                if (!subscription.source) {\r\n                    subscription.callback(data, subscription.topic, source);\r\n                } else {\r\n                    if (this.keysMatch(subscription.source, source)) {\r\n                        subscription.callback(data, subscription.topic, source);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private removeEmptyValues(obj: any) {\r\n        const cleaned: any = {};\r\n        Object.keys(obj).forEach((key) => {\r\n            if (obj[key] !== undefined && obj[key] !== null) {\r\n                cleaned[key] = obj[key];\r\n            }\r\n        });\r\n        return cleaned;\r\n    }\r\n\r\n    private keysMatch(obj1: any, obj2: any) {\r\n        const keysObj1 = Object.keys(obj1);\r\n        let allMatch = true;\r\n        keysObj1.forEach((key) => {\r\n            if (obj1[key] !== obj2[key]) {\r\n                allMatch = false;\r\n            }\r\n        });\r\n        return allMatch;\r\n    }\r\n}\r\n","import metrics from \"./metrics/main\";\r\nimport Connection from \"./connection/connection\";\r\nimport { Logger } from \"./logger/logger\";\r\nimport { Glue42Core } from \"../glue\";\r\nimport prepareConfig from \"./config\";\r\nimport timer, { getAllTimers } from \"./utils/timer\";\r\nimport Utils from \"./utils/utils\";\r\nimport { Timer } from \"./types\";\r\nimport { ContextsModule } from \"./contexts/contextsModule\";\r\nimport { ContextMessageReplaySpec } from \"./contexts/contextMessageReplaySpec\";\r\nimport { InteropSettings } from \"./interop/types\";\r\nimport Interop from \"./interop/interop\";\r\nimport { MessageBus } from \"./bus/main\";\r\nimport { version } from \"../package.json\";\r\nimport shortid from \"shortid\";\r\n\r\nconst GlueCore = (userConfig?: Glue42Core.Config, ext?: Glue42Core.Extension): Promise<Glue42Core.GlueCore> => {\r\n    const gdVersion: number | undefined = Utils.getGDMajorVersion();\r\n    let glue42gd: Glue42Core.GDObject | undefined;\r\n    let preloadPromise: Promise<any> = Promise.resolve();\r\n\r\n    if (gdVersion) {\r\n        if (gdVersion < 3) {\r\n            throw new Error(\"GD v2 is not supported. Use v4 of the API to run in that context.\");\r\n        } else if (gdVersion >= 3) {\r\n            glue42gd = window.glue42gd;\r\n            preloadPromise = window.gdPreloadPromise || preloadPromise;\r\n        }\r\n    }\r\n\r\n    const glueInitTimer = timer(\"glue\");\r\n\r\n    userConfig = userConfig || {};\r\n    ext = ext || {};\r\n    const internalConfig = prepareConfig(userConfig, ext, glue42gd);\r\n\r\n    // Init the GLUE namespace\r\n    let _connection: Connection;\r\n    let _interop: Interop;\r\n    let _logger: Logger;\r\n    let _metrics: Glue42Core.Metrics.API;\r\n    let _contexts: Glue42Core.Contexts.API;\r\n    let _bus: Glue42Core.Bus.API;\r\n    let _allowTrace: boolean; // true if trace logging is enabled\r\n\r\n    const libs: { [key: string]: any } = {};\r\n\r\n    function registerLib(name: string | string[], inner: any, t: Timer) {\r\n\r\n        _allowTrace = _logger.canPublish(\"trace\");\r\n        if (_allowTrace) {\r\n            _logger.trace(`registering ${name} module`);\r\n        }\r\n\r\n        const done = () => {\r\n            inner.initTime = t.stop();\r\n            inner.initEndTime = t.endTime;\r\n            inner.marks = t.marks;\r\n            if (_allowTrace) {\r\n                _logger.trace(`${name} is ready - ${t.endTime - t.startTime}`);\r\n            }\r\n        };\r\n\r\n        inner.initStartTime = t.startTime;\r\n        if (inner.ready) {\r\n            inner.ready().then(() => {\r\n                done();\r\n            });\r\n        } else {\r\n            done();\r\n        }\r\n\r\n        if (!Array.isArray(name)) {\r\n            name = [name];\r\n        }\r\n\r\n        name.forEach((n) => {\r\n            libs[n] = inner;\r\n            (GlueCore as any)[n] = inner;\r\n        });\r\n    }\r\n\r\n    function setupConnection(): Promise<object> {\r\n        const initTimer = timer(\"connection\");\r\n        _connection = new Connection(internalConfig.connection, _logger.subLogger(\"connection\"));\r\n\r\n        let authPromise: Promise<any> = Promise.resolve(internalConfig.auth);\r\n\r\n        // no auth - what we do in different protocol versions\r\n        if (internalConfig.connection && !internalConfig.auth) {\r\n            if (glue42gd) {\r\n                authPromise = glue42gd.getGWToken()\r\n                    .then((token) => {\r\n                        // initTimer.mark(\"got-gw-token\");\r\n                        return {\r\n                            gatewayToken: token\r\n                        };\r\n                    });\r\n            } else if (typeof window !== \"undefined\" && window?.glue42electron) {\r\n                if (typeof window.glue42electron.gwToken === \"string\") {\r\n                    authPromise = Promise.resolve({\r\n                        gatewayToken: window.glue42electron.gwToken\r\n                    });\r\n                }\r\n            } else {\r\n                // assign to auth promise so we ca cleanup the connection\r\n                authPromise = Promise.reject(\"You need to provide auth information\");\r\n            }\r\n        }\r\n\r\n        return authPromise\r\n            .then((authConfig) => {\r\n                initTimer.mark(\"auth-promise-resolved\");\r\n                // convert the authConfig to AuthRequest object\r\n                let authRequest: Glue42Core.Auth;\r\n                if (Object.prototype.toString.call(authConfig) === \"[object Object]\") {\r\n                    authRequest = authConfig;\r\n                } else {\r\n                    throw new Error(\"Invalid auth object - \" + JSON.stringify(authConfig));\r\n                }\r\n                // do the login\r\n                return _connection.login(authRequest);\r\n            })\r\n            .then(() => {\r\n                registerLib(\"connection\", _connection, initTimer);\r\n                return internalConfig;\r\n            })\r\n            .catch((e) => {\r\n                if (_connection) {\r\n                    _connection.logout();\r\n                }\r\n                throw e;\r\n            });\r\n    }\r\n\r\n    function setupLogger(): Promise<void> {\r\n        // Logger\r\n        const initTimer = timer(\"logger\");\r\n        _logger = new Logger(`${internalConfig.connection.identity?.application}`, undefined, internalConfig.customLogger);\r\n        _logger.consoleLevel(internalConfig.logger.console);\r\n        _logger.publishLevel(internalConfig.logger.publish);\r\n\r\n        if (_logger.canPublish(\"debug\")) {\r\n            _logger.debug(\"initializing glue...\");\r\n        }\r\n        registerLib(\"logger\", _logger, initTimer);\r\n\r\n        return Promise.resolve(undefined);\r\n    }\r\n\r\n    function setupMetrics(): Promise<void> {\r\n        const initTimer = timer(\"metrics\");\r\n        const config = internalConfig.metrics;\r\n\r\n        const metricsPublishingEnabledFunc = glue42gd?.getMetricsPublishingEnabled;\r\n        const identity = internalConfig.connection.identity;\r\n        const canUpdateMetric = metricsPublishingEnabledFunc ? metricsPublishingEnabledFunc : () => true;\r\n        const disableAutoAppSystem: boolean = (typeof config !== \"boolean\" && config.disableAutoAppSystem) ?? false;\r\n        _metrics = metrics({\r\n            connection: config ? _connection : undefined,\r\n            logger: _logger.subLogger(\"metrics\"),\r\n            canUpdateMetric,\r\n            system: \"Glue42\",\r\n            service: identity?.service ?? glue42gd?.applicationName ?? internalConfig.application,\r\n            instance: identity?.instance ?? identity?.windowId ?? shortid(),\r\n            disableAutoAppSystem,\r\n            pagePerformanceMetrics: typeof config !== \"boolean\" ? config?.pagePerformanceMetrics : undefined\r\n        });\r\n\r\n        registerLib(\"metrics\", _metrics, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function setupInterop(): Promise<void> {\r\n        const initTimer = timer(\"interop\");\r\n\r\n        const agmConfig: InteropSettings = {\r\n            connection: _connection,\r\n            logger: _logger.subLogger(\"interop\"),\r\n        };\r\n\r\n        _interop = new Interop(agmConfig);\r\n        Logger.Interop = _interop;\r\n        registerLib([\"interop\", \"agm\"], _interop, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function setupContexts() {\r\n        const hasActivities = ((internalConfig as any).activities && _connection.protocolVersion === 3);\r\n        const needsContexts = internalConfig.contexts || hasActivities;\r\n        if (needsContexts) {\r\n            const initTimer = timer(\"contexts\");\r\n\r\n            _contexts = new ContextsModule({\r\n                connection: _connection,\r\n                logger: _logger.subLogger(\"contexts\")\r\n            });\r\n            registerLib(\"contexts\", _contexts, initTimer);\r\n            return _contexts;\r\n\r\n            // NB: The shared contexts data is part of the global domain,\r\n            // which is joined implicitly and there is no 'Success' message\r\n            // to indicate that the initial state has arrived.\r\n            // We're relying on the fact that none of the other Glue libs\r\n            // rely on the shared contexts' state, and that the 'contexts'\r\n            // lib is created first so any other domain's success message\r\n            // will arrive after our state, so the contexts will be visible\r\n            // when the Glue promise resolves.\r\n        } else {\r\n            const replayer = _connection.replayer;\r\n            if (replayer) {\r\n                replayer.drain(ContextMessageReplaySpec.name);\r\n            }\r\n        }\r\n    }\r\n\r\n    async function setupBus(): Promise<void> {\r\n        if (!internalConfig.bus) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const initTimer = timer(\"bus\");\r\n        _bus = new MessageBus(_connection, _logger.subLogger(\"bus\"));\r\n        registerLib(\"bus\", _bus, initTimer);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    function setupExternalLibs(externalLibs: Glue42Core.ExternalLib[]): Promise<any> {\r\n        try {\r\n            externalLibs.forEach((lib) => {\r\n                setupExternalLib(lib.name, lib.create);\r\n            });\r\n\r\n            return Promise.resolve();\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    function setupExternalLib(name: string, createCallback: (core: any) => any) {\r\n        const initTimer = timer(name);\r\n        const lib = createCallback(libs);\r\n        if (lib) {\r\n            registerLib(name, lib, initTimer);\r\n        }\r\n    }\r\n\r\n    function waitForLibs(): Promise<object[]> {\r\n        // get all libs that have ready promises and wait for these to be ready\r\n        const libsReadyPromises = Object.keys(libs).map((key) => {\r\n            const lib = libs[key];\r\n            return lib.ready ?\r\n                lib.ready() : Promise.resolve();\r\n        });\r\n\r\n        return Promise.all(libsReadyPromises);\r\n    }\r\n\r\n    function constructGlueObject(): Glue42Core.GlueCore {\r\n\r\n        const feedbackFunc = (feedbackInfo?: Glue42Core.FeedbackInfo) => {\r\n            if (!_interop) {\r\n                return;\r\n            }\r\n            _interop.invoke(\"T42.ACS.Feedback\", feedbackInfo, \"best\");\r\n        };\r\n\r\n        const info: { [key: string]: any } = {\r\n            coreVersion: version,\r\n            version: internalConfig.version\r\n        };\r\n\r\n        glueInitTimer.stop();\r\n\r\n        const glue: Glue42Core.GlueCore & ({ [key: string]: any }) = {\r\n            feedback: feedbackFunc,\r\n            info,\r\n            logger: _logger,\r\n            interop: _interop,\r\n            agm: _interop,\r\n            connection: _connection,\r\n            metrics: _metrics,\r\n            contexts: _contexts,\r\n            bus: _bus,\r\n            version: internalConfig.version,\r\n            userConfig,\r\n            done: () => {\r\n                _logger?.info(`done called by user...`);\r\n                return _connection.logout();\r\n            }\r\n        };\r\n\r\n        // ver performance\r\n        glue.performance = {\r\n            get glueVer() {\r\n                return internalConfig.version;\r\n            },\r\n            get glueConfig() {\r\n                return JSON.stringify(userConfig);\r\n            },\r\n            get browser() {\r\n                return window.performance.timing.toJSON();\r\n            },\r\n            get memory() {\r\n                return (window as any).performance.memory;\r\n            },\r\n            get initTimes() {\r\n                const all = getAllTimers();\r\n                return Object.keys(all).map((key) => {\r\n                    const t = all[key];\r\n                    return {\r\n                        name: key,\r\n                        duration: t.endTime - t.startTime,\r\n                        marks: t.marks,\r\n                        startTime: t.startTime,\r\n                        endTime: t.endTime\r\n                    };\r\n                });\r\n            }\r\n        };\r\n\r\n        // attach each lib to glue\r\n        Object.keys(libs).forEach((key) => {\r\n            const lib = libs[key];\r\n            glue[key] = lib;\r\n        });\r\n\r\n        // construct the config object to be exposed to end user\r\n        // transfer config keys from internalConfig and then ext\r\n        glue.config = {};\r\n\r\n        Object.keys(internalConfig).forEach((k) => {\r\n            glue.config[k] = (internalConfig as any)[k];\r\n        });\r\n\r\n        if (ext && ext.extOptions) {\r\n            Object.keys(ext.extOptions).forEach((k) => {\r\n                glue.config[k] = ext?.extOptions[k];\r\n            });\r\n        }\r\n\r\n        if (ext?.enrichGlue) {\r\n            ext.enrichGlue(glue);\r\n        }\r\n\r\n        if (glue42gd && glue42gd.updatePerfData) {\r\n            glue42gd.updatePerfData(glue.performance);\r\n        }\r\n\r\n        if (glue.agm) {\r\n            const deprecatedDecorator = (fn: any, wrong: string, proper: string) => {\r\n                // tslint:disable-next-line:only-arrow-functions\r\n                return function() {\r\n                    // tslint:disable-next-line:no-console\r\n                    glue.logger.warn(`glue.js - 'glue.agm.${wrong}' method is deprecated, use 'glue.interop.${proper}' instead.`);\r\n                    return fn.apply(glue.agm, arguments);\r\n                };\r\n            };\r\n            // extend glue.agm with legacy support\r\n            const agmAny: any = glue.agm;\r\n            agmAny.method_added = deprecatedDecorator(glue.agm.methodAdded, \"method_added\", \"methodAdded\");\r\n            agmAny.method_removed = deprecatedDecorator(glue.agm.methodRemoved, \"method_removed\", \"methodRemoved\");\r\n            agmAny.server_added = deprecatedDecorator(glue.agm.serverAdded, \"server_added\", \"serverAdded\");\r\n            agmAny.server_method_aded = deprecatedDecorator(glue.agm.serverMethodAdded, \"server_method_aded\", \"serverMethodAdded\");\r\n            agmAny.server_method_removed = deprecatedDecorator(glue.agm.serverMethodRemoved, \"server_method_removed\", \"serverMethodRemoved\");\r\n        }\r\n        return glue;\r\n    }\r\n\r\n    return preloadPromise\r\n        .then(setupLogger)\r\n        .then(setupConnection)\r\n        .then(() => Promise.all([setupMetrics(), setupInterop(), setupContexts(), setupBus()]))\r\n        .then(() => _interop.readyPromise)\r\n        .then(() => {\r\n            return setupExternalLibs(internalConfig.libs || []);\r\n        })\r\n        .then(waitForLibs)\r\n        .then(constructGlueObject)\r\n        .catch((err) => {\r\n            // if there is some some error include the libs object for debugging purposes\r\n            return Promise.reject({\r\n                err,\r\n                libs\r\n            });\r\n        });\r\n};\r\n\r\nif (typeof window !== \"undefined\") {\r\n    (window as any).GlueCore = GlueCore;\r\n}\r\n(GlueCore as any).version = version;\r\n// add default library for ES6 modules\r\n(GlueCore as any).default = GlueCore;\r\n\r\nexport default GlueCore;\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { Glue42Core } from \"../glue\";\r\nimport { InternalConfig, GDStaringContext } from \"./types\";\r\nimport generate from \"shortid\";\r\nimport Utils from \"./utils/utils\";\r\nimport { ContextMessageReplaySpec } from \"./contexts/contextMessageReplaySpec\";\r\nimport { version as pjsonVersion } from \"../package.json\";\r\nimport { ConnectionSettings } from \"./connection/types\";\r\n\r\nexport default function (configuration: Glue42Core.Config, ext: Glue42Core.Extension, glue42gd: Glue42Core.GDObject | undefined): InternalConfig {\r\n\r\n    let nodeStartingContext: GDStaringContext;\r\n    if (Utils.isNode()) {\r\n        const startingContextString = process.env._GD_STARTING_CONTEXT_;\r\n        if (startingContextString) {\r\n            try {\r\n                nodeStartingContext = JSON.parse(startingContextString);\r\n            } catch {\r\n                // Do nothing - we will continue with the flow as if there is no starting context\r\n            }\r\n        }\r\n    }\r\n\r\n    function getConnection(): ConnectionSettings {\r\n\r\n        const gwConfig = configuration.gateway;\r\n\r\n        const protocolVersion = gwConfig?.protocolVersion ?? 3;\r\n        const reconnectInterval = gwConfig?.reconnectInterval;\r\n        const reconnectAttempts = gwConfig?.reconnectAttempts;\r\n\r\n        const defaultWs = \"ws://localhost:8385\";\r\n        let ws = gwConfig?.ws;\r\n        const sharedWorker = gwConfig?.sharedWorker;\r\n        const inproc = gwConfig?.inproc;\r\n        const webPlatform = gwConfig?.webPlatform ?? undefined;\r\n\r\n        // If running in GD use the injected ws URL\r\n        if (glue42gd) {\r\n            // GD3\r\n            ws = glue42gd.gwURL;\r\n        }\r\n        // if running in Node app, started from GD, use the ws from starting context\r\n        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwURL) {\r\n            ws = nodeStartingContext.gwURL;\r\n        }\r\n\r\n        // if nothing specified use default WS\r\n        if (!ws && !sharedWorker && !inproc) {\r\n            ws = defaultWs;\r\n        }\r\n\r\n        let instanceId: string | undefined;\r\n        let windowId: string | undefined;\r\n        let pid: number | undefined;\r\n        let environment: string | undefined;\r\n        let region: string | undefined;\r\n        const appName = getApplication();\r\n        let uniqueAppName = appName;\r\n        if (typeof glue42gd !== \"undefined\") {\r\n            windowId = glue42gd.windowId;\r\n            pid = glue42gd.pid;\r\n            if (glue42gd.env) {\r\n                environment = glue42gd.env.env;\r\n                region = glue42gd.env.region;\r\n            }\r\n            // G4E-1668\r\n            uniqueAppName = glue42gd.application ?? \"glue-app\";\r\n            instanceId = glue42gd.appInstanceId;\r\n        } else if (Utils.isNode()) {\r\n            pid = process.pid;\r\n            if (nodeStartingContext) {\r\n                environment = nodeStartingContext.env;\r\n                region = nodeStartingContext.region;\r\n                instanceId = nodeStartingContext.instanceId;\r\n            }\r\n        } else if (typeof window?.glue42electron !== \"undefined\") {\r\n            windowId = window?.glue42electron.instanceId;\r\n            pid = window?.glue42electron.pid;\r\n            environment = window?.glue42electron.env;\r\n            region = window?.glue42electron.region;\r\n            // G4E-1668\r\n            uniqueAppName = window?.glue42electron.application ?? \"glue-app\";\r\n            instanceId = window?.glue42electron.instanceId;\r\n        } else {\r\n            // this is the case where this is is running in Glue42 Core V2\r\n            // in this case the windowId of the identity is set by the WebTransport, because it needs to communicate with possible parents\r\n        }\r\n\r\n        // replay specs for core connection\r\n        const replaySpecs = configuration.gateway?.replaySpecs ?? [];\r\n        // inject Context message replay\r\n        replaySpecs.push(ContextMessageReplaySpec);\r\n\r\n        let identity = {\r\n            application: uniqueAppName,\r\n            applicationName: appName,\r\n            windowId,\r\n            instance: instanceId,\r\n            process: pid,\r\n            region,\r\n            environment,\r\n            api: ext.version || pjsonVersion\r\n        };\r\n\r\n        if (configuration.identity) {\r\n            identity = Object.assign(identity, configuration.identity);\r\n        }\r\n\r\n        return {\r\n            identity,\r\n            reconnectInterval,\r\n            ws,\r\n            sharedWorker,\r\n            webPlatform,\r\n            inproc,\r\n            protocolVersion,\r\n            reconnectAttempts,\r\n            replaySpecs,\r\n        };\r\n    }\r\n\r\n    function getApplication() {\r\n        if (configuration.application) {\r\n            return configuration.application;\r\n        }\r\n\r\n        if (glue42gd) {\r\n            return glue42gd.applicationName;\r\n        }\r\n\r\n        if (typeof window !== \"undefined\" && typeof (window as any).glue42electron !== \"undefined\") {\r\n            return (window as any).glue42electron.application;\r\n        }\r\n\r\n        const uid = generate();\r\n        if (Utils.isNode()) {\r\n            if (nodeStartingContext) {\r\n                return nodeStartingContext.applicationConfig.name;\r\n            }\r\n\r\n            return \"NodeJS\" + uid;\r\n        }\r\n\r\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n            return document.title + ` (${uid})`;\r\n        }\r\n\r\n        return uid;\r\n    }\r\n\r\n    function getAuth(): Glue42Core.Auth | undefined {\r\n        if (typeof configuration.auth === \"string\") {\r\n            return {\r\n                token: configuration.auth\r\n            };\r\n        }\r\n\r\n        if (configuration.auth) {\r\n            return configuration.auth;\r\n        }\r\n\r\n        if (Utils.isNode() && nodeStartingContext && nodeStartingContext.gwToken) {\r\n            return {\r\n                gatewayToken: nodeStartingContext.gwToken\r\n            };\r\n        }\r\n\r\n        if (configuration.gateway?.webPlatform || configuration.gateway?.inproc || configuration.gateway?.sharedWorker) {\r\n            return {\r\n                username: \"glue42\", password: \"glue42\"\r\n            };\r\n        }\r\n    }\r\n\r\n    function getLogger(): { console: Glue42Core.LogLevel; publish: Glue42Core.LogLevel } {\r\n        let config = configuration.logger;\r\n        const defaultLevel = \"warn\";\r\n        if (!config) {\r\n            config = defaultLevel;\r\n        }\r\n\r\n        // console level can be overridden by a gd setting\r\n        let gdConsoleLevel: Glue42Core.LogLevel | undefined;\r\n        if (glue42gd) {\r\n            gdConsoleLevel = glue42gd.consoleLogLevel;\r\n        }\r\n\r\n        if (typeof config === \"string\") {\r\n            return { console: gdConsoleLevel ?? config, publish: defaultLevel };\r\n        }\r\n\r\n        return {\r\n            console: gdConsoleLevel ?? config.console ?? defaultLevel,\r\n            publish: config.publish ?? defaultLevel\r\n        };\r\n    }\r\n\r\n    const connection = getConnection();\r\n    let application: string = getApplication();\r\n    if (typeof window !== \"undefined\") {\r\n        const windowAsAny = window as any;\r\n        const containerApplication = windowAsAny.htmlContainer ?\r\n            `${windowAsAny.htmlContainer.containerName}.${windowAsAny.htmlContainer.application}` :\r\n            windowAsAny?.glue42gd?.application;\r\n        if (containerApplication) {\r\n            application = containerApplication;\r\n        }\r\n    }\r\n\r\n    return {\r\n        bus: configuration.bus ?? false,\r\n        application,\r\n        auth: getAuth(),\r\n        logger: getLogger(),\r\n        connection,\r\n        metrics: configuration.metrics ?? true,\r\n        contexts: configuration.contexts ?? true,\r\n        version: ext.version || pjsonVersion,\r\n        libs: ext.libs ?? [],\r\n        customLogger: configuration.customLogger\r\n    };\r\n}\r\n"],"names":["getMetricTypeByValue","metric","type","MetricTypes","getTypeByValue","value","constructor","Date","serializeMetric","serializedMetrics","values","Object","keys","reduce","memo","key","innerType","composite","defineNestedComposite","description","context","name","normalizeMetricName","path","join","length","getMetricValueByType","now","publishNestedComposite","getTime","Boolean","toString","composeMsgForRootStateMetric","system","merged","flatten","arr","flat","toFlatten","concat","Array","isArray","root","getAggregateState","highestState","sort","a","b","state","msg","forEach","m","idx","slice","aggregateDescription","definition","parent","transport","Error","this","Helpers","push","createMetric","BaseMetric","repo","newValue","updateMetric","_super","metricTypes","__extends","NumberMetric","num","update","incrementBy","ObjectMetric","mergeValues","k","_this","TimestampMetric","options","protocol","init","separator","_transport","_name","_description","_repo","_parent","_path","_buildPath","shadowedSystem","_state","id","_subSystems","_metrics","_getOrCreateMetric","metricObject","expectedType","metricDef","matching","filter","shadowedMetric","existing","catch","me","subSystems","metrics","subSystem","nameSystem","descriptionSystem","match","s","_system","getState","setState","stateDescription","updateSystem","stringMetric","StringMetric","timestampMetric","objectMetric","numberMetric","aggState","shadowedSubSystem","result","createSystem","addSystemMetrics","clickStream","undefined","Repository","rootSystem","useClickStream","navigator","userAgent","document","clickStream_1","documentClickHandler","e","target","className","getAttribute","timestamp","tagName","toLowerCase","href","title","page","window","location","addEventListener","attachEvent","urlMetric","appNameMetric","startUrl","glue42gd","appName","NullProtocol","Promise","resolve","api","initialPublishTimeout","publishInterval","scheduleCollection","PerfTracker","setTimeout","collect","setInterval","collectMemory","collectEntries","memory","performance","JSON","stringify","totalJSHeapSize","usedJSHeapSize","allEntries","getEntries","lastCount","jsonfiedEntries","map","i","toJSON","connection","config","joinPromise","session","replayRepo","replaySystem","ss","_a","Description","Value","createMetricsMsg","send","metricClone","cloneMetric","updateMetricCore","canUpdate","publishMetricsMsg","sendFireAndForget","canUpdateMetric","resolveReadyPromise","domain","onJoined","reconnect","defineRootMetricsMsg","service","instance","shadowedUpdateMetric","stateObj","rootMetric","peer_id","peerId","gw3","disableAutoAppSystem","featureMetric","reportingSystem","def","featureMetricFunc","action","payload","addFAVSupport","perfConfig","pagePerformanceMetrics","enabled","initPerf","createRegistry","errorHandling","_userErrorHandler","callbacks","_handleError","exceptionArtifact","errParam","stack","console","error","add","callback","replayArgumentsArr","callbacksForKey","replayArgument","includes","apply","err","allForKey","acc","element","index","execute","argumentsArr","_i","arguments","results","clear","clearKey","default","settings","logger","CallbackRegistryFactory","gw","facade","connect","_client","message","messageHandler","then","client","InProcTransport","reject","_msg","registry","workerFile","worker","SharedWorker","port","onmessage","data","SharedWorkerTransport","postMessage","Utils","glueDesktop","version","ver","Number","substr","isNaN","_isNode","prototype","call","global","process","promise","t","resolved","rejected","PromiseWrapper","time","timers","timerName","marks","endTime","period","startTime","mark","currentTime","diff","timerObj","stop","WebSocketConstructor","isNode","require","WebSocket","timer","ws","WS","_registry","waitForSocketConnection","info","_running","close","pw","failed","readyState","wsRequests","openSocket","retryInterval","retriesLeft","startupTimer","reconnectInterval","notifyForSocketState","debug","initiateSocket","_b","retries","onerror","reason","seen_1","WeakSet","has","notifyStatusChanged","onclose","onopen","identity","application","wsRequest","status","seed","alphabet","previousSeed","shuffled","nextValue","_seed_","ORIGINAL","reset","setCharacters","_alphabet_","unique","split","item","ind","lastIndexOf","getShuffled","characterIndex","sourceArray","targetArray","r","randomFromSeed","Math","floor","splice","shuffle","characters","lookup","crypto","msCrypto","getRandomValues","random","dest","Uint8Array","number","done","loopCounter","str","randomByte","pow","indexOf","len","counter","previousSeconds","clusterWorkerId","generate","seconds","encode","module","seedValue","exports","workerId","newCharacters","decode","isValid","require$$0","successMessages","errorMessages","_latestOptions","isJoined","tryReconnecting","_connectionOn","disconnected","loggedIn","on","handleSuccessMessage","handleErrorMessage","sm","requestsMap","destination","wasReconnect","handleJoined","requestId","request_id","entry","success","getNextRequestId","tag","skipPeerId","successMsg","_tag","errorMsg","warn","leave","onLeft","connected","datePrefix","datePrefixLen","handleDisconnected","ping","GW3ProtocolImpl","_isLoggedIn","parse","dateMinLen","datePrefixFirstChar","substring","milliseconds","parseInt","ex","msgType","oldToJson","datePrefix_1","loginConfig","username","password","shouldTryLogin","authentication","gatewayToken","getNewGWToken","token","_c","e_1","method","flowName","provider","flowCallback","sessionId","login","secret","helloMsg","globalDomain","domainSession","subLogger","sendOptions","initialLogin","maxRetries","reconnectAttempts","welcomeMsg","Buffer","from","resolvedIdentity","resolved_identity","availableDomains","available_domains","access_token","setLoggedIn","err_1","pingTimer","clearTimeout","promises","sessions","all","domainName","domainLogger","initialLoginAttempts","bind","res","getGWToken","specs","specs_1","spec","specsNames","MessageReplayerImpl","name_1","refCount","this_1","subsRefCount","sub","processMessage","subs","types","isDone","name_2","messages","off","PromisePlus","executor","timeoutMilliseconds","timeoutMessage","timeout","connectionAccepted","handle","handleConnectionAccepted","connectionRejected","handleConnectionRejected","connectionRequest","handleConnectionRequest","parentReady","handleParentReady","parentPing","handleParentPing","platformPing","handlePlatformPing","platformUnload","handlePlatformUnload","platformReady","handlePlatformReady","clientUnload","handleClientUnload","manualUnload","handleManualUnload","extConnectionResponse","handleExtConnectionResponse","extSetupRequest","handleExtSetupRequest","extContentAvailable","glue42ext","setUpMessageListener","setUpUnload","opener","top","parentType","WebPlatformTransport","publicWindowId","extContentConnected","glue42ExtOut","defaultTargetString","windowId","event","waitParent","parentInExtMode","requestConnectionPermissionFromExt","initiateRemoteConnection","connectionResolve","connectionReject","myClientId","bridgeInstanceId","request","glue42core","clientId","clientType","extContentConnecting","parentWindowId","connectionRequestTimeout","connectionNotPossibleMsg","parentCheck","isIframe","self","parentPingResolve","parentPingTimeout","checkMessageTypeValid","messageType","ownWindowId","extMode","handleAcceptanceOfMyRequest","handleAcceptanceOfGrandChildRequest","processExtContentConnection","applicationName","extData","glue42ExtInc","child","children","find","c","grandChildId","source","origin","rejectConnectionRequest","iAmConnected","typeToValidate","rejection","waitForContentScript","extConnectionResolve","extConnectionReject","approved","content","CallbackFactory","inproc","sharedWorker","webPlatform","isTrace","canPublish","onConnectedChanged","handleConnectionChanged","onMessage","handleTransportMessage","replaySpecs","replayer","Connection","protocolVersion","sendObject","isObjectBasedTransport","createObjectMessage","trace","strMessage","createStringMessage","messageHandlers","ids","isLoggedIn","authRequest","open","logout","authToken","handlers","handlerId","handler","loggerError","log","_connected","msgObj","processStringMessage","processObjectMessage","distributeMessage","order","logFn","loggerFullName","includeTimeAndLevel","customLogFn","Logger","existingSub","subLoggers","level","_publishLevel","publishLevel","_consoleLevel","consoleLevel","publishMessage","compareWith","loggerName","interop","Interop","methods","InteropMethodName","invoke","prefix","date","getHours","getMinutes","getSeconds","getMilliseconds","toPrint","GW_MESSAGE_CREATE_CONTEXT","GW_MESSAGE_ACTIVITY_CREATED","GW_MESSAGE_ACTIVITY_DESTROYED","GW_MESSAGE_CONTEXT_CREATED","GW_MESSAGE_CONTEXT_ADDED","GW_MESSAGE_SUBSCRIBE_CONTEXT","GW_MESSAGE_SUBSCRIBED_CONTEXT","GW_MESSAGE_UNSUBSCRIBE_CONTEXT","GW_MESSAGE_DESTROY_CONTEXT","GW_MESSAGE_CONTEXT_DESTROYED","GW_MESSAGE_UPDATE_CONTEXT","GW_MESSAGE_CONTEXT_UPDATED","GW_MESSAGE_JOINED_ACTIVITY","ContextMessageReplaySpec","msg.GW_MESSAGE_CREATE_CONTEXT","msg.GW_MESSAGE_ACTIVITY_CREATED","msg.GW_MESSAGE_ACTIVITY_DESTROYED","msg.GW_MESSAGE_CONTEXT_CREATED","msg.GW_MESSAGE_CONTEXT_ADDED","msg.GW_MESSAGE_SUBSCRIBE_CONTEXT","msg.GW_MESSAGE_SUBSCRIBED_CONTEXT","msg.GW_MESSAGE_UNSUBSCRIBE_CONTEXT","msg.GW_MESSAGE_DESTROY_CONTEXT","msg.GW_MESSAGE_CONTEXT_DESTROYED","msg.GW_MESSAGE_UPDATE_CONTEXT","msg.GW_MESSAGE_CONTEXT_UPDATED","msg.GW_MESSAGE_JOINED_ACTIVITY","contextId","isAnnounced","activityId","GW3ContextData","updateCallbacks","hasCallbacks","applyContextDelta","delta","deepClone","commands","command","deletePath","setValueToPath","added_1","added","updated_1","updated","removed","mergeObjectsProperties","obj","hash","WeakMap","Set","get","RegExp","flags","create","set","Map","val","assign","what","withWhat","right","left","deepEqual","x","y","p","hasOwnProperty","pathArr","InvokeStatus","_connection","_logger","_gw3Session","subscribeToContextCreatedMessages","subscribeToContextUpdatedMessages","subscribeToContextDestroyedMessages","drain","handleContextCreatedMessage","handleContextUpdatedMessage","handleContextDestroyedMessage","GW3Bridge","_protocolVersion","contextsDomainInfo","d","uri","_gw3Subscriptions","contextName","_contextNameToData","_contextNameToId","lifetime","createContextMsg","context_id","_contextIdToName","contextData","ContextData","hasReceivedSnapshot","currentContext","createContext","calculatedDelta","calculateContextDeltaV2","calculateContextDeltaV1","gwResponse","handleUpdated","updaterId","setPathSupported","setPaths","pathValues","pathValues_1","pathValue","pathValues_2","_","subscribe","_d","_r","un","unsubscribe","thisCallbackSubscriptionNumber","_nextCallbackSubscriptionNumber","hadCallbacks","clone","joinedActivity","sentExplicitSubscription","sendSubscribe","subscriptionKey","sendUnsubscribe","extraData","oldContext","invokeUpdateCallbacks","createdMessageTypes_1","createdMessageType","contextCreatedMsg","activity_id","updatedMessageTypes_1","updatedMessageType","contextUpdatedMsg","justSeen","context_snapshot","updater_id","updateCallbackIndex","updateCallback","destroyedMessageTypes_1","destroyedMessageType","destroyedMsg","to","_bridge","ContextsModule","checkName","checkData","checkPath","setPath","paths","paths_1","destroy","successCallback","errorCallback","rejectAfter","ms","clearTimeoutIfThere","configuration","Client","callProtocolSubscribe","targetServers","stream","successProxy","errorProxy","methodResponseTimeout","waitTimeoutMs","promisify","methodDef","method_response_timeout","wait_for_method_timeout","delayTillNow","currentServers","getServerMethodsByFilterAndTarget","retry_1","streamInfo","methodFilter","filterCopy","getServers","serverMethodMap","server","getMethods","getMethodsForInstance","onMethodAdded","onMethodRemoved","onServerAdded","onServerRemoved","onServerMethodAdded","onServerMethodRemoved","argumentObj","additionalOptions","methodDefinition","methodResponseTimeoutMs","serversMethodMap","tryToAwaitForMethods","supportsStreaming","objectTypes","metadata","errorObj","called_with","executed_by","returned","additionalOptionsCopy","invokePromises","serversMethodPair","invId","invokePromise","race","invocationId","invocationMessages","getInvocationResultObj","every","getInvokePromise","invocationResults","calledWith","all_return_values","invokeMessage","Success","allValues","currentValue","all_errors","allErrors","currError","invResult","interval","clearInterval","matches","myMatches","serverMethodPair","instanceMatch","localMachine","isLocal","instanceFilter","instanceDefinition","containsProps","repoMethod","prop","isMatch","filterValue","repoMethodValue","filterValueEl","isSubset","superObj","subObj","ele","String","methodMatch","matchingServers","resultMethodsObject","methodKey","identifier","servers","prev","current","matchingMethods","filterByTarget","subscription","ServerSubscription","branchKey","closeSingleSubscription","pushDataToSingle","requestContext","Request","acceptRequestOnBranch","branch","rejectRequest","onSubRequest","rc","rm","handleSubRequest","onSubAdded","handleSubAdded","onSubRemoved","handleSubRemoved","ServerStreaming","streamCallbacks","subscriptionRequestHandler","subscriptionAddedHandler","subscriptionRemovedHandler","ServerBranch","getSubscriptionList","closeAllSubscriptions","pushData","_protocol","_repoMethod","_server","ServerStream","bList","getBranchList","branches","def2","accepts","displayName","returns","unregister","serverRepository","streaming","onInvoked","onMethodInvoked","Server","streamDef","existingStream","streamMethodDefinition","getList","some","serverMethod","accept","protocolState","createStream","streamUserObject","updateRepoMethod","repoId","remove","wrappedCallbackFunction","resultCallback","args","resultValue","userCallback","registerCore","wrappedCallback","resultCalled_1","methodResult","userCallbackAsync","forStream","unregisterWithPredicate","methodToBeRemoved","removeMethodsOrStreams","filterPredicate","methodsOrStreamsToRemove","methodsToRemove","methodUnregPromises","addAsCurrentlyUnregistering","methodName","currentlyUnregistering","theFunction","unregisterInProgress","register","methodToExecute","invocationArgs","unStrException","_value","methodInvocationResult","API","wrapped","methodsForInstance","getStreams","refreshWrappedObject","refresh","InstanceWrapper","user","pid","machine","environment","region","hideMethodSystemFlags","myServer","wrapper","unwrappedInstance","ClientRepository","serverId","serverEntry","unwrap","methodId","removeServerMethod","createMethodIdentifier","that","gatewayId","display_name","object_types","input_signature","result_signature","getServersByMethod","clientMethodDefinition","methodsCount","extractMethodsFromServers","hideServerMethodSystemFlags","unsubscribeFunc","serversWithMethodsToReplay","returnUnsubWithDelayedReplay","methodsToReplay","unsubCalled","removeServerById","methodInfo","allServers","collectionToReplay","clientMethods","entries","ServerRepository","nextId","TypeError","SUBSCRIPTION_REQUEST","SUBSCRIPTION_ADDED","SUBSCRIPTION_REMOVED","repository","handleAddInterest","handleRemoveInterest","streamingMethod","subscriptionsMap","branchKeyToStreamIdMap","streamId","getStreamId","subscription_id","subscribeMsg","stream_id","sendSubscriptionFailed","br","dropSubscriptionMessage","subscriptionsToClose","drop","allSubscriptions","onSubscriptionLifetimeEvent","getById","method_id","eventName","handlerFunc","nextStreamId","getServerById","caller_id","arguments_kv","subscriptionId","errorMessage","reason_uri","ERR_URI_SUBSCRIPTION_FAILED","needleBranch","getNextStreamId","clientRepository","handleInvokeMessage","ServerProtocol","isStreaming","registerMsg","restrictions","invocation_id","closeMultipleSubscriptions","callerId","subscriptionData","UserSubscription","params","trackedServers","pair","dataCallback","onData","queued","dataItem","closedCallback","onClosed","onConnected","newSub","STATUS_AWAITING_ACCEPT","STATUS_SUBSCRIBED","ERR_MSG_SUB_FAILED","ON_CLOSE_MSG_CLIENT_INIT","errorResponse","subLocalKey","pendingSub","subscriptionsList","timeoutId","callArgs","callOnClosedHandlers","acceptingServer","subscriptionIdToLocalKeyMap","isFirstResponse","setNewSubscription","serverInstance","trackedServersFound","isPrivateData","oob","sendingServerId","receivedStreamData","requestArguments","private","onDataHandlers","queuedData","expectedNewLength","closers","handleSubscribed","handleEventData","handleSubscriptionCancelled","ClientStreaming","getNextSubscriptionLocalKey","registerSubscription","server_id","handleErrorSubscribing","nextSubLocalKey","subsInfo","localKey","closeSubscription","closingServer","closersCount","closingServerId","handlePeerAdded","handlePeerRemoved","handleMethodsAddedMessage","handleMethodsRemovedMessage","ClientProtocol","handleResultMessage","handleInvocationError","drainSubscriptions","newPeerId","new_peer_id","remoteId","meta","local","serverInfo","addServer","removedPeerId","removed_id","addServerMethod","methodIdList","libConfig","readyPromise","existingSubscriptions_1","registeredMethods","registeredMethods_1","registerAsync","handleReconnect","protocolPromise","gW3ProtocolFactory","serverRemoved","serverAdded","serverMethodRemoved","serverMethodAdded","methodRemoved","methodAdded","topic","routingKey","removeEmptyValues","routing_key","target_identity","response","subscriptions","keysMatch","watchOnEvent","MessageBus","cleaned","obj1","obj2","keysObj1","allMatch","GlueCore","userConfig","ext","gdVersion","getGDMajorVersion","preloadPromise","gdPreloadPromise","_interop","_contexts","_bus","_allowTrace","glueInitTimer","internalConfig","nodeStartingContext","startingContextString","env","_GD_STARTING_CONTEXT_","getApplication","glue42electron","uid","applicationConfig","instanceId","gwConfig","gateway","gwURL","uniqueAppName","appInstanceId","pjsonVersion","getConnection","windowAsAny","containerApplication","htmlContainer","containerName","bus","auth","gwToken","getAuth","gdConsoleLevel","defaultLevel","consoleLogLevel","publish","getLogger","contexts","libs","customLogger","prepareConfig","registerLib","inner","initTime","initEndTime","initStartTime","ready","n","setupInterop","initTimer","agmConfig","setupContexts","hasActivities","activities","setupBus","setupExternalLibs","externalLibs","lib","createCallback","setupExternalLib","authPromise","authConfig","metricsPublishingEnabledFunc","getMetricsPublishingEnabled","shortid","libsReadyPromises","coreVersion","glue","feedback","feedbackInfo","agm","glueVer","glueConfig","browser","timing","initTimes","duration","extOptions","enrichGlue","updatePerfData","deprecatedDecorator","fn","wrong","proper","agmAny","method_added","method_removed","server_added","server_method_aded","server_method_removed"],"mappings":"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"}